"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_EmployeeList_tsx"],{

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/ObservableQuery.js":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/core/ObservableQuery.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObservableQuery: () => (/* binding */ ObservableQuery),\n/* harmony export */   logMissingFieldErrors: () => (/* binding */ logMissingFieldErrors)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./networkStatus.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/cloneDeep.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/promises/preventUnhandledRejection.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/iteration.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/subclassing.js\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../errors/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/errors/index.js\");\n/* harmony import */ var _equalByQuery_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./equalByQuery.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/equalByQuery.js\");\n/* harmony import */ var optimism__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! optimism */ \"(app-pages-browser)/./node_modules/optimism/lib/index.js\");\n\n\n\n\n\n\n\n\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n        var _this = this;\n        var startedInactive = ObservableQuery.inactiveOnCreation.getValue();\n        _this = _super.call(this, function (observer) {\n            if (startedInactive) {\n                queryManager[\"queries\"].set(_this.queryId, queryInfo);\n                startedInactive = false;\n            }\n            // Zen Observable has its own error function, so in order to log correctly\n            // we need to provide a custom error callback.\n            try {\n                var subObserver = observer._subscription._observer;\n                if (subObserver && !subObserver.error) {\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\n                }\n            }\n            catch (_a) { }\n            var first = !_this.observers.size;\n            _this.observers.add(observer);\n            // Deliver most recent error or result.\n            var last = _this.last;\n            if (last && last.error) {\n                observer.error && observer.error(last.error);\n            }\n            else if (last && last.result) {\n                observer.next && observer.next(_this.maskResult(last.result));\n            }\n            // Initiate observation of this query if it hasn't been reported to\n            // the QueryManager yet.\n            if (first) {\n                // Blindly catching here prevents unhandled promise rejections,\n                // and is safe because the ObservableQuery handles this error with\n                // this.observer.error, so we're not just swallowing the error by\n                // ignoring it here.\n                _this.reobserve().catch(function () { });\n            }\n            return function () {\n                if (_this.observers.delete(observer) && !_this.observers.size) {\n                    _this.tearDownQuery();\n                }\n            };\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        _this.dirty = false;\n        // related classes\n        _this.queryInfo = queryInfo;\n        _this.queryManager = queryManager;\n        // active state\n        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n        _this.isTornDown = false;\n        _this.subscribeToMore = _this.subscribeToMore.bind(_this);\n        _this.maskResult = _this.maskResult.bind(_this);\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        _f = options.initialFetchPolicy, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : (fetchPolicy) : _f;\n        _this.options = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options), { \n            // Remember the initial options.fetchPolicy so we can revert back to this\n            // policy when variables change. This information can also be specified\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\n            initialFetchPolicy: initialFetchPolicy, \n            // This ensures this.options.fetchPolicy always has a string value, in\n            // case options.fetchPolicy was not provided.\n            fetchPolicy: fetchPolicy });\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n        var opDef = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.getOperationDefinition)(_this.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        return _this;\n    }\n    Object.defineProperty(ObservableQuery.prototype, \"query\", {\n        // The `query` computed property will always reflect the document transformed\n        // by the last run query. `this.options.query` will always reflect the raw\n        // untransformed query to ensure document transforms with runtime conditionals\n        // are run on the original document.\n        get: function () {\n            return this.lastQuery || this.options.query;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n        // Computed shorthand for this.options.variables, preserved for\n        // backwards compatibility.\n        /**\n         * An object containing the variables that were provided for the query.\n         */\n        get: function () {\n            return this.options.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ObservableQuery.prototype.result = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO: this code doesnâ€™t actually make sense insofar as the observer\n            // will never exist in this.observers due how zen-observable wraps observables.\n            // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n            var observer = {\n                next: function (result) {\n                    resolve(result);\n                    // Stop the query within the QueryManager if we can before\n                    // this function returns.\n                    //\n                    // We do this in order to prevent observers piling up within\n                    // the QueryManager. Notice that we only fully unsubscribe\n                    // from the subscription in a setTimeout(..., 0)  call. This call can\n                    // actually be handled by the browser at a much later time. If queries\n                    // are fired in the meantime, observers that should have been removed\n                    // from the QueryManager will continue to fire, causing an unnecessary\n                    // performance hit.\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function () {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject,\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    /** @internal */\n    ObservableQuery.prototype.resetDiff = function () {\n        this.queryInfo.resetDiff();\n    };\n    ObservableQuery.prototype.getCurrentFullResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        // Use the last result as long as the variables match this.variables.\n        var lastResult = this.getLastResult(true);\n        var networkStatus = this.queryInfo.networkStatus ||\n            (lastResult && lastResult.networkStatus) ||\n            _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.ready;\n        var result = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, lastResult), { loading: (0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.isNetworkRequestInFlight)(networkStatus), networkStatus: networkStatus });\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n        if (\n        // These fetch policies should never deliver data from the cache, unless\n        // redelivering a previously delivered result.\n        skipCacheDataFor(fetchPolicy) ||\n            // If this.options.query has @client(always: true) fields, we cannot\n            // trust diff.result, since it was read from the cache without running\n            // local resolvers (and it's too late to run resolvers now, since we must\n            // return a result synchronously).\n            this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n            // Fall through.\n        }\n        else if (this.waitForOwnResult) {\n            // This would usually be a part of `QueryInfo.getDiff()`.\n            // which we skip in the waitForOwnResult case since we are not\n            // interested in the diff.\n            this.queryInfo[\"updateWatch\"]();\n        }\n        else {\n            var diff = this.queryInfo.getDiff();\n            if (diff.complete || this.options.returnPartialData) {\n                result.data = diff.result;\n            }\n            if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(result.data, {})) {\n                result.data = void 0;\n            }\n            if (diff.complete) {\n                // Similar to setting result.partial to false, but taking advantage of the\n                // falsiness of missing fields.\n                delete result.partial;\n                // If the diff is complete, and we're using a FetchPolicy that\n                // terminates after a complete cache read, we can assume the next result\n                // we receive will have NetworkStatus.ready and !loading.\n                if (diff.complete &&\n                    result.networkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.loading &&\n                    (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n                    result.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.ready;\n                    result.loading = false;\n                }\n            }\n            else {\n                result.partial = true;\n            }\n            // We need to check for both both `error` and `errors` field because there\n            // are cases where sometimes `error` is set, but not `errors` and\n            // vice-versa. This will be updated in the next major version when\n            // `errors` is deprecated in favor of `error`.\n            if (result.networkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.ready &&\n                (result.error || result.errors)) {\n                result.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.error;\n            }\n            if (globalThis.__DEV__ !== false &&\n                !diff.complete &&\n                !this.options.partialRefetch &&\n                !result.loading &&\n                !result.data &&\n                !result.error) {\n                logMissingFieldErrors(diff.missing);\n            }\n        }\n        if (saveAsLastResult) {\n            this.updateLastResult(result);\n        }\n        return result;\n    };\n    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        return this.maskResult(this.getCurrentFullResult(saveAsLastResult));\n    };\n    // Compares newResult to the snapshot we took of this.lastResult when it was\n    // first received.\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n        if (!this.last) {\n            return true;\n        }\n        var documentInfo = this.queryManager.getDocumentInfo(this.query);\n        var dataMasking = this.queryManager.dataMasking;\n        var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;\n        var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ?\n            !(0,_equalByQuery_js__WEBPACK_IMPORTED_MODULE_6__.equalByQuery)(query, this.last.result, newResult, this.variables)\n            : !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.last.result, newResult);\n        return (resultIsDifferent || (variables && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.last.variables, variables)));\n    };\n    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n        var last = this.last;\n        if (last &&\n            last[key] &&\n            (!variablesMustMatch || (0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(last.variables, this.variables))) {\n            return last[key];\n        }\n    };\n    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n        return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n        return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.resetLastResults = function () {\n        delete this.last;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\n        this.queryManager.resetErrors(this.queryId);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results.\n     * This method should be preferred over `setVariables` in most use cases.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.refetch = function (variables) {\n        var _a;\n        var reobserveOptions = {\n            // Always disable polling for refetches.\n            pollInterval: 0,\n        };\n        // Unless the provided fetchPolicy always consults the network\n        // (no-cache, network-only, or cache-and-network), override it with\n        // network-only to force the refetch for this fetchQuery call.\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === \"no-cache\") {\n            reobserveOptions.fetchPolicy = \"no-cache\";\n        }\n        else {\n            reobserveOptions.fetchPolicy = \"network-only\";\n        }\n        if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n            var queryDef = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.getQueryDefinition)(this.query);\n            var vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some(function (v) { return v.variable.name.value === \"variables\"; })) {\n                globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(\n                    21,\n                    variables,\n                    ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef\n                );\n            }\n        }\n        if (variables && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.options.variables, variables)) {\n            // Update the existing options with new variables\n            reobserveOptions.variables = this.options.variables = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this.options.variables), variables);\n        }\n        this.queryInfo.resetLastWrite();\n        return this.reobserve(reobserveOptions, _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.refetch);\n    };\n    /**\n     * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n     */\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n        var _this = this;\n        var combinedOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, (fetchMoreOptions.query ? fetchMoreOptions : ((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this.options.variables), fetchMoreOptions.variables) })))), { \n            // The fetchMore request goes immediately to the network and does\n            // not automatically write its result to the cache (hence no-cache\n            // instead of network-only), because we allow the caller of\n            // fetchMore to provide an updateQuery callback that determines how\n            // the data gets written to the cache.\n            fetchPolicy: \"no-cache\" });\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\n        var qid = this.queryManager.generateQueryId();\n        // If a temporary query is passed to `fetchMore`, we don't want to store\n        // it as the last query result since it may be an optimized query for\n        // pagination. We will however run the transforms on the original document\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\n        // uses the most up-to-date document which may rely on runtime conditionals.\n        this.lastQuery =\n            fetchMoreOptions.query ?\n                this.transformDocument(this.options.query)\n                : combinedOptions.query;\n        // Simulate a loading result for the original query with\n        // result.networkStatus === NetworkStatus.fetchMore.\n        var queryInfo = this.queryInfo;\n        var originalNetworkStatus = queryInfo.networkStatus;\n        queryInfo.networkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.fetchMore;\n        if (combinedOptions.notifyOnNetworkStatusChange) {\n            this.observe();\n        }\n        var updatedQuerySet = new Set();\n        var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;\n        var isCached = this.options.fetchPolicy !== \"no-cache\";\n        if (!isCached) {\n            (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(updateQuery, 22);\n        }\n        return this.queryManager\n            .fetchQuery(qid, combinedOptions, _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.fetchMore)\n            .then(function (fetchMoreResult) {\n            _this.queryManager.removeQuery(qid);\n            if (queryInfo.networkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.fetchMore) {\n                queryInfo.networkStatus = originalNetworkStatus;\n            }\n            if (isCached) {\n                // Performing this cache update inside a cache.batch transaction ensures\n                // any affected cache.watch watchers are notified at most once about any\n                // updates. Most watchers will be using the QueryInfo class, which\n                // responds to notifications by calling reobserveCacheFirst to deliver\n                // fetchMore cache results back to this ObservableQuery.\n                _this.queryManager.cache.batch({\n                    update: function (cache) {\n                        var updateQuery = fetchMoreOptions.updateQuery;\n                        if (updateQuery) {\n                            cache.updateQuery({\n                                query: _this.query,\n                                variables: _this.variables,\n                                returnPartialData: true,\n                                optimistic: false,\n                            }, function (previous) {\n                                return updateQuery(previous, {\n                                    fetchMoreResult: fetchMoreResult.data,\n                                    variables: combinedOptions.variables,\n                                });\n                            });\n                        }\n                        else {\n                            // If we're using a field policy instead of updateQuery, the only\n                            // thing we need to do is write the new data to the cache using\n                            // combinedOptions.variables (instead of this.variables, which is\n                            // what this.updateQuery uses, because it works by abusing the\n                            // original field value, keyed by the original variables).\n                            cache.writeQuery({\n                                query: combinedOptions.query,\n                                variables: combinedOptions.variables,\n                                data: fetchMoreResult.data,\n                            });\n                        }\n                    },\n                    onWatchUpdated: function (watch) {\n                        // Record the DocumentNode associated with any watched query whose\n                        // data were updated by the cache writes above.\n                        updatedQuerySet.add(watch.query);\n                    },\n                });\n            }\n            else {\n                // There is a possibility `lastResult` may not be set when\n                // `fetchMore` is called which would cause this to crash. This should\n                // only happen if we haven't previously reported a result. We don't\n                // quite know what the right behavior should be here since this block\n                // of code runs after the fetch result has executed on the network.\n                // We plan to let it crash in the meantime.\n                //\n                // If we get bug reports due to the `data` property access on\n                // undefined, this should give us a real-world scenario that we can\n                // use to test against and determine the right behavior. If we do end\n                // up changing this behavior, this may require, for example, an\n                // adjustment to the types on `updateQuery` since that function\n                // expects that the first argument always contains previous result\n                // data, but not `undefined`.\n                var lastResult = _this.getLast(\"result\");\n                var data = updateQuery(lastResult.data, {\n                    fetchMoreResult: fetchMoreResult.data,\n                    variables: combinedOptions.variables,\n                });\n                _this.reportResult((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, lastResult), { networkStatus: originalNetworkStatus, loading: (0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.isNetworkRequestInFlight)(originalNetworkStatus), data: data }), _this.variables);\n            }\n            return _this.maskResult(fetchMoreResult);\n        })\n            .finally(function () {\n            // In case the cache writes above did not generate a broadcast\n            // notification (which would have been intercepted by onWatchUpdated),\n            // likely because the written data were the same as what was already in\n            // the cache, we still want fetchMore to deliver its final loading:false\n            // result with the unchanged data.\n            if (isCached && !updatedQuerySet.has(_this.query)) {\n                _this.reobserveCacheFirst();\n            }\n        });\n    };\n    // XXX the subscription variables are separate from the query variables.\n    // if you want to update subscription variables, right now you have to do that separately,\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\n    /**\n     * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n     *\n     * This function returns _another_ function that you can call to terminate the subscription.\n     */\n    ObservableQuery.prototype.subscribeToMore = function (options) {\n        var _this = this;\n        var subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context,\n        })\n            .subscribe({\n            next: function (subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function (previous, updateOptions) {\n                        return updateQuery(previous, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({ subscriptionData: subscriptionData }, updateOptions));\n                    });\n                }\n            },\n            error: function (err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(23, err);\n            },\n        });\n        this.subscriptions.add(subscription);\n        return function () {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function (newOptions) {\n        return this.reobserve(newOptions);\n    };\n    ObservableQuery.prototype.silentSetOptions = function (newOptions) {\n        var mergedOptions = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.compact)(this.options, newOptions || {});\n        assign(this.options, mergedOptions);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results\n     * if they've changed. Most users should prefer `refetch` instead of\n     * `setVariables` in order to to be properly notified of results even when\n     * they come from the cache.\n     *\n     * Note: the `next` callback will *not* fire if the variables have not changed\n     * or if the result is coming from cache.\n     *\n     * Note: the promise will return the old results immediately if the variables\n     * have not changed.\n     *\n     * Note: the promise will return null immediately if the query is not active\n     * (there are no subscribers).\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.setVariables = function (variables) {\n        if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(this.variables, variables)) {\n            // If we have no observers, then we don't actually want to make a network\n            // request. As soon as someone observes the query, the request will kick\n            // off. For now, we just store any changes. (See #1077)\n            return this.observers.size ? this.result() : Promise.resolve();\n        }\n        this.options.variables = variables;\n        // See comment above\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.reobserve({\n            // Reset options.fetchPolicy to its original value.\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables: variables,\n        }, _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.setVariables);\n    };\n    /**\n     * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n     *\n     * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n     */\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\n        var queryManager = this.queryManager;\n        var _a = queryManager.cache.diff({\n            query: this.options.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic: false,\n        }), result = _a.result, complete = _a.complete;\n        var newResult = mapFn(result, {\n            variables: this.variables,\n            complete: !!complete,\n            previousData: result,\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables,\n            });\n            queryManager.broadcastQueries();\n        }\n    };\n    /**\n     * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n     */\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    };\n    /**\n     * A function that instructs the query to stop polling after a previous call to `startPolling`.\n     */\n    ObservableQuery.prototype.stopPolling = function () {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    };\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\n    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, \n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options) {\n        if (options.nextFetchPolicy) {\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n            if (fetchPolicy === \"standby\") {\n                // Do nothing, leaving options.fetchPolicy unchanged.\n            }\n            else if (typeof options.nextFetchPolicy === \"function\") {\n                // When someone chooses \"cache-and-network\" or \"network-only\" as their\n                // initial FetchPolicy, they often do not want future cache updates to\n                // trigger unconditional network requests, which is what repeatedly\n                // applying the \"cache-and-network\" or \"network-only\" policies would\n                // seem to imply. Instead, when the cache reports an update after the\n                // initial network request, it may be desirable for subsequent network\n                // requests to be triggered only if the cache result is incomplete. To\n                // that end, the options.nextFetchPolicy option provides an easy way to\n                // update options.fetchPolicy after the initial network request, without\n                // having to call observableQuery.setOptions.\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n                    reason: reason,\n                    options: options,\n                    observable: this,\n                    initialFetchPolicy: initialFetchPolicy,\n                });\n            }\n            else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            }\n            else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    };\n    ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\n        // before actually committing to the fetch.\n        var queryInfo = this.queryManager.getOrCreateQuery(this.queryId);\n        queryInfo.setObservableQuery(this);\n        return this.queryManager[\"fetchConcastWithInfo\"](queryInfo, options, newNetworkStatus, query);\n    };\n    // Turns polling on or off based on this.options.pollInterval.\n    ObservableQuery.prototype.updatePolling = function () {\n        var _this = this;\n        // Avoid polling in SSR mode\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n        if (!pollInterval || !this.hasObservers()) {\n            if (pollingInfo) {\n                clearTimeout(pollingInfo.timeout);\n                delete this.pollingInfo;\n            }\n            return;\n        }\n        if (pollingInfo && pollingInfo.interval === pollInterval) {\n            return;\n        }\n        (0,_utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(pollInterval, 24);\n        var info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        var maybeFetch = function () {\n            var _a, _b;\n            if (_this.pollingInfo) {\n                if (!(0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.isNetworkRequestInFlight)(_this.queryInfo.networkStatus) &&\n                    !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n                    _this.reobserve({\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\n                        // users wouldn't want to be polling the cache directly. However, network-only and\n                        // no-cache are both useful for when the user wants to control whether or not the\n                        // polled results are written to the cache.\n                        fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ?\n                            \"no-cache\"\n                            : \"network-only\",\n                    }, _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.poll).then(poll, poll);\n                }\n                else {\n                    poll();\n                }\n            }\n        };\n        var poll = function () {\n            var info = _this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    };\n    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n        if (variables === void 0) { variables = this.variables; }\n        var error = this.getLastError();\n        // Preserve this.last.error unless the variables have changed.\n        if (error && this.last && !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(variables, this.last.variables)) {\n            error = void 0;\n        }\n        return (this.last = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({ result: this.queryManager.assumeImmutableResults ?\n                newResult\n                : (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_8__.cloneDeep)(newResult), variables: variables }, (error ? { error: error } : null)));\n    };\n    ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\n        var _this = this;\n        this.isTornDown = false;\n        var useDisposableConcast = \n        // Refetching uses a disposable Concast to allow refetches using different\n        // options/variables, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.refetch ||\n            // The fetchMore method does not actually call the reobserve method, but,\n            // if it did, it would definitely use a disposable Concast.\n            newNetworkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.fetchMore ||\n            // Polling uses a disposable Concast so the polling options (which force\n            // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n            newNetworkStatus === _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.poll;\n        // Save the old variables, since Object.assign may modify them below.\n        var oldVariables = this.options.variables;\n        var oldFetchPolicy = this.options.fetchPolicy;\n        var mergedOptions = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_7__.compact)(this.options, newOptions || {});\n        var options = useDisposableConcast ?\n            // Disposable Concast fetches receive a shallow copy of this.options\n            // (merged with newOptions), leaving this.options unmodified.\n            mergedOptions\n            : assign(this.options, mergedOptions);\n        // Don't update options.query with the transformed query to avoid\n        // overwriting this.options.query when we aren't using a disposable concast.\n        // We want to ensure we can re-run the custom document transforms the next\n        // time a request is made against the original query.\n        var query = this.transformDocument(options.query);\n        this.lastQuery = query;\n        if (!useDisposableConcast) {\n            // We can skip calling updatePolling if we're not changing this.options.\n            this.updatePolling();\n            // Reset options.fetchPolicy to its original value when variables change,\n            // unless a new fetchPolicy was provided by newOptions.\n            if (newOptions &&\n                newOptions.variables &&\n                !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(newOptions.variables, oldVariables) &&\n                // Don't mess with the fetchPolicy if it's currently \"standby\".\n                options.fetchPolicy !== \"standby\" &&\n                // If we're changing the fetchPolicy anyway, don't try to change it here\n                // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n                (options.fetchPolicy === oldFetchPolicy ||\n                    // A `nextFetchPolicy` function has even higher priority, though,\n                    // so in that case `applyNextFetchPolicy` must be called.\n                    typeof options.nextFetchPolicy === \"function\")) {\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.setVariables;\n                }\n            }\n        }\n        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n        var finishWaitingForOwnResult = function () {\n            if (_this.concast === concast) {\n                _this.waitForOwnResult = false;\n            }\n        };\n        var variables = options.variables && (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, options.variables);\n        var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\n        var observer = {\n            next: function (result) {\n                if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(_this.variables, variables)) {\n                    finishWaitingForOwnResult();\n                    _this.reportResult(result, variables);\n                }\n            },\n            error: function (error) {\n                if ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_1__.equal)(_this.variables, variables)) {\n                    // Coming from `getResultsFromLink`, `error` here should always be an `ApolloError`.\n                    // However, calling `concast.cancel` can inject another type of error, so we have to\n                    // wrap it again here.\n                    if (!(0,_errors_index_js__WEBPACK_IMPORTED_MODULE_9__.isApolloError)(error)) {\n                        error = new _errors_index_js__WEBPACK_IMPORTED_MODULE_9__.ApolloError({ networkError: error });\n                    }\n                    finishWaitingForOwnResult();\n                    _this.reportError(error, variables);\n                }\n            },\n        };\n        if (!useDisposableConcast && (fromLink || !this.concast)) {\n            // We use the {add,remove}Observer methods directly to avoid wrapping\n            // observer with an unnecessary SubscriptionObserver object.\n            if (this.concast && this.observer) {\n                this.concast.removeObserver(this.observer);\n            }\n            this.concast = concast;\n            this.observer = observer;\n        }\n        concast.addObserver(observer);\n        return concast;\n    };\n    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n        return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_10__.preventUnhandledRejection)(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));\n    };\n    ObservableQuery.prototype.resubscribeAfterError = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // If `lastError` is set in the current when the subscription is re-created,\n        // the subscription will immediately receive the error, which will\n        // cause it to terminate again. To avoid this, we first clear\n        // the last error/result from the `observableQuery` before re-starting\n        // the subscription, and restore the last value afterwards so that the\n        // subscription has a chance to stay open.\n        var last = this.last;\n        this.resetLastResults();\n        var subscription = this.subscribe.apply(this, args);\n        this.last = last;\n        return subscription;\n    };\n    // (Re)deliver the current result to this.observers without applying fetch\n    // policies or making network requests.\n    ObservableQuery.prototype.observe = function () {\n        this.reportResult(\n        // Passing false is important so that this.getCurrentResult doesn't\n        // save the fetchMore result as this.lastResult, causing it to be\n        // ignored due to the this.isDifferentFromLastResult check in\n        // this.reportResult.\n        this.getCurrentFullResult(false), this.variables);\n    };\n    ObservableQuery.prototype.reportResult = function (result, variables) {\n        var lastError = this.getLastError();\n        var isDifferent = this.isDifferentFromLastResult(result, variables);\n        // Update the last result even when isDifferentFromLastResult returns false,\n        // because the query may be using the @nonreactive directive, and we want to\n        // save the the latest version of any nonreactive subtrees (in case\n        // getCurrentResult is called), even though we skip broadcasting changes.\n        if (lastError || !result.partial || this.options.returnPartialData) {\n            this.updateLastResult(result, variables);\n        }\n        if (lastError || isDifferent) {\n            (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.iterateObserversSafely)(this.observers, \"next\", this.maskResult(result));\n        }\n    };\n    ObservableQuery.prototype.reportError = function (error, variables) {\n        // Since we don't get the current result on errors, only the error, we\n        // must mirror the updates that occur in QueryStore.markQueryError here\n        var errorResult = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: _networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.NetworkStatus.error, loading: false });\n        this.updateLastResult(errorResult, variables);\n        (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.iterateObserversSafely)(this.observers, \"error\", (this.last.error = error));\n    };\n    ObservableQuery.prototype.hasObservers = function () {\n        return this.observers.size > 0;\n    };\n    ObservableQuery.prototype.tearDownQuery = function () {\n        if (this.isTornDown)\n            return;\n        if (this.concast && this.observer) {\n            this.concast.removeObserver(this.observer);\n            delete this.concast;\n            delete this.observer;\n        }\n        this.stopPolling();\n        // stop all active GraphQL subscriptions\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n        this.subscriptions.clear();\n        this.queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n        this.isTornDown = true;\n    };\n    ObservableQuery.prototype.transformDocument = function (document) {\n        return this.queryManager.transform(document);\n    };\n    ObservableQuery.prototype.maskResult = function (result) {\n        return result && \"data\" in result ? (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, result), { data: this.queryManager.maskOperation({\n                document: this.query,\n                data: result.data,\n                fetchPolicy: this.options.fetchPolicy,\n                id: this.queryId,\n            }) }) : result;\n    };\n    /** @internal */\n    ObservableQuery.prototype.resetNotifications = function () {\n        this.cancelNotifyTimeout();\n        this.dirty = false;\n    };\n    ObservableQuery.prototype.cancelNotifyTimeout = function () {\n        if (this.notifyTimeout) {\n            clearTimeout(this.notifyTimeout);\n            this.notifyTimeout = void 0;\n        }\n    };\n    /** @internal */\n    ObservableQuery.prototype.scheduleNotify = function () {\n        var _this = this;\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        if (!this.notifyTimeout) {\n            this.notifyTimeout = setTimeout(function () { return _this.notify(); }, 0);\n        }\n    };\n    /** @internal */\n    ObservableQuery.prototype.notify = function () {\n        this.cancelNotifyTimeout();\n        if (this.dirty) {\n            if (this.options.fetchPolicy == \"cache-only\" ||\n                this.options.fetchPolicy == \"cache-and-network\" ||\n                !(0,_networkStatus_js__WEBPACK_IMPORTED_MODULE_5__.isNetworkRequestInFlight)(this.queryInfo.networkStatus)) {\n                var diff = this.queryInfo.getDiff();\n                if (diff.fromOptimisticTransaction) {\n                    // If this diff came from an optimistic transaction, deliver the\n                    // current cache data to the ObservableQuery, but don't perform a\n                    // reobservation, since oq.reobserveCacheFirst might make a network\n                    // request, and we never want to trigger network requests in the\n                    // middle of optimistic updates.\n                    this.observe();\n                }\n                else {\n                    // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n                    // using a temporary fetch policy of \"cache-first\", so complete cache\n                    // results have a chance to be delivered without triggering additional\n                    // network requests, even when options.fetchPolicy is \"network-only\"\n                    // or \"cache-and-network\". All other fetch policies are preserved by\n                    // this method, and are handled by calling oq.reobserve(). If this\n                    // reobservation is spurious, isDifferentFromLastResult still has a\n                    // chance to catch it before delivery to ObservableQuery subscribers.\n                    this.reobserveCacheFirst();\n                }\n            }\n        }\n        this.dirty = false;\n    };\n    // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n    // delivery of any new data from the cache, possibly falling back to the network\n    // if any cache data are missing. This allows _complete_ cache results to be\n    // delivered without also kicking off unnecessary network requests when\n    // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n    // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n    // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n    ObservableQuery.prototype.reobserveCacheFirst = function () {\n        var _a = this.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n        if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n            return this.reobserve({\n                fetchPolicy: \"cache-first\",\n                // Use a temporary nextFetchPolicy function that replaces itself with the\n                // previous nextFetchPolicy value and returns the original fetchPolicy.\n                nextFetchPolicy: function (currentFetchPolicy, context) {\n                    // Replace this nextFetchPolicy function in the options object with the\n                    // original this.options.nextFetchPolicy value.\n                    this.nextFetchPolicy = nextFetchPolicy;\n                    // If the original nextFetchPolicy value was a function, give it a\n                    // chance to decide what happens here.\n                    if (typeof this.nextFetchPolicy === \"function\") {\n                        return this.nextFetchPolicy(currentFetchPolicy, context);\n                    }\n                    // Otherwise go back to the original this.options.fetchPolicy.\n                    return fetchPolicy;\n                },\n            });\n        }\n        return this.reobserve();\n    };\n    /**\n     * @internal\n     * A slot used by the `useQuery` hook to indicate that `client.watchQuery`\n     * should not register the query immediately, but instead wait for the query to\n     * be started registered with the `QueryManager` when `useSyncExternalStore`\n     * actively subscribes to it.\n     */\n    ObservableQuery.inactiveOnCreation = new optimism__WEBPACK_IMPORTED_MODULE_2__.Slot();\n    return ObservableQuery;\n}(_utilities_index_js__WEBPACK_IMPORTED_MODULE_12__.Observable));\n\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\n(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.fixObservableSubclass)(ObservableQuery);\nfunction defaultSubscriptionObserverErrorCallback(error) {\n    globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(25, error.message, error.stack);\n}\nfunction logMissingFieldErrors(missing) {\n    if (globalThis.__DEV__ !== false && missing) {\n        globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.debug(26, missing);\n    }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */) {\n    return (fetchPolicy === \"network-only\" ||\n        fetchPolicy === \"no-cache\" ||\n        fetchPolicy === \"standby\");\n}\n//# sourceMappingURL=ObservableQuery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL09ic2VydmFibGVRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ2M7QUFDcEI7QUFDdUM7QUFDaUg7QUFDOUg7QUFDZjtBQUNqQjtBQUNoQztBQUNBO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBUSxDQUFDLCtDQUFRLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esb0JBQW9CLDJFQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQWE7QUFDekIscUJBQXFCLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxpQkFBaUIsU0FBUywyRUFBd0IsK0NBQStDO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQUssZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDREQUFhO0FBQzFEO0FBQ0EsMkNBQTJDLDREQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDREQUFhO0FBQ3REO0FBQ0EsdUNBQXVDLDREQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOERBQVk7QUFDekIsZUFBZSxvREFBSztBQUNwQixvREFBb0Qsb0RBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvREFBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1RUFBa0I7QUFDN0M7QUFDQSxtREFBbUQsK0NBQStDO0FBQ2xHLGdEQUFnRCxrRUFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQUs7QUFDL0I7QUFDQSxrRUFBa0UsK0NBQVEsQ0FBQywrQ0FBUSxHQUFHO0FBQ3RGO0FBQ0E7QUFDQSxnREFBZ0QsNERBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxnREFBZ0QsK0NBQVEsQ0FBQywrQ0FBUSxDQUFDLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxtQkFBbUIsMkJBQTJCLHdCQUF3QixXQUFXLCtDQUFRLENBQUMsK0NBQVEsR0FBRyx3REFBd0Q7QUFDclM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUFTO0FBQ3JCO0FBQ0E7QUFDQSw4Q0FBOEMsNERBQWE7QUFDM0Q7QUFDQTtBQUNBLDRDQUE0Qyw0REFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtQ0FBbUMsK0NBQVEsQ0FBQywrQ0FBUSxHQUFHLGlCQUFpQiwrQ0FBK0MsMkVBQXdCLHFDQUFxQztBQUNwTDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtDQUFRLEdBQUcsb0NBQW9DO0FBQ3BHLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtFQUFTO0FBQ3pELGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBTywrQkFBK0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFTO0FBQ2pCLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyRUFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUUsNERBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG1DQUFtQyxvREFBSztBQUN4QztBQUNBO0FBQ0EsNEJBQTRCLCtDQUFRLEdBQUc7QUFDdkM7QUFDQSxrQkFBa0IsOERBQVMsbUNBQW1DLGFBQWEsZUFBZTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDREQUFhO0FBQzFDO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQWE7QUFDOUM7QUFDQTtBQUNBLGlDQUFpQyw0REFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQU8sK0JBQStCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0REFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsK0NBQVEsR0FBRztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CLG9EQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrREFBYTtBQUN0QyxvQ0FBb0MseURBQVcsR0FBRyxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtFQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRFQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFRLENBQUMsK0NBQVEsR0FBRywyQkFBMkIsMERBQTBELDREQUFhLHdCQUF3QjtBQUN4SztBQUNBLFFBQVEsNEVBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkJBQTJCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBUSxDQUFDLCtDQUFRLEdBQUcsYUFBYTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyRUFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBDQUFJO0FBQ2pEO0FBQ0EsQ0FBQyxDQUFDLDREQUFVO0FBQ2U7QUFDM0I7QUFDQTtBQUNBLDJFQUFxQjtBQUNyQjtBQUNBLG9DQUFvQyxrRUFBUztBQUM3QztBQUNPO0FBQ1A7QUFDQSx3Q0FBd0Msa0VBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXGNvcmVcXE9ic2VydmFibGVRdWVyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVxdWFsIH0gZnJvbSBcIkB3cnkvZXF1YWxpdHlcIjtcbmltcG9ydCB7IE5ldHdvcmtTdGF0dXMsIGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodCB9IGZyb20gXCIuL25ldHdvcmtTdGF0dXMuanNcIjtcbmltcG9ydCB7IGNsb25lRGVlcCwgY29tcGFjdCwgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbiwgT2JzZXJ2YWJsZSwgaXRlcmF0ZU9ic2VydmVyc1NhZmVseSwgZml4T2JzZXJ2YWJsZVN1YmNsYXNzLCBnZXRRdWVyeURlZmluaXRpb24sIHByZXZlbnRVbmhhbmRsZWRSZWplY3Rpb24sIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQXBvbGxvRXJyb3IsIGlzQXBvbGxvRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBlcXVhbEJ5UXVlcnkgfSBmcm9tIFwiLi9lcXVhbEJ5UXVlcnkuanNcIjtcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwib3B0aW1pc21cIjtcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbnZhciBPYnNlcnZhYmxlUXVlcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9ic2VydmFibGVRdWVyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlUXVlcnkoX2EpIHtcbiAgICAgICAgdmFyIHF1ZXJ5TWFuYWdlciA9IF9hLnF1ZXJ5TWFuYWdlciwgcXVlcnlJbmZvID0gX2EucXVlcnlJbmZvLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXJ0ZWRJbmFjdGl2ZSA9IE9ic2VydmFibGVRdWVyeS5pbmFjdGl2ZU9uQ3JlYXRpb24uZ2V0VmFsdWUoKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkSW5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBxdWVyeU1hbmFnZXJbXCJxdWVyaWVzXCJdLnNldChfdGhpcy5xdWVyeUlkLCBxdWVyeUluZm8pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWRJbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWmVuIE9ic2VydmFibGUgaGFzIGl0cyBvd24gZXJyb3IgZnVuY3Rpb24sIHNvIGluIG9yZGVyIHRvIGxvZyBjb3JyZWN0bHlcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcHJvdmlkZSBhIGN1c3RvbSBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Yk9ic2VydmVyID0gb2JzZXJ2ZXIuX3N1YnNjcmlwdGlvbi5fb2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yk9ic2VydmVyICYmICFzdWJPYnNlcnZlci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzdWJPYnNlcnZlci5lcnJvciA9IGRlZmF1bHRTdWJzY3JpcHRpb25PYnNlcnZlckVycm9yQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIHZhciBmaXJzdCA9ICFfdGhpcy5vYnNlcnZlcnMuc2l6ZTtcbiAgICAgICAgICAgIF90aGlzLm9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgLy8gRGVsaXZlciBtb3N0IHJlY2VudCBlcnJvciBvciByZXN1bHQuXG4gICAgICAgICAgICB2YXIgbGFzdCA9IF90aGlzLmxhc3Q7XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IobGFzdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0ICYmIGxhc3QucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KF90aGlzLm1hc2tSZXN1bHQobGFzdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluaXRpYXRlIG9ic2VydmF0aW9uIG9mIHRoaXMgcXVlcnkgaWYgaXQgaGFzbid0IGJlZW4gcmVwb3J0ZWQgdG9cbiAgICAgICAgICAgIC8vIHRoZSBRdWVyeU1hbmFnZXIgeWV0LlxuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgLy8gQmxpbmRseSBjYXRjaGluZyBoZXJlIHByZXZlbnRzIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIHNhZmUgYmVjYXVzZSB0aGUgT2JzZXJ2YWJsZVF1ZXJ5IGhhbmRsZXMgdGhpcyBlcnJvciB3aXRoXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5vYnNlcnZlci5lcnJvciwgc28gd2UncmUgbm90IGp1c3Qgc3dhbGxvd2luZyB0aGUgZXJyb3IgYnlcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmluZyBpdCBoZXJlLlxuICAgICAgICAgICAgICAgIF90aGlzLnJlb2JzZXJ2ZSgpLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKSAmJiAhX3RoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVhckRvd25RdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVsYXRlZCBjbGFzc2VzXG4gICAgICAgIF90aGlzLnF1ZXJ5SW5mbyA9IHF1ZXJ5SW5mbztcbiAgICAgICAgX3RoaXMucXVlcnlNYW5hZ2VyID0gcXVlcnlNYW5hZ2VyO1xuICAgICAgICAvLyBhY3RpdmUgc3RhdGVcbiAgICAgICAgX3RoaXMud2FpdEZvck93blJlc3VsdCA9IHNraXBDYWNoZURhdGFGb3Iob3B0aW9ucy5mZXRjaFBvbGljeSk7XG4gICAgICAgIF90aGlzLmlzVG9ybkRvd24gPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaWJlVG9Nb3JlID0gX3RoaXMuc3Vic2NyaWJlVG9Nb3JlLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5tYXNrUmVzdWx0ID0gX3RoaXMubWFza1Jlc3VsdC5iaW5kKF90aGlzKTtcbiAgICAgICAgdmFyIF9iID0gcXVlcnlNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnksIF9jID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsIF9kID0gX2MuZmV0Y2hQb2xpY3ksIGRlZmF1bHRGZXRjaFBvbGljeSA9IF9kID09PSB2b2lkIDAgPyBcImNhY2hlLWZpcnN0XCIgOiBfZDtcbiAgICAgICAgdmFyIF9lID0gb3B0aW9ucy5mZXRjaFBvbGljeSwgZmV0Y2hQb2xpY3kgPSBfZSA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoUG9saWN5IDogX2UsIFxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3Qgc3RvcmUgXCJzdGFuZGJ5XCIgYXMgdGhlIGluaXRpYWxGZXRjaFBvbGljeS5cbiAgICAgICAgX2YgPSBvcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSwgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBzdG9yZSBcInN0YW5kYnlcIiBhcyB0aGUgaW5pdGlhbEZldGNoUG9saWN5LlxuICAgICAgICBpbml0aWFsRmV0Y2hQb2xpY3kgPSBfZiA9PT0gdm9pZCAwID8gZmV0Y2hQb2xpY3kgPT09IFwic3RhbmRieVwiID8gZGVmYXVsdEZldGNoUG9saWN5IDogKGZldGNoUG9saWN5KSA6IF9mO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IFxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGluaXRpYWwgb3B0aW9ucy5mZXRjaFBvbGljeSBzbyB3ZSBjYW4gcmV2ZXJ0IGJhY2sgdG8gdGhpc1xuICAgICAgICAgICAgLy8gcG9saWN5IHdoZW4gdmFyaWFibGVzIGNoYW5nZS4gVGhpcyBpbmZvcm1hdGlvbiBjYW4gYWxzbyBiZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vIChvciBvdmVycmlkZGVuKSBieSBwcm92aWRpbmcgb3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kgZXhwbGljaXRseS5cbiAgICAgICAgICAgIGluaXRpYWxGZXRjaFBvbGljeTogaW5pdGlhbEZldGNoUG9saWN5LCBcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3kgYWx3YXlzIGhhcyBhIHN0cmluZyB2YWx1ZSwgaW5cbiAgICAgICAgICAgIC8vIGNhc2Ugb3B0aW9ucy5mZXRjaFBvbGljeSB3YXMgbm90IHByb3ZpZGVkLlxuICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5IH0pO1xuICAgICAgICBfdGhpcy5xdWVyeUlkID0gcXVlcnlJbmZvLnF1ZXJ5SWQgfHwgcXVlcnlNYW5hZ2VyLmdlbmVyYXRlUXVlcnlJZCgpO1xuICAgICAgICB2YXIgb3BEZWYgPSBnZXRPcGVyYXRpb25EZWZpbml0aW9uKF90aGlzLnF1ZXJ5KTtcbiAgICAgICAgX3RoaXMucXVlcnlOYW1lID0gb3BEZWYgJiYgb3BEZWYubmFtZSAmJiBvcERlZi5uYW1lLnZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLCBcInF1ZXJ5XCIsIHtcbiAgICAgICAgLy8gVGhlIGBxdWVyeWAgY29tcHV0ZWQgcHJvcGVydHkgd2lsbCBhbHdheXMgcmVmbGVjdCB0aGUgZG9jdW1lbnQgdHJhbnNmb3JtZWRcbiAgICAgICAgLy8gYnkgdGhlIGxhc3QgcnVuIHF1ZXJ5LiBgdGhpcy5vcHRpb25zLnF1ZXJ5YCB3aWxsIGFsd2F5cyByZWZsZWN0IHRoZSByYXdcbiAgICAgICAgLy8gdW50cmFuc2Zvcm1lZCBxdWVyeSB0byBlbnN1cmUgZG9jdW1lbnQgdHJhbnNmb3JtcyB3aXRoIHJ1bnRpbWUgY29uZGl0aW9uYWxzXG4gICAgICAgIC8vIGFyZSBydW4gb24gdGhlIG9yaWdpbmFsIGRvY3VtZW50LlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RRdWVyeSB8fCB0aGlzLm9wdGlvbnMucXVlcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZSwgXCJ2YXJpYWJsZXNcIiwge1xuICAgICAgICAvLyBDb21wdXRlZCBzaG9ydGhhbmQgZm9yIHRoaXMub3B0aW9ucy52YXJpYWJsZXMsIHByZXNlcnZlZCBmb3JcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmFyaWFibGVzIHRoYXQgd2VyZSBwcm92aWRlZCBmb3IgdGhlIHF1ZXJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhcmlhYmxlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBjb2RlIGRvZXNu4oCZdCBhY3R1YWxseSBtYWtlIHNlbnNlIGluc29mYXIgYXMgdGhlIG9ic2VydmVyXG4gICAgICAgICAgICAvLyB3aWxsIG5ldmVyIGV4aXN0IGluIHRoaXMub2JzZXJ2ZXJzIGR1ZSBob3cgemVuLW9ic2VydmFibGUgd3JhcHMgb2JzZXJ2YWJsZXMuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy96ZW4tb2JzZXJ2YWJsZS9ibG9iL21hc3Rlci9zcmMvT2JzZXJ2YWJsZS5qcyNMMTY5XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgdGhlIHF1ZXJ5IHdpdGhpbiB0aGUgUXVlcnlNYW5hZ2VyIGlmIHdlIGNhbiBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIGluIG9yZGVyIHRvIHByZXZlbnQgb2JzZXJ2ZXJzIHBpbGluZyB1cCB3aXRoaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIFF1ZXJ5TWFuYWdlci4gTm90aWNlIHRoYXQgd2Ugb25seSBmdWxseSB1bnN1YnNjcmliZVxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBzdWJzY3JpcHRpb24gaW4gYSBzZXRUaW1lb3V0KC4uLiwgMCkgIGNhbGwuIFRoaXMgY2FsbCBjYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgYmUgaGFuZGxlZCBieSB0aGUgYnJvd3NlciBhdCBhIG11Y2ggbGF0ZXIgdGltZS4gSWYgcXVlcmllc1xuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgZmlyZWQgaW4gdGhlIG1lYW50aW1lLCBvYnNlcnZlcnMgdGhhdCBzaG91bGQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgUXVlcnlNYW5hZ2VyIHdpbGwgY29udGludWUgdG8gZmlyZSwgY2F1c2luZyBhbiB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtYW5jZSBoaXQuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIucmVtb3ZlUXVlcnkoX3RoaXMucXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc2V0RGlmZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5xdWVyeUluZm8ucmVzZXREaWZmKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmdldEN1cnJlbnRGdWxsUmVzdWx0ID0gZnVuY3Rpb24gKHNhdmVBc0xhc3RSZXN1bHQpIHtcbiAgICAgICAgaWYgKHNhdmVBc0xhc3RSZXN1bHQgPT09IHZvaWQgMCkgeyBzYXZlQXNMYXN0UmVzdWx0ID0gdHJ1ZTsgfVxuICAgICAgICAvLyBVc2UgdGhlIGxhc3QgcmVzdWx0IGFzIGxvbmcgYXMgdGhlIHZhcmlhYmxlcyBtYXRjaCB0aGlzLnZhcmlhYmxlcy5cbiAgICAgICAgdmFyIGxhc3RSZXN1bHQgPSB0aGlzLmdldExhc3RSZXN1bHQodHJ1ZSk7XG4gICAgICAgIHZhciBuZXR3b3JrU3RhdHVzID0gdGhpcy5xdWVyeUluZm8ubmV0d29ya1N0YXR1cyB8fFxuICAgICAgICAgICAgKGxhc3RSZXN1bHQgJiYgbGFzdFJlc3VsdC5uZXR3b3JrU3RhdHVzKSB8fFxuICAgICAgICAgICAgTmV0d29ya1N0YXR1cy5yZWFkeTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsYXN0UmVzdWx0KSwgeyBsb2FkaW5nOiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cyksIG5ldHdvcmtTdGF0dXM6IG5ldHdvcmtTdGF0dXMgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeSwgZmV0Y2hQb2xpY3kgPSBfYSA9PT0gdm9pZCAwID8gXCJjYWNoZS1maXJzdFwiIDogX2E7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gVGhlc2UgZmV0Y2ggcG9saWNpZXMgc2hvdWxkIG5ldmVyIGRlbGl2ZXIgZGF0YSBmcm9tIHRoZSBjYWNoZSwgdW5sZXNzXG4gICAgICAgIC8vIHJlZGVsaXZlcmluZyBhIHByZXZpb3VzbHkgZGVsaXZlcmVkIHJlc3VsdC5cbiAgICAgICAgc2tpcENhY2hlRGF0YUZvcihmZXRjaFBvbGljeSkgfHxcbiAgICAgICAgICAgIC8vIElmIHRoaXMub3B0aW9ucy5xdWVyeSBoYXMgQGNsaWVudChhbHdheXM6IHRydWUpIGZpZWxkcywgd2UgY2Fubm90XG4gICAgICAgICAgICAvLyB0cnVzdCBkaWZmLnJlc3VsdCwgc2luY2UgaXQgd2FzIHJlYWQgZnJvbSB0aGUgY2FjaGUgd2l0aG91dCBydW5uaW5nXG4gICAgICAgICAgICAvLyBsb2NhbCByZXNvbHZlcnMgKGFuZCBpdCdzIHRvbyBsYXRlIHRvIHJ1biByZXNvbHZlcnMgbm93LCBzaW5jZSB3ZSBtdXN0XG4gICAgICAgICAgICAvLyByZXR1cm4gYSByZXN1bHQgc3luY2hyb25vdXNseSkuXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5nZXREb2N1bWVudEluZm8odGhpcy5xdWVyeSkuaGFzRm9yY2VkUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53YWl0Rm9yT3duUmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIHVzdWFsbHkgYmUgYSBwYXJ0IG9mIGBRdWVyeUluZm8uZ2V0RGlmZigpYC5cbiAgICAgICAgICAgIC8vIHdoaWNoIHdlIHNraXAgaW4gdGhlIHdhaXRGb3JPd25SZXN1bHQgY2FzZSBzaW5jZSB3ZSBhcmUgbm90XG4gICAgICAgICAgICAvLyBpbnRlcmVzdGVkIGluIHRoZSBkaWZmLlxuICAgICAgICAgICAgdGhpcy5xdWVyeUluZm9bXCJ1cGRhdGVXYXRjaFwiXSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLnF1ZXJ5SW5mby5nZXREaWZmKCk7XG4gICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSB8fCB0aGlzLm9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRpZmYucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVxdWFsKHJlc3VsdC5kYXRhLCB7fSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltaWxhciB0byBzZXR0aW5nIHJlc3VsdC5wYXJ0aWFsIHRvIGZhbHNlLCBidXQgdGFraW5nIGFkdmFudGFnZSBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBmYWxzaW5lc3Mgb2YgbWlzc2luZyBmaWVsZHMuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaWZmIGlzIGNvbXBsZXRlLCBhbmQgd2UncmUgdXNpbmcgYSBGZXRjaFBvbGljeSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGVybWluYXRlcyBhZnRlciBhIGNvbXBsZXRlIGNhY2hlIHJlYWQsIHdlIGNhbiBhc3N1bWUgdGhlIG5leHQgcmVzdWx0XG4gICAgICAgICAgICAgICAgLy8gd2UgcmVjZWl2ZSB3aWxsIGhhdmUgTmV0d29ya1N0YXR1cy5yZWFkeSBhbmQgIWxvYWRpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYuY29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5ldHdvcmtTdGF0dXMgPT09IE5ldHdvcmtTdGF0dXMubG9hZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmV0Y2hQb2xpY3kgPT09IFwiY2FjaGUtZmlyc3RcIiB8fCBmZXRjaFBvbGljeSA9PT0gXCJjYWNoZS1vbmx5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5yZWFkeTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGFydGlhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGZvciBib3RoIGJvdGggYGVycm9yYCBhbmQgYGVycm9yc2AgZmllbGQgYmVjYXVzZSB0aGVyZVxuICAgICAgICAgICAgLy8gYXJlIGNhc2VzIHdoZXJlIHNvbWV0aW1lcyBgZXJyb3JgIGlzIHNldCwgYnV0IG5vdCBgZXJyb3JzYCBhbmRcbiAgICAgICAgICAgIC8vIHZpY2UtdmVyc2EuIFRoaXMgd2lsbCBiZSB1cGRhdGVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gd2hlblxuICAgICAgICAgICAgLy8gYGVycm9yc2AgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgZXJyb3JgLlxuICAgICAgICAgICAgaWYgKHJlc3VsdC5uZXR3b3JrU3RhdHVzID09PSBOZXR3b3JrU3RhdHVzLnJlYWR5ICYmXG4gICAgICAgICAgICAgICAgKHJlc3VsdC5lcnJvciB8fCByZXN1bHQuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5uZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgIWRpZmYuY29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5vcHRpb25zLnBhcnRpYWxSZWZldGNoICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5kYXRhICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ01pc3NpbmdGaWVsZEVycm9ycyhkaWZmLm1pc3NpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzYXZlQXNMYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRDdXJyZW50UmVzdWx0ID0gZnVuY3Rpb24gKHNhdmVBc0xhc3RSZXN1bHQpIHtcbiAgICAgICAgaWYgKHNhdmVBc0xhc3RSZXN1bHQgPT09IHZvaWQgMCkgeyBzYXZlQXNMYXN0UmVzdWx0ID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXNrUmVzdWx0KHRoaXMuZ2V0Q3VycmVudEZ1bGxSZXN1bHQoc2F2ZUFzTGFzdFJlc3VsdCkpO1xuICAgIH07XG4gICAgLy8gQ29tcGFyZXMgbmV3UmVzdWx0IHRvIHRoZSBzbmFwc2hvdCB3ZSB0b29rIG9mIHRoaXMubGFzdFJlc3VsdCB3aGVuIGl0IHdhc1xuICAgIC8vIGZpcnN0IHJlY2VpdmVkLlxuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuaXNEaWZmZXJlbnRGcm9tTGFzdFJlc3VsdCA9IGZ1bmN0aW9uIChuZXdSZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAoIXRoaXMubGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvY3VtZW50SW5mbyA9IHRoaXMucXVlcnlNYW5hZ2VyLmdldERvY3VtZW50SW5mbyh0aGlzLnF1ZXJ5KTtcbiAgICAgICAgdmFyIGRhdGFNYXNraW5nID0gdGhpcy5xdWVyeU1hbmFnZXIuZGF0YU1hc2tpbmc7XG4gICAgICAgIHZhciBxdWVyeSA9IGRhdGFNYXNraW5nID8gZG9jdW1lbnRJbmZvLm5vblJlYWN0aXZlUXVlcnkgOiB0aGlzLnF1ZXJ5O1xuICAgICAgICB2YXIgcmVzdWx0SXNEaWZmZXJlbnQgPSBkYXRhTWFza2luZyB8fCBkb2N1bWVudEluZm8uaGFzTm9ucmVhY3RpdmVEaXJlY3RpdmUgP1xuICAgICAgICAgICAgIWVxdWFsQnlRdWVyeShxdWVyeSwgdGhpcy5sYXN0LnJlc3VsdCwgbmV3UmVzdWx0LCB0aGlzLnZhcmlhYmxlcylcbiAgICAgICAgICAgIDogIWVxdWFsKHRoaXMubGFzdC5yZXN1bHQsIG5ld1Jlc3VsdCk7XG4gICAgICAgIHJldHVybiAocmVzdWx0SXNEaWZmZXJlbnQgfHwgKHZhcmlhYmxlcyAmJiAhZXF1YWwodGhpcy5sYXN0LnZhcmlhYmxlcywgdmFyaWFibGVzKSkpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0ID0gZnVuY3Rpb24gKGtleSwgdmFyaWFibGVzTXVzdE1hdGNoKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5sYXN0O1xuICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgbGFzdFtrZXldICYmXG4gICAgICAgICAgICAoIXZhcmlhYmxlc011c3RNYXRjaCB8fCBlcXVhbChsYXN0LnZhcmlhYmxlcywgdGhpcy52YXJpYWJsZXMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0UmVzdWx0ID0gZnVuY3Rpb24gKHZhcmlhYmxlc011c3RNYXRjaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXN0KFwicmVzdWx0XCIsIHZhcmlhYmxlc011c3RNYXRjaCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmdldExhc3RFcnJvciA9IGZ1bmN0aW9uICh2YXJpYWJsZXNNdXN0TWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdChcImVycm9yXCIsIHZhcmlhYmxlc011c3RNYXRjaCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc2V0TGFzdFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmxhc3Q7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXNldFF1ZXJ5U3RvcmVFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyLnJlc2V0RXJyb3JzKHRoaXMucXVlcnlJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHZhcmlhYmxlcyBvZiB0aGlzIG9ic2VydmFibGUgcXVlcnksIGFuZCBmZXRjaCB0aGUgbmV3IHJlc3VsdHMuXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHByZWZlcnJlZCBvdmVyIGBzZXRWYXJpYWJsZXNgIGluIG1vc3QgdXNlIGNhc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhcmlhYmxlcyAtIFRoZSBuZXcgc2V0IG9mIHZhcmlhYmxlcy4gSWYgdGhlcmUgYXJlIG1pc3NpbmcgdmFyaWFibGVzLFxuICAgICAqIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgdGhvc2UgdmFyaWFibGVzIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHJlb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgZGlzYWJsZSBwb2xsaW5nIGZvciByZWZldGNoZXMuXG4gICAgICAgICAgICBwb2xsSW50ZXJ2YWw6IDAsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFVubGVzcyB0aGUgcHJvdmlkZWQgZmV0Y2hQb2xpY3kgYWx3YXlzIGNvbnN1bHRzIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vIChuby1jYWNoZSwgbmV0d29yay1vbmx5LCBvciBjYWNoZS1hbmQtbmV0d29yayksIG92ZXJyaWRlIGl0IHdpdGhcbiAgICAgICAgLy8gbmV0d29yay1vbmx5IHRvIGZvcmNlIHRoZSByZWZldGNoIGZvciB0aGlzIGZldGNoUXVlcnkgY2FsbC5cbiAgICAgICAgdmFyIGZldGNoUG9saWN5ID0gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmVvYnNlcnZlT3B0aW9ucy5mZXRjaFBvbGljeSA9IFwibm8tY2FjaGVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlb2JzZXJ2ZU9wdGlvbnMuZmV0Y2hQb2xpY3kgPSBcIm5ldHdvcmstb25seVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmIHZhcmlhYmxlcyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhcmlhYmxlcywgXCJ2YXJpYWJsZXNcIikpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeURlZiA9IGdldFF1ZXJ5RGVmaW5pdGlvbih0aGlzLnF1ZXJ5KTtcbiAgICAgICAgICAgIHZhciB2YXJzID0gcXVlcnlEZWYudmFyaWFibGVEZWZpbml0aW9ucztcbiAgICAgICAgICAgIGlmICghdmFycyB8fCAhdmFycy5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnZhcmlhYmxlLm5hbWUudmFsdWUgPT09IFwidmFyaWFibGVzXCI7IH0pKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQud2FybihcbiAgICAgICAgICAgICAgICAgICAgMjEsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IHF1ZXJ5RGVmLm5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkgfHwgcXVlcnlEZWZcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYWJsZXMgJiYgIWVxdWFsKHRoaXMub3B0aW9ucy52YXJpYWJsZXMsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3Rpbmcgb3B0aW9ucyB3aXRoIG5ldyB2YXJpYWJsZXNcbiAgICAgICAgICAgIHJlb2JzZXJ2ZU9wdGlvbnMudmFyaWFibGVzID0gdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgdmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXJ5SW5mby5yZXNldExhc3RXcml0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUocmVvYnNlcnZlT3B0aW9ucywgTmV0d29ya1N0YXR1cy5yZWZldGNoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBoZWxwcyB5b3UgZmV0Y2ggdGhlIG5leHQgc2V0IG9mIHJlc3VsdHMgZm9yIGEgW3BhZ2luYXRlZCBsaXN0IGZpZWxkXShodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL3JlYWN0L3BhZ2luYXRpb24vY29yZS1hcGkvKS5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmZldGNoTW9yZSA9IGZ1bmN0aW9uIChmZXRjaE1vcmVPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb21iaW5lZE9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKGZldGNoTW9yZU9wdGlvbnMucXVlcnkgPyBmZXRjaE1vcmVPcHRpb25zIDogKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IHF1ZXJ5OiB0aGlzLm9wdGlvbnMucXVlcnkgfSksIGZldGNoTW9yZU9wdGlvbnMpLCB7IHZhcmlhYmxlczogX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucy52YXJpYWJsZXMpLCBmZXRjaE1vcmVPcHRpb25zLnZhcmlhYmxlcykgfSkpKSksIHsgXG4gICAgICAgICAgICAvLyBUaGUgZmV0Y2hNb3JlIHJlcXVlc3QgZ29lcyBpbW1lZGlhdGVseSB0byB0aGUgbmV0d29yayBhbmQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGF1dG9tYXRpY2FsbHkgd3JpdGUgaXRzIHJlc3VsdCB0byB0aGUgY2FjaGUgKGhlbmNlIG5vLWNhY2hlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIG5ldHdvcmstb25seSksIGJlY2F1c2Ugd2UgYWxsb3cgdGhlIGNhbGxlciBvZlxuICAgICAgICAgICAgLy8gZmV0Y2hNb3JlIHRvIHByb3ZpZGUgYW4gdXBkYXRlUXVlcnkgY2FsbGJhY2sgdGhhdCBkZXRlcm1pbmVzIGhvd1xuICAgICAgICAgICAgLy8gdGhlIGRhdGEgZ2V0cyB3cml0dGVuIHRvIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGZldGNoUG9saWN5OiBcIm5vLWNhY2hlXCIgfSk7XG4gICAgICAgIGNvbWJpbmVkT3B0aW9ucy5xdWVyeSA9IHRoaXMudHJhbnNmb3JtRG9jdW1lbnQoY29tYmluZWRPcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgdmFyIHFpZCA9IHRoaXMucXVlcnlNYW5hZ2VyLmdlbmVyYXRlUXVlcnlJZCgpO1xuICAgICAgICAvLyBJZiBhIHRlbXBvcmFyeSBxdWVyeSBpcyBwYXNzZWQgdG8gYGZldGNoTW9yZWAsIHdlIGRvbid0IHdhbnQgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgYXMgdGhlIGxhc3QgcXVlcnkgcmVzdWx0IHNpbmNlIGl0IG1heSBiZSBhbiBvcHRpbWl6ZWQgcXVlcnkgZm9yXG4gICAgICAgIC8vIHBhZ2luYXRpb24uIFdlIHdpbGwgaG93ZXZlciBydW4gdGhlIHRyYW5zZm9ybXMgb24gdGhlIG9yaWdpbmFsIGRvY3VtZW50XG4gICAgICAgIC8vIGFzIHdlbGwgYXMgdGhlIGRvY3VtZW50IHBhc3NlZCBpbiBgZmV0Y2hNb3JlT3B0aW9uc2AgdG8gZW5zdXJlIHRoZSBjYWNoZVxuICAgICAgICAvLyB1c2VzIHRoZSBtb3N0IHVwLXRvLWRhdGUgZG9jdW1lbnQgd2hpY2ggbWF5IHJlbHkgb24gcnVudGltZSBjb25kaXRpb25hbHMuXG4gICAgICAgIHRoaXMubGFzdFF1ZXJ5ID1cbiAgICAgICAgICAgIGZldGNoTW9yZU9wdGlvbnMucXVlcnkgP1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRG9jdW1lbnQodGhpcy5vcHRpb25zLnF1ZXJ5KVxuICAgICAgICAgICAgICAgIDogY29tYmluZWRPcHRpb25zLnF1ZXJ5O1xuICAgICAgICAvLyBTaW11bGF0ZSBhIGxvYWRpbmcgcmVzdWx0IGZvciB0aGUgb3JpZ2luYWwgcXVlcnkgd2l0aFxuICAgICAgICAvLyByZXN1bHQubmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUuXG4gICAgICAgIHZhciBxdWVyeUluZm8gPSB0aGlzLnF1ZXJ5SW5mbztcbiAgICAgICAgdmFyIG9yaWdpbmFsTmV0d29ya1N0YXR1cyA9IHF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzO1xuICAgICAgICBxdWVyeUluZm8ubmV0d29ya1N0YXR1cyA9IE5ldHdvcmtTdGF0dXMuZmV0Y2hNb3JlO1xuICAgICAgICBpZiAoY29tYmluZWRPcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWRRdWVyeVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gZmV0Y2hNb3JlT3B0aW9ucyA9PT0gbnVsbCB8fCBmZXRjaE1vcmVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaE1vcmVPcHRpb25zLnVwZGF0ZVF1ZXJ5O1xuICAgICAgICB2YXIgaXNDYWNoZWQgPSB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3kgIT09IFwibm8tY2FjaGVcIjtcbiAgICAgICAgaWYgKCFpc0NhY2hlZCkge1xuICAgICAgICAgICAgaW52YXJpYW50KHVwZGF0ZVF1ZXJ5LCAyMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyXG4gICAgICAgICAgICAuZmV0Y2hRdWVyeShxaWQsIGNvbWJpbmVkT3B0aW9ucywgTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmV0Y2hNb3JlUmVzdWx0KSB7XG4gICAgICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIucmVtb3ZlUXVlcnkocWlkKTtcbiAgICAgICAgICAgIGlmIChxdWVyeUluZm8ubmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ubmV0d29ya1N0YXR1cyA9IG9yaWdpbmFsTmV0d29ya1N0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NhY2hlZCkge1xuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm1pbmcgdGhpcyBjYWNoZSB1cGRhdGUgaW5zaWRlIGEgY2FjaGUuYmF0Y2ggdHJhbnNhY3Rpb24gZW5zdXJlc1xuICAgICAgICAgICAgICAgIC8vIGFueSBhZmZlY3RlZCBjYWNoZS53YXRjaCB3YXRjaGVycyBhcmUgbm90aWZpZWQgYXQgbW9zdCBvbmNlIGFib3V0IGFueVxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMuIE1vc3Qgd2F0Y2hlcnMgd2lsbCBiZSB1c2luZyB0aGUgUXVlcnlJbmZvIGNsYXNzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHJlc3BvbmRzIHRvIG5vdGlmaWNhdGlvbnMgYnkgY2FsbGluZyByZW9ic2VydmVDYWNoZUZpcnN0IHRvIGRlbGl2ZXJcbiAgICAgICAgICAgICAgICAvLyBmZXRjaE1vcmUgY2FjaGUgcmVzdWx0cyBiYWNrIHRvIHRoaXMgT2JzZXJ2YWJsZVF1ZXJ5LlxuICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5jYWNoZS5iYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUXVlcnkgPSBmZXRjaE1vcmVPcHRpb25zLnVwZGF0ZVF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUudXBkYXRlUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogX3RoaXMucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogX3RoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVRdWVyeShwcmV2aW91cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hNb3JlUmVzdWx0OiBmZXRjaE1vcmVSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogY29tYmluZWRPcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyBhIGZpZWxkIHBvbGljeSBpbnN0ZWFkIG9mIHVwZGF0ZVF1ZXJ5LCB0aGUgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaW5nIHdlIG5lZWQgdG8gZG8gaXMgd3JpdGUgdGhlIG5ldyBkYXRhIHRvIHRoZSBjYWNoZSB1c2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmVkT3B0aW9ucy52YXJpYWJsZXMgKGluc3RlYWQgb2YgdGhpcy52YXJpYWJsZXMsIHdoaWNoIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hhdCB0aGlzLnVwZGF0ZVF1ZXJ5IHVzZXMsIGJlY2F1c2UgaXQgd29ya3MgYnkgYWJ1c2luZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBmaWVsZCB2YWx1ZSwga2V5ZWQgYnkgdGhlIG9yaWdpbmFsIHZhcmlhYmxlcykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUud3JpdGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBjb21iaW5lZE9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogY29tYmluZWRPcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hNb3JlUmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uV2F0Y2hVcGRhdGVkOiBmdW5jdGlvbiAod2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgRG9jdW1lbnROb2RlIGFzc29jaWF0ZWQgd2l0aCBhbnkgd2F0Y2hlZCBxdWVyeSB3aG9zZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSB3ZXJlIHVwZGF0ZWQgYnkgdGhlIGNhY2hlIHdyaXRlcyBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRRdWVyeVNldC5hZGQod2F0Y2gucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBwb3NzaWJpbGl0eSBgbGFzdFJlc3VsdGAgbWF5IG5vdCBiZSBzZXQgd2hlblxuICAgICAgICAgICAgICAgIC8vIGBmZXRjaE1vcmVgIGlzIGNhbGxlZCB3aGljaCB3b3VsZCBjYXVzZSB0aGlzIHRvIGNyYXNoLiBUaGlzIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIG9ubHkgaGFwcGVuIGlmIHdlIGhhdmVuJ3QgcHJldmlvdXNseSByZXBvcnRlZCBhIHJlc3VsdC4gV2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBxdWl0ZSBrbm93IHdoYXQgdGhlIHJpZ2h0IGJlaGF2aW9yIHNob3VsZCBiZSBoZXJlIHNpbmNlIHRoaXMgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyBvZiBjb2RlIHJ1bnMgYWZ0ZXIgdGhlIGZldGNoIHJlc3VsdCBoYXMgZXhlY3V0ZWQgb24gdGhlIG5ldHdvcmsuXG4gICAgICAgICAgICAgICAgLy8gV2UgcGxhbiB0byBsZXQgaXQgY3Jhc2ggaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGJ1ZyByZXBvcnRzIGR1ZSB0byB0aGUgYGRhdGFgIHByb3BlcnR5IGFjY2VzcyBvblxuICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCwgdGhpcyBzaG91bGQgZ2l2ZSB1cyBhIHJlYWwtd29ybGQgc2NlbmFyaW8gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyB1c2UgdG8gdGVzdCBhZ2FpbnN0IGFuZCBkZXRlcm1pbmUgdGhlIHJpZ2h0IGJlaGF2aW9yLiBJZiB3ZSBkbyBlbmRcbiAgICAgICAgICAgICAgICAvLyB1cCBjaGFuZ2luZyB0aGlzIGJlaGF2aW9yLCB0aGlzIG1heSByZXF1aXJlLCBmb3IgZXhhbXBsZSwgYW5cbiAgICAgICAgICAgICAgICAvLyBhZGp1c3RtZW50IHRvIHRoZSB0eXBlcyBvbiBgdXBkYXRlUXVlcnlgIHNpbmNlIHRoYXQgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBleHBlY3RzIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGFsd2F5cyBjb250YWlucyBwcmV2aW91cyByZXN1bHRcbiAgICAgICAgICAgICAgICAvLyBkYXRhLCBidXQgbm90IGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gX3RoaXMuZ2V0TGFzdChcInJlc3VsdFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHVwZGF0ZVF1ZXJ5KGxhc3RSZXN1bHQuZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaE1vcmVSZXN1bHQ6IGZldGNoTW9yZVJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGNvbWJpbmVkT3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0UmVzdWx0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBsYXN0UmVzdWx0KSwgeyBuZXR3b3JrU3RhdHVzOiBvcmlnaW5hbE5ldHdvcmtTdGF0dXMsIGxvYWRpbmc6IGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodChvcmlnaW5hbE5ldHdvcmtTdGF0dXMpLCBkYXRhOiBkYXRhIH0pLCBfdGhpcy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1hc2tSZXN1bHQoZmV0Y2hNb3JlUmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIGNhY2hlIHdyaXRlcyBhYm92ZSBkaWQgbm90IGdlbmVyYXRlIGEgYnJvYWRjYXN0XG4gICAgICAgICAgICAvLyBub3RpZmljYXRpb24gKHdoaWNoIHdvdWxkIGhhdmUgYmVlbiBpbnRlcmNlcHRlZCBieSBvbldhdGNoVXBkYXRlZCksXG4gICAgICAgICAgICAvLyBsaWtlbHkgYmVjYXVzZSB0aGUgd3JpdHRlbiBkYXRhIHdlcmUgdGhlIHNhbWUgYXMgd2hhdCB3YXMgYWxyZWFkeSBpblxuICAgICAgICAgICAgLy8gdGhlIGNhY2hlLCB3ZSBzdGlsbCB3YW50IGZldGNoTW9yZSB0byBkZWxpdmVyIGl0cyBmaW5hbCBsb2FkaW5nOmZhbHNlXG4gICAgICAgICAgICAvLyByZXN1bHQgd2l0aCB0aGUgdW5jaGFuZ2VkIGRhdGEuXG4gICAgICAgICAgICBpZiAoaXNDYWNoZWQgJiYgIXVwZGF0ZWRRdWVyeVNldC5oYXMoX3RoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVvYnNlcnZlQ2FjaGVGaXJzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFhYWCB0aGUgc3Vic2NyaXB0aW9uIHZhcmlhYmxlcyBhcmUgc2VwYXJhdGUgZnJvbSB0aGUgcXVlcnkgdmFyaWFibGVzLlxuICAgIC8vIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSBzdWJzY3JpcHRpb24gdmFyaWFibGVzLCByaWdodCBub3cgeW91IGhhdmUgdG8gZG8gdGhhdCBzZXBhcmF0ZWx5LFxuICAgIC8vIGFuZCB5b3UgY2FuIG9ubHkgZG8gaXQgYnkgc3RvcHBpbmcgdGhlIHN1YnNjcmlwdGlvbiBhbmQgdGhlbiBzdWJzY3JpYmluZyBhZ2FpbiB3aXRoIG5ldyB2YXJpYWJsZXMuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGVuYWJsZXMgeW91IHRvIGV4ZWN1dGUgYSBbc3Vic2NyaXB0aW9uXShodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL3JlYWN0L2RhdGEvc3Vic2NyaXB0aW9ucy8pLCB1c3VhbGx5IHRvIHN1YnNjcmliZSB0byBzcGVjaWZpYyBmaWVsZHMgdGhhdCB3ZXJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBfYW5vdGhlcl8gZnVuY3Rpb24gdGhhdCB5b3UgY2FuIGNhbGwgdG8gdGVybWluYXRlIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5zdWJzY3JpYmVUb01vcmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5xdWVyeU1hbmFnZXJcbiAgICAgICAgICAgIC5zdGFydEdyYXBoUUxTdWJzY3JpcHRpb24oe1xuICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnMuZG9jdW1lbnQsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVRdWVyeSA9IG9wdGlvbnMudXBkYXRlUXVlcnk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVF1ZXJ5KGZ1bmN0aW9uIChwcmV2aW91cywgdXBkYXRlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVF1ZXJ5KHByZXZpb3VzLCBfX2Fzc2lnbih7IHN1YnNjcmlwdGlvbkRhdGE6IHN1YnNjcmlwdGlvbkRhdGEgfSwgdXBkYXRlT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50LmVycm9yKDIzLCBlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAobmV3T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUobmV3T3B0aW9ucyk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnNpbGVudFNldE9wdGlvbnMgPSBmdW5jdGlvbiAobmV3T3B0aW9ucykge1xuICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IGNvbXBhY3QodGhpcy5vcHRpb25zLCBuZXdPcHRpb25zIHx8IHt9KTtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHZhcmlhYmxlcyBvZiB0aGlzIG9ic2VydmFibGUgcXVlcnksIGFuZCBmZXRjaCB0aGUgbmV3IHJlc3VsdHNcbiAgICAgKiBpZiB0aGV5J3ZlIGNoYW5nZWQuIE1vc3QgdXNlcnMgc2hvdWxkIHByZWZlciBgcmVmZXRjaGAgaW5zdGVhZCBvZlxuICAgICAqIGBzZXRWYXJpYWJsZXNgIGluIG9yZGVyIHRvIHRvIGJlIHByb3Blcmx5IG5vdGlmaWVkIG9mIHJlc3VsdHMgZXZlbiB3aGVuXG4gICAgICogdGhleSBjb21lIGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogTm90ZTogdGhlIGBuZXh0YCBjYWxsYmFjayB3aWxsICpub3QqIGZpcmUgaWYgdGhlIHZhcmlhYmxlcyBoYXZlIG5vdCBjaGFuZ2VkXG4gICAgICogb3IgaWYgdGhlIHJlc3VsdCBpcyBjb21pbmcgZnJvbSBjYWNoZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBwcm9taXNlIHdpbGwgcmV0dXJuIHRoZSBvbGQgcmVzdWx0cyBpbW1lZGlhdGVseSBpZiB0aGUgdmFyaWFibGVzXG4gICAgICogaGF2ZSBub3QgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBwcm9taXNlIHdpbGwgcmV0dXJuIG51bGwgaW1tZWRpYXRlbHkgaWYgdGhlIHF1ZXJ5IGlzIG5vdCBhY3RpdmVcbiAgICAgKiAodGhlcmUgYXJlIG5vIHN1YnNjcmliZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YXJpYWJsZXMgLSBUaGUgbmV3IHNldCBvZiB2YXJpYWJsZXMuIElmIHRoZXJlIGFyZSBtaXNzaW5nIHZhcmlhYmxlcyxcbiAgICAgKiB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIHRob3NlIHZhcmlhYmxlcyB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5zZXRWYXJpYWJsZXMgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgIGlmIChlcXVhbCh0aGlzLnZhcmlhYmxlcywgdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBubyBvYnNlcnZlcnMsIHRoZW4gd2UgZG9uJ3QgYWN0dWFsbHkgd2FudCB0byBtYWtlIGEgbmV0d29ya1xuICAgICAgICAgICAgLy8gcmVxdWVzdC4gQXMgc29vbiBhcyBzb21lb25lIG9ic2VydmVzIHRoZSBxdWVyeSwgdGhlIHJlcXVlc3Qgd2lsbCBraWNrXG4gICAgICAgICAgICAvLyBvZmYuIEZvciBub3csIHdlIGp1c3Qgc3RvcmUgYW55IGNoYW5nZXMuIChTZWUgIzEwNzcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMuc2l6ZSA/IHRoaXMucmVzdWx0KCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZVxuICAgICAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUoe1xuICAgICAgICAgICAgLy8gUmVzZXQgb3B0aW9ucy5mZXRjaFBvbGljeSB0byBpdHMgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAgICAgICBmZXRjaFBvbGljeTogdGhpcy5vcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICB9LCBOZXR3b3JrU3RhdHVzLnNldFZhcmlhYmxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgZW5hYmxlcyB5b3UgdG8gdXBkYXRlIHRoZSBxdWVyeSdzIGNhY2hlZCByZXN1bHQgd2l0aG91dCBleGVjdXRpbmcgYSBmb2xsb3d1cCBHcmFwaFFMIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFNlZSBbdXNpbmcgdXBkYXRlUXVlcnkgYW5kIHVwZGF0ZUZyYWdtZW50XShodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL3JlYWN0L2NhY2hpbmcvY2FjaGUtaW50ZXJhY3Rpb24vI3VzaW5nLXVwZGF0ZXF1ZXJ5LWFuZC11cGRhdGVmcmFnbWVudCkgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVRdWVyeSA9IGZ1bmN0aW9uIChtYXBGbikge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gdGhpcy5xdWVyeU1hbmFnZXI7XG4gICAgICAgIHZhciBfYSA9IHF1ZXJ5TWFuYWdlci5jYWNoZS5kaWZmKHtcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLm9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHRoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgfSksIHJlc3VsdCA9IF9hLnJlc3VsdCwgY29tcGxldGUgPSBfYS5jb21wbGV0ZTtcbiAgICAgICAgdmFyIG5ld1Jlc3VsdCA9IG1hcEZuKHJlc3VsdCwge1xuICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAhIWNvbXBsZXRlLFxuICAgICAgICAgICAgcHJldmlvdXNEYXRhOiByZXN1bHQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3UmVzdWx0KSB7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXIuY2FjaGUud3JpdGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHRoaXMub3B0aW9ucy5xdWVyeSxcbiAgICAgICAgICAgICAgICBkYXRhOiBuZXdSZXN1bHQsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXVlcnlNYW5hZ2VyLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGluc3RydWN0cyB0aGUgcXVlcnkgdG8gYmVnaW4gcmUtZXhlY3V0aW5nIGF0IGEgc3BlY2lmaWVkIGludGVydmFsIChpbiBtaWxsaXNlY29uZHMpLlxuICAgICAqL1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc3RhcnRQb2xsaW5nID0gZnVuY3Rpb24gKHBvbGxJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucG9sbEludGVydmFsID0gcG9sbEludGVydmFsO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvbGxpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBpbnN0cnVjdHMgdGhlIHF1ZXJ5IHRvIHN0b3AgcG9sbGluZyBhZnRlciBhIHByZXZpb3VzIGNhbGwgdG8gYHN0YXJ0UG9sbGluZ2AuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5zdG9wUG9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvbGxJbnRlcnZhbCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlUG9sbGluZygpO1xuICAgIH07XG4gICAgLy8gVXBkYXRlIG9wdGlvbnMuZmV0Y2hQb2xpY3kgYWNjb3JkaW5nIHRvIG9wdGlvbnMubmV4dEZldGNoUG9saWN5LlxuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuYXBwbHlOZXh0RmV0Y2hQb2xpY3kgPSBmdW5jdGlvbiAocmVhc29uLCBcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIHVzZSB0aGlzIG1ldGhvZCB0byBhcHBseSBvcHRpb25zLm5leHRGZXRjaFBvbGljeSB0b1xuICAgIC8vIG9wdGlvbnMuZmV0Y2hQb2xpY3kgZXZlbiBpZiBvcHRpb25zICE9PSB0aGlzLm9wdGlvbnMsIHRob3VnaCB0aGF0IGhhcHBlbnNcbiAgICAvLyBtb3N0IG9mdGVuIHdoZW4gdGhlIG9wdGlvbnMgYXJlIHRlbXBvcmFyeSwgdXNlZCBmb3Igb25seSBvbmUgcmVxdWVzdCBhbmRcbiAgICAvLyB0aGVuIHRocm93biBhd2F5LCBzbyBuZXh0RmV0Y2hQb2xpY3kgbWF5IG5vdCBlbmQgdXAgbWF0dGVyaW5nLlxuICAgIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubmV4dEZldGNoUG9saWN5KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmZldGNoUG9saWN5LCBmZXRjaFBvbGljeSA9IF9hID09PSB2b2lkIDAgPyBcImNhY2hlLWZpcnN0XCIgOiBfYSwgX2IgPSBvcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSwgaW5pdGlhbEZldGNoUG9saWN5ID0gX2IgPT09IHZvaWQgMCA/IGZldGNoUG9saWN5IDogX2I7XG4gICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09IFwic3RhbmRieVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZywgbGVhdmluZyBvcHRpb25zLmZldGNoUG9saWN5IHVuY2hhbmdlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm5leHRGZXRjaFBvbGljeSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzb21lb25lIGNob29zZXMgXCJjYWNoZS1hbmQtbmV0d29ya1wiIG9yIFwibmV0d29yay1vbmx5XCIgYXMgdGhlaXJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIEZldGNoUG9saWN5LCB0aGV5IG9mdGVuIGRvIG5vdCB3YW50IGZ1dHVyZSBjYWNoZSB1cGRhdGVzIHRvXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciB1bmNvbmRpdGlvbmFsIG5ldHdvcmsgcmVxdWVzdHMsIHdoaWNoIGlzIHdoYXQgcmVwZWF0ZWRseVxuICAgICAgICAgICAgICAgIC8vIGFwcGx5aW5nIHRoZSBcImNhY2hlLWFuZC1uZXR3b3JrXCIgb3IgXCJuZXR3b3JrLW9ubHlcIiBwb2xpY2llcyB3b3VsZFxuICAgICAgICAgICAgICAgIC8vIHNlZW0gdG8gaW1wbHkuIEluc3RlYWQsIHdoZW4gdGhlIGNhY2hlIHJlcG9ydHMgYW4gdXBkYXRlIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgbmV0d29yayByZXF1ZXN0LCBpdCBtYXkgYmUgZGVzaXJhYmxlIGZvciBzdWJzZXF1ZW50IG5ldHdvcmtcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0cyB0byBiZSB0cmlnZ2VyZWQgb25seSBpZiB0aGUgY2FjaGUgcmVzdWx0IGlzIGluY29tcGxldGUuIFRvXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBlbmQsIHRoZSBvcHRpb25zLm5leHRGZXRjaFBvbGljeSBvcHRpb24gcHJvdmlkZXMgYW4gZWFzeSB3YXkgdG9cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgb3B0aW9ucy5mZXRjaFBvbGljeSBhZnRlciB0aGUgaW5pdGlhbCBuZXR3b3JrIHJlcXVlc3QsIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBoYXZpbmcgdG8gY2FsbCBvYnNlcnZhYmxlUXVlcnkuc2V0T3B0aW9ucy5cbiAgICAgICAgICAgICAgICBvcHRpb25zLmZldGNoUG9saWN5ID0gb3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3koZmV0Y2hQb2xpY3ksIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxGZXRjaFBvbGljeTogaW5pdGlhbEZldGNoUG9saWN5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVhc29uID09PSBcInZhcmlhYmxlcy1jaGFuZ2VkXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZldGNoUG9saWN5ID0gaW5pdGlhbEZldGNoUG9saWN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9IG9wdGlvbnMubmV4dEZldGNoUG9saWN5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmZldGNoUG9saWN5O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChvcHRpb25zLCBuZXdOZXR3b3JrU3RhdHVzLCBxdWVyeSkge1xuICAgICAgICAvLyBUT0RPIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIG5ldHdvcmtTdGF0dXMgKGFuZCBpbmZlciBmZXRjaFZhcmlhYmxlcylcbiAgICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IGNvbW1pdHRpbmcgdG8gdGhlIGZldGNoLlxuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyeU1hbmFnZXIuZ2V0T3JDcmVhdGVRdWVyeSh0aGlzLnF1ZXJ5SWQpO1xuICAgICAgICBxdWVyeUluZm8uc2V0T2JzZXJ2YWJsZVF1ZXJ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXJbXCJmZXRjaENvbmNhc3RXaXRoSW5mb1wiXShxdWVyeUluZm8sIG9wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMsIHF1ZXJ5KTtcbiAgICB9O1xuICAgIC8vIFR1cm5zIHBvbGxpbmcgb24gb3Igb2ZmIGJhc2VkIG9uIHRoaXMub3B0aW9ucy5wb2xsSW50ZXJ2YWwuXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBBdm9pZCBwb2xsaW5nIGluIFNTUiBtb2RlXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5TWFuYWdlci5zc3JNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgcG9sbGluZ0luZm8gPSBfYS5wb2xsaW5nSW5mbywgcG9sbEludGVydmFsID0gX2Eub3B0aW9ucy5wb2xsSW50ZXJ2YWw7XG4gICAgICAgIGlmICghcG9sbEludGVydmFsIHx8ICF0aGlzLmhhc09ic2VydmVycygpKSB7XG4gICAgICAgICAgICBpZiAocG9sbGluZ0luZm8pIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocG9sbGluZ0luZm8udGltZW91dCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucG9sbGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbGxpbmdJbmZvICYmIHBvbGxpbmdJbmZvLmludGVydmFsID09PSBwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnZhcmlhbnQocG9sbEludGVydmFsLCAyNCk7XG4gICAgICAgIHZhciBpbmZvID0gcG9sbGluZ0luZm8gfHwgKHRoaXMucG9sbGluZ0luZm8gPSB7fSk7XG4gICAgICAgIGluZm8uaW50ZXJ2YWwgPSBwb2xsSW50ZXJ2YWw7XG4gICAgICAgIHZhciBtYXliZUZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wb2xsaW5nSW5mbykge1xuICAgICAgICAgICAgICAgIGlmICghaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KF90aGlzLnF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKChfYiA9IChfYSA9IF90aGlzLm9wdGlvbnMpLnNraXBQb2xsQXR0ZW1wdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW9ic2VydmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9zdCBmZXRjaFBvbGljeSBvcHRpb25zIGRvbid0IG1ha2Ugc2Vuc2UgdG8gdXNlIGluIGEgcG9sbGluZyBjb250ZXh0LCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlcnMgd291bGRuJ3Qgd2FudCB0byBiZSBwb2xsaW5nIHRoZSBjYWNoZSBkaXJlY3RseS4gSG93ZXZlciwgbmV0d29yay1vbmx5IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8tY2FjaGUgYXJlIGJvdGggdXNlZnVsIGZvciB3aGVuIHRoZSB1c2VyIHdhbnRzIHRvIGNvbnRyb2wgd2hldGhlciBvciBub3QgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2xsZWQgcmVzdWx0cyBhcmUgd3JpdHRlbiB0byB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogX3RoaXMub3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuby1jYWNoZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIm5ldHdvcmstb25seVwiLFxuICAgICAgICAgICAgICAgICAgICB9LCBOZXR3b3JrU3RhdHVzLnBvbGwpLnRoZW4ocG9sbCwgcG9sbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gX3RoaXMucG9sbGluZ0luZm87XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmZvLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGluZm8udGltZW91dCA9IHNldFRpbWVvdXQobWF5YmVGZXRjaCwgaW5mby5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBvbGwoKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUudXBkYXRlTGFzdFJlc3VsdCA9IGZ1bmN0aW9uIChuZXdSZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXM7IH1cbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5nZXRMYXN0RXJyb3IoKTtcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcy5sYXN0LmVycm9yIHVubGVzcyB0aGUgdmFyaWFibGVzIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgaWYgKGVycm9yICYmIHRoaXMubGFzdCAmJiAhZXF1YWwodmFyaWFibGVzLCB0aGlzLmxhc3QudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmxhc3QgPSBfX2Fzc2lnbih7IHJlc3VsdDogdGhpcy5xdWVyeU1hbmFnZXIuYXNzdW1lSW1tdXRhYmxlUmVzdWx0cyA/XG4gICAgICAgICAgICAgICAgbmV3UmVzdWx0XG4gICAgICAgICAgICAgICAgOiBjbG9uZURlZXAobmV3UmVzdWx0KSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfSwgKGVycm9yID8geyBlcnJvcjogZXJyb3IgfSA6IG51bGwpKSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlb2JzZXJ2ZUFzQ29uY2FzdCA9IGZ1bmN0aW9uIChuZXdPcHRpb25zLCBuZXdOZXR3b3JrU3RhdHVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IGZhbHNlO1xuICAgICAgICB2YXIgdXNlRGlzcG9zYWJsZUNvbmNhc3QgPSBcbiAgICAgICAgLy8gUmVmZXRjaGluZyB1c2VzIGEgZGlzcG9zYWJsZSBDb25jYXN0IHRvIGFsbG93IHJlZmV0Y2hlcyB1c2luZyBkaWZmZXJlbnRcbiAgICAgICAgLy8gb3B0aW9ucy92YXJpYWJsZXMsIHdpdGhvdXQgcGVybWFuZW50bHkgYWx0ZXJpbmcgdGhlIG9wdGlvbnMgb2YgdGhlXG4gICAgICAgIC8vIG9yaWdpbmFsIE9ic2VydmFibGVRdWVyeS5cbiAgICAgICAgbmV3TmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5yZWZldGNoIHx8XG4gICAgICAgICAgICAvLyBUaGUgZmV0Y2hNb3JlIG1ldGhvZCBkb2VzIG5vdCBhY3R1YWxseSBjYWxsIHRoZSByZW9ic2VydmUgbWV0aG9kLCBidXQsXG4gICAgICAgICAgICAvLyBpZiBpdCBkaWQsIGl0IHdvdWxkIGRlZmluaXRlbHkgdXNlIGEgZGlzcG9zYWJsZSBDb25jYXN0LlxuICAgICAgICAgICAgbmV3TmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUgfHxcbiAgICAgICAgICAgIC8vIFBvbGxpbmcgdXNlcyBhIGRpc3Bvc2FibGUgQ29uY2FzdCBzbyB0aGUgcG9sbGluZyBvcHRpb25zICh3aGljaCBmb3JjZVxuICAgICAgICAgICAgLy8gZmV0Y2hQb2xpY3kgdG8gYmUgXCJuZXR3b3JrLW9ubHlcIiBvciBcIm5vLWNhY2hlXCIpIHdvbid0IG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBvcHRpb25zLlxuICAgICAgICAgICAgbmV3TmV0d29ya1N0YXR1cyA9PT0gTmV0d29ya1N0YXR1cy5wb2xsO1xuICAgICAgICAvLyBTYXZlIHRoZSBvbGQgdmFyaWFibGVzLCBzaW5jZSBPYmplY3QuYXNzaWduIG1heSBtb2RpZnkgdGhlbSBiZWxvdy5cbiAgICAgICAgdmFyIG9sZFZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXM7XG4gICAgICAgIHZhciBvbGRGZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBjb21wYWN0KHRoaXMub3B0aW9ucywgbmV3T3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdXNlRGlzcG9zYWJsZUNvbmNhc3QgP1xuICAgICAgICAgICAgLy8gRGlzcG9zYWJsZSBDb25jYXN0IGZldGNoZXMgcmVjZWl2ZSBhIHNoYWxsb3cgY29weSBvZiB0aGlzLm9wdGlvbnNcbiAgICAgICAgICAgIC8vIChtZXJnZWQgd2l0aCBuZXdPcHRpb25zKSwgbGVhdmluZyB0aGlzLm9wdGlvbnMgdW5tb2RpZmllZC5cbiAgICAgICAgICAgIG1lcmdlZE9wdGlvbnNcbiAgICAgICAgICAgIDogYXNzaWduKHRoaXMub3B0aW9ucywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgIC8vIERvbid0IHVwZGF0ZSBvcHRpb25zLnF1ZXJ5IHdpdGggdGhlIHRyYW5zZm9ybWVkIHF1ZXJ5IHRvIGF2b2lkXG4gICAgICAgIC8vIG92ZXJ3cml0aW5nIHRoaXMub3B0aW9ucy5xdWVyeSB3aGVuIHdlIGFyZW4ndCB1c2luZyBhIGRpc3Bvc2FibGUgY29uY2FzdC5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBlbnN1cmUgd2UgY2FuIHJlLXJ1biB0aGUgY3VzdG9tIGRvY3VtZW50IHRyYW5zZm9ybXMgdGhlIG5leHRcbiAgICAgICAgLy8gdGltZSBhIHJlcXVlc3QgaXMgbWFkZSBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBxdWVyeS5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1Eb2N1bWVudChvcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgdGhpcy5sYXN0UXVlcnkgPSBxdWVyeTtcbiAgICAgICAgaWYgKCF1c2VEaXNwb3NhYmxlQ29uY2FzdCkge1xuICAgICAgICAgICAgLy8gV2UgY2FuIHNraXAgY2FsbGluZyB1cGRhdGVQb2xsaW5nIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGlzLm9wdGlvbnMuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvbGxpbmcoKTtcbiAgICAgICAgICAgIC8vIFJlc2V0IG9wdGlvbnMuZmV0Y2hQb2xpY3kgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIHdoZW4gdmFyaWFibGVzIGNoYW5nZSxcbiAgICAgICAgICAgIC8vIHVubGVzcyBhIG5ldyBmZXRjaFBvbGljeSB3YXMgcHJvdmlkZWQgYnkgbmV3T3B0aW9ucy5cbiAgICAgICAgICAgIGlmIChuZXdPcHRpb25zICYmXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucy52YXJpYWJsZXMgJiZcbiAgICAgICAgICAgICAgICAhZXF1YWwobmV3T3B0aW9ucy52YXJpYWJsZXMsIG9sZFZhcmlhYmxlcykgJiZcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtZXNzIHdpdGggdGhlIGZldGNoUG9saWN5IGlmIGl0J3MgY3VycmVudGx5IFwic3RhbmRieVwiLlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgIT09IFwic3RhbmRieVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgY2hhbmdpbmcgdGhlIGZldGNoUG9saWN5IGFueXdheSwgZG9uJ3QgdHJ5IHRvIGNoYW5nZSBpdCBoZXJlXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgYXBwbHlOZXh0RmV0Y2hQb2xpY3kuIFRoZSBleHBsaWNpdCBvcHRpb25zLmZldGNoUG9saWN5IHdpbnMuXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09IG9sZEZldGNoUG9saWN5IHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYG5leHRGZXRjaFBvbGljeWAgZnVuY3Rpb24gaGFzIGV2ZW4gaGlnaGVyIHByaW9yaXR5LCB0aG91Z2gsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGluIHRoYXQgY2FzZSBgYXBwbHlOZXh0RmV0Y2hQb2xpY3lgIG11c3QgYmUgY2FsbGVkLlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TmV4dEZldGNoUG9saWN5KFwidmFyaWFibGVzLWNoYW5nZWRcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld05ldHdvcmtTdGF0dXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOZXR3b3JrU3RhdHVzID0gTmV0d29ya1N0YXR1cy5zZXRWYXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdEZvck93blJlc3VsdCAmJiAodGhpcy53YWl0Rm9yT3duUmVzdWx0ID0gc2tpcENhY2hlRGF0YUZvcihvcHRpb25zLmZldGNoUG9saWN5KSk7XG4gICAgICAgIHZhciBmaW5pc2hXYWl0aW5nRm9yT3duUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmNhc3QgPT09IGNvbmNhc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWl0Rm9yT3duUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBvcHRpb25zLnZhcmlhYmxlcyAmJiBfX2Fzc2lnbih7fSwgb3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmZldGNoKG9wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMsIHF1ZXJ5KSwgY29uY2FzdCA9IF9hLmNvbmNhc3QsIGZyb21MaW5rID0gX2EuZnJvbUxpbms7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWwoX3RoaXMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFdhaXRpbmdGb3JPd25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0UmVzdWx0KHJlc3VsdCwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbChfdGhpcy52YXJpYWJsZXMsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29taW5nIGZyb20gYGdldFJlc3VsdHNGcm9tTGlua2AsIGBlcnJvcmAgaGVyZSBzaG91bGQgYWx3YXlzIGJlIGFuIGBBcG9sbG9FcnJvcmAuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGNhbGxpbmcgYGNvbmNhc3QuY2FuY2VsYCBjYW4gaW5qZWN0IGFub3RoZXIgdHlwZSBvZiBlcnJvciwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB3cmFwIGl0IGFnYWluIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBcG9sbG9FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEFwb2xsb0Vycm9yKHsgbmV0d29ya0Vycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hXYWl0aW5nRm9yT3duUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcG9ydEVycm9yKGVycm9yLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdXNlRGlzcG9zYWJsZUNvbmNhc3QgJiYgKGZyb21MaW5rIHx8ICF0aGlzLmNvbmNhc3QpKSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHthZGQscmVtb3ZlfU9ic2VydmVyIG1ldGhvZHMgZGlyZWN0bHkgdG8gYXZvaWQgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIHdpdGggYW4gdW5uZWNlc3NhcnkgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKHRoaXMuY29uY2FzdCAmJiB0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25jYXN0LnJlbW92ZU9ic2VydmVyKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25jYXN0ID0gY29uY2FzdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25jYXN0LmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhc3Q7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlb2JzZXJ2ZSA9IGZ1bmN0aW9uIChuZXdPcHRpb25zLCBuZXdOZXR3b3JrU3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBwcmV2ZW50VW5oYW5kbGVkUmVqZWN0aW9uKHRoaXMucmVvYnNlcnZlQXNDb25jYXN0KG5ld09wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMpLnByb21pc2UudGhlbih0aGlzLm1hc2tSZXN1bHQpKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzdWJzY3JpYmVBZnRlckVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGBsYXN0RXJyb3JgIGlzIHNldCBpbiB0aGUgY3VycmVudCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gaXMgcmUtY3JlYXRlZCxcbiAgICAgICAgLy8gdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGltbWVkaWF0ZWx5IHJlY2VpdmUgdGhlIGVycm9yLCB3aGljaCB3aWxsXG4gICAgICAgIC8vIGNhdXNlIGl0IHRvIHRlcm1pbmF0ZSBhZ2Fpbi4gVG8gYXZvaWQgdGhpcywgd2UgZmlyc3QgY2xlYXJcbiAgICAgICAgLy8gdGhlIGxhc3QgZXJyb3IvcmVzdWx0IGZyb20gdGhlIGBvYnNlcnZhYmxlUXVlcnlgIGJlZm9yZSByZS1zdGFydGluZ1xuICAgICAgICAvLyB0aGUgc3Vic2NyaXB0aW9uLCBhbmQgcmVzdG9yZSB0aGUgbGFzdCB2YWx1ZSBhZnRlcndhcmRzIHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiBoYXMgYSBjaGFuY2UgdG8gc3RheSBvcGVuLlxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMubGFzdDtcbiAgICAgICAgdGhpcy5yZXNldExhc3RSZXN1bHRzKCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdGhpcy5sYXN0ID0gbGFzdDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIC8vIChSZSlkZWxpdmVyIHRoZSBjdXJyZW50IHJlc3VsdCB0byB0aGlzLm9ic2VydmVycyB3aXRob3V0IGFwcGx5aW5nIGZldGNoXG4gICAgLy8gcG9saWNpZXMgb3IgbWFraW5nIG5ldHdvcmsgcmVxdWVzdHMuXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlcG9ydFJlc3VsdChcbiAgICAgICAgLy8gUGFzc2luZyBmYWxzZSBpcyBpbXBvcnRhbnQgc28gdGhhdCB0aGlzLmdldEN1cnJlbnRSZXN1bHQgZG9lc24ndFxuICAgICAgICAvLyBzYXZlIHRoZSBmZXRjaE1vcmUgcmVzdWx0IGFzIHRoaXMubGFzdFJlc3VsdCwgY2F1c2luZyBpdCB0byBiZVxuICAgICAgICAvLyBpZ25vcmVkIGR1ZSB0byB0aGUgdGhpcy5pc0RpZmZlcmVudEZyb21MYXN0UmVzdWx0IGNoZWNrIGluXG4gICAgICAgIC8vIHRoaXMucmVwb3J0UmVzdWx0LlxuICAgICAgICB0aGlzLmdldEN1cnJlbnRGdWxsUmVzdWx0KGZhbHNlKSwgdGhpcy52YXJpYWJsZXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXBvcnRSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGxhc3RFcnJvciA9IHRoaXMuZ2V0TGFzdEVycm9yKCk7XG4gICAgICAgIHZhciBpc0RpZmZlcmVudCA9IHRoaXMuaXNEaWZmZXJlbnRGcm9tTGFzdFJlc3VsdChyZXN1bHQsIHZhcmlhYmxlcyk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCByZXN1bHQgZXZlbiB3aGVuIGlzRGlmZmVyZW50RnJvbUxhc3RSZXN1bHQgcmV0dXJucyBmYWxzZSxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgcXVlcnkgbWF5IGJlIHVzaW5nIHRoZSBAbm9ucmVhY3RpdmUgZGlyZWN0aXZlLCBhbmQgd2Ugd2FudCB0b1xuICAgICAgICAvLyBzYXZlIHRoZSB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgYW55IG5vbnJlYWN0aXZlIHN1YnRyZWVzIChpbiBjYXNlXG4gICAgICAgIC8vIGdldEN1cnJlbnRSZXN1bHQgaXMgY2FsbGVkKSwgZXZlbiB0aG91Z2ggd2Ugc2tpcCBicm9hZGNhc3RpbmcgY2hhbmdlcy5cbiAgICAgICAgaWYgKGxhc3RFcnJvciB8fCAhcmVzdWx0LnBhcnRpYWwgfHwgdGhpcy5vcHRpb25zLnJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0LCB2YXJpYWJsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RXJyb3IgfHwgaXNEaWZmZXJlbnQpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkodGhpcy5vYnNlcnZlcnMsIFwibmV4dFwiLCB0aGlzLm1hc2tSZXN1bHQocmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIHZhcmlhYmxlcykge1xuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBnZXQgdGhlIGN1cnJlbnQgcmVzdWx0IG9uIGVycm9ycywgb25seSB0aGUgZXJyb3IsIHdlXG4gICAgICAgIC8vIG11c3QgbWlycm9yIHRoZSB1cGRhdGVzIHRoYXQgb2NjdXIgaW4gUXVlcnlTdG9yZS5tYXJrUXVlcnlFcnJvciBoZXJlXG4gICAgICAgIHZhciBlcnJvclJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLmdldExhc3RSZXN1bHQoKSksIHsgZXJyb3I6IGVycm9yLCBlcnJvcnM6IGVycm9yLmdyYXBoUUxFcnJvcnMsIG5ldHdvcmtTdGF0dXM6IE5ldHdvcmtTdGF0dXMuZXJyb3IsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQoZXJyb3JSZXN1bHQsIHZhcmlhYmxlcyk7XG4gICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkodGhpcy5vYnNlcnZlcnMsIFwiZXJyb3JcIiwgKHRoaXMubGFzdC5lcnJvciA9IGVycm9yKSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmhhc09ic2VydmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNpemUgPiAwO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS50ZWFyRG93blF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Rvcm5Eb3duKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5jb25jYXN0ICYmIHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uY2FzdC5yZW1vdmVPYnNlcnZlcih0aGlzLm9ic2VydmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmNhc3Q7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgIC8vIHN0b3AgYWxsIGFjdGl2ZSBHcmFwaFFMIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuc3RvcFF1ZXJ5KHRoaXMucXVlcnlJZCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaXNUb3JuRG93biA9IHRydWU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnRyYW5zZm9ybURvY3VtZW50ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci50cmFuc2Zvcm0oZG9jdW1lbnQpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5tYXNrUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICYmIFwiZGF0YVwiIGluIHJlc3VsdCA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IGRhdGE6IHRoaXMucXVlcnlNYW5hZ2VyLm1hc2tPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGRvY3VtZW50OiB0aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMucXVlcnlJZCxcbiAgICAgICAgICAgIH0pIH0pIDogcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzZXROb3RpZmljYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbE5vdGlmeVRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5jYW5jZWxOb3RpZnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ub3RpZnlUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuc2NoZWR1bGVOb3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm5vdGlmeVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubm90aWZ5KCk7IH0sIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsTm90aWZ5VGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeSA9PSBcImNhY2hlLW9ubHlcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeSA9PSBcImNhY2hlLWFuZC1uZXR3b3JrXCIgfHxcbiAgICAgICAgICAgICAgICAhaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KHRoaXMucXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLnF1ZXJ5SW5mby5nZXREaWZmKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYuZnJvbU9wdGltaXN0aWNUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGRpZmYgY2FtZSBmcm9tIGFuIG9wdGltaXN0aWMgdHJhbnNhY3Rpb24sIGRlbGl2ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgY2FjaGUgZGF0YSB0byB0aGUgT2JzZXJ2YWJsZVF1ZXJ5LCBidXQgZG9uJ3QgcGVyZm9ybSBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlb2JzZXJ2YXRpb24sIHNpbmNlIG9xLnJlb2JzZXJ2ZUNhY2hlRmlyc3QgbWlnaHQgbWFrZSBhIG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCwgYW5kIHdlIG5ldmVyIHdhbnQgdG8gdHJpZ2dlciBuZXR3b3JrIHJlcXVlc3RzIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBtaWRkbGUgb2Ygb3B0aW1pc3RpYyB1cGRhdGVzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbWFrZSB0aGUgT2JzZXJ2YWJsZVF1ZXJ5IFwicmVvYnNlcnZlXCIgdGhlIGxhdGVzdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIGEgdGVtcG9yYXJ5IGZldGNoIHBvbGljeSBvZiBcImNhY2hlLWZpcnN0XCIsIHNvIGNvbXBsZXRlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgaGF2ZSBhIGNoYW5jZSB0byBiZSBkZWxpdmVyZWQgd2l0aG91dCB0cmlnZ2VyaW5nIGFkZGl0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV0d29yayByZXF1ZXN0cywgZXZlbiB3aGVuIG9wdGlvbnMuZmV0Y2hQb2xpY3kgaXMgXCJuZXR3b3JrLW9ubHlcIlxuICAgICAgICAgICAgICAgICAgICAvLyBvciBcImNhY2hlLWFuZC1uZXR3b3JrXCIuIEFsbCBvdGhlciBmZXRjaCBwb2xpY2llcyBhcmUgcHJlc2VydmVkIGJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kLCBhbmQgYXJlIGhhbmRsZWQgYnkgY2FsbGluZyBvcS5yZW9ic2VydmUoKS4gSWYgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyByZW9ic2VydmF0aW9uIGlzIHNwdXJpb3VzLCBpc0RpZmZlcmVudEZyb21MYXN0UmVzdWx0IHN0aWxsIGhhcyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjYXRjaCBpdCBiZWZvcmUgZGVsaXZlcnkgdG8gT2JzZXJ2YWJsZVF1ZXJ5IHN1YnNjcmliZXJzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlb2JzZXJ2ZUNhY2hlRmlyc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG4gICAgLy8gUmVvYnNlcnZlIHdpdGggZmV0Y2hQb2xpY3kgZWZmZWN0aXZlbHkgc2V0IHRvIFwiY2FjaGUtZmlyc3RcIiwgdHJpZ2dlcmluZ1xuICAgIC8vIGRlbGl2ZXJ5IG9mIGFueSBuZXcgZGF0YSBmcm9tIHRoZSBjYWNoZSwgcG9zc2libHkgZmFsbGluZyBiYWNrIHRvIHRoZSBuZXR3b3JrXG4gICAgLy8gaWYgYW55IGNhY2hlIGRhdGEgYXJlIG1pc3NpbmcuIFRoaXMgYWxsb3dzIF9jb21wbGV0ZV8gY2FjaGUgcmVzdWx0cyB0byBiZVxuICAgIC8vIGRlbGl2ZXJlZCB3aXRob3V0IGFsc28ga2lja2luZyBvZmYgdW5uZWNlc3NhcnkgbmV0d29yayByZXF1ZXN0cyB3aGVuXG4gICAgLy8gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5IGlzIFwiY2FjaGUtYW5kLW5ldHdvcmtcIiBvciBcIm5ldHdvcmstb25seVwiLiBXaGVuXG4gICAgLy8gdGhpcy5vcHRpb25zLmZldGNoUG9saWN5IGlzIGFueSBvdGhlciBwb2xpY3kgKFwiY2FjaGUtZmlyc3RcIiwgXCJjYWNoZS1vbmx5XCIsXG4gICAgLy8gXCJzdGFuZGJ5XCIsIG9yIFwibm8tY2FjaGVcIiksIHdlIGNhbGwgdGhpcy5yZW9ic2VydmUoKSBhcyB1c3VhbC5cbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlb2JzZXJ2ZUNhY2hlRmlyc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeSwgbmV4dEZldGNoUG9saWN5ID0gX2EubmV4dEZldGNoUG9saWN5O1xuICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09IFwiY2FjaGUtYW5kLW5ldHdvcmtcIiB8fCBmZXRjaFBvbGljeSA9PT0gXCJuZXR3b3JrLW9ubHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVvYnNlcnZlKHtcbiAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogXCJjYWNoZS1maXJzdFwiLFxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHRlbXBvcmFyeSBuZXh0RmV0Y2hQb2xpY3kgZnVuY3Rpb24gdGhhdCByZXBsYWNlcyBpdHNlbGYgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBuZXh0RmV0Y2hQb2xpY3kgdmFsdWUgYW5kIHJldHVybnMgdGhlIG9yaWdpbmFsIGZldGNoUG9saWN5LlxuICAgICAgICAgICAgICAgIG5leHRGZXRjaFBvbGljeTogZnVuY3Rpb24gKGN1cnJlbnRGZXRjaFBvbGljeSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoaXMgbmV4dEZldGNoUG9saWN5IGZ1bmN0aW9uIGluIHRoZSBvcHRpb25zIG9iamVjdCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCB0aGlzLm9wdGlvbnMubmV4dEZldGNoUG9saWN5IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRGZXRjaFBvbGljeSA9IG5leHRGZXRjaFBvbGljeTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIG5leHRGZXRjaFBvbGljeSB2YWx1ZSB3YXMgYSBmdW5jdGlvbiwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5jZSB0byBkZWNpZGUgd2hhdCBoYXBwZW5zIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5uZXh0RmV0Y2hQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dEZldGNoUG9saWN5KGN1cnJlbnRGZXRjaFBvbGljeSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGdvIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUG9saWN5O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEEgc2xvdCB1c2VkIGJ5IHRoZSBgdXNlUXVlcnlgIGhvb2sgdG8gaW5kaWNhdGUgdGhhdCBgY2xpZW50LndhdGNoUXVlcnlgXG4gICAgICogc2hvdWxkIG5vdCByZWdpc3RlciB0aGUgcXVlcnkgaW1tZWRpYXRlbHksIGJ1dCBpbnN0ZWFkIHdhaXQgZm9yIHRoZSBxdWVyeSB0b1xuICAgICAqIGJlIHN0YXJ0ZWQgcmVnaXN0ZXJlZCB3aXRoIHRoZSBgUXVlcnlNYW5hZ2VyYCB3aGVuIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZWBcbiAgICAgKiBhY3RpdmVseSBzdWJzY3JpYmVzIHRvIGl0LlxuICAgICAqL1xuICAgIE9ic2VydmFibGVRdWVyeS5pbmFjdGl2ZU9uQ3JlYXRpb24gPSBuZXcgU2xvdCgpO1xuICAgIHJldHVybiBPYnNlcnZhYmxlUXVlcnk7XG59KE9ic2VydmFibGUpKTtcbmV4cG9ydCB7IE9ic2VydmFibGVRdWVyeSB9O1xuLy8gTmVjZXNzYXJ5IGJlY2F1c2UgdGhlIE9ic2VydmFibGVRdWVyeSBjb25zdHJ1Y3RvciBoYXMgYSBkaWZmZXJlbnRcbi8vIHNpZ25hdHVyZSB0aGFuIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yLlxuZml4T2JzZXJ2YWJsZVN1YmNsYXNzKE9ic2VydmFibGVRdWVyeSk7XG5mdW5jdGlvbiBkZWZhdWx0U3Vic2NyaXB0aW9uT2JzZXJ2ZXJFcnJvckNhbGxiYWNrKGVycm9yKSB7XG4gICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQuZXJyb3IoMjUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2dNaXNzaW5nRmllbGRFcnJvcnMobWlzc2luZykge1xuICAgIGlmIChnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmIG1pc3NpbmcpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQuZGVidWcoMjYsIG1pc3NpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBDYWNoZURhdGFGb3IoZmV0Y2hQb2xpY3kgLyogYHVuZGVmaW5lZGAgd291bGQgbWVhbiBgXCJjYWNoZS1maXJzdFwiYCAqLykge1xuICAgIHJldHVybiAoZmV0Y2hQb2xpY3kgPT09IFwibmV0d29yay1vbmx5XCIgfHxcbiAgICAgICAgZmV0Y2hQb2xpY3kgPT09IFwibm8tY2FjaGVcIiB8fFxuICAgICAgICBmZXRjaFBvbGljeSA9PT0gXCJzdGFuZGJ5XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZVF1ZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/ObservableQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/equalByQuery.js":
/*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/core/equalByQuery.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equalByQuery: () => (/* binding */ equalByQuery)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n\n\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nfunction equalByQuery(query, _a, _b, variables) {\n    var aData = _a.data, aRest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, [\"data\"]);\n    var bData = _b.data, bRest = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_b, [\"data\"]);\n    return ((0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(aRest, bRest) &&\n        equalBySelectionSet((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.getMainDefinition)(query).selectionSet, aData, bData, {\n            fragmentMap: (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.createFragmentMap)((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.getFragmentDefinitions)(query)),\n            variables: variables,\n        }));\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n    if (aResult === bResult) {\n        return true;\n    }\n    var seenSelections = new Set();\n    // Returning true from this Array.prototype.every callback function skips the\n    // current field/subtree. Returning false aborts the entire traversal\n    // immediately, causing equalBySelectionSet to return false.\n    return selectionSet.selections.every(function (selection) {\n        // Avoid re-processing the same selection at the same level of recursion, in\n        // case the same field gets included via multiple indirect fragment spreads.\n        if (seenSelections.has(selection))\n            return true;\n        seenSelections.add(selection);\n        // Ignore @skip(if: true) and @include(if: false) fields.\n        if (!(0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_4__.shouldInclude)(selection, context.variables))\n            return true;\n        // If the field or (named) fragment spread has a @nonreactive directive on\n        // it, we don't care if it's different, so we pretend it's the same.\n        if (selectionHasNonreactiveDirective(selection))\n            return true;\n        if ((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.isField)(selection)) {\n            var resultKey = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_5__.resultKeyNameFromField)(selection);\n            var aResultChild = aResult && aResult[resultKey];\n            var bResultChild = bResult && bResult[resultKey];\n            var childSelectionSet = selection.selectionSet;\n            if (!childSelectionSet) {\n                // These are scalar values, so we can compare them with deep equal\n                // without redoing the main recursive work.\n                return (0,_wry_equality__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(aResultChild, bResultChild);\n            }\n            var aChildIsArray = Array.isArray(aResultChild);\n            var bChildIsArray = Array.isArray(bResultChild);\n            if (aChildIsArray !== bChildIsArray)\n                return false;\n            if (aChildIsArray && bChildIsArray) {\n                var length_1 = aResultChild.length;\n                if (bResultChild.length !== length_1) {\n                    return false;\n                }\n                for (var i = 0; i < length_1; ++i) {\n                    if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n        }\n        else {\n            var fragment = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_3__.getFragmentFromSelection)(selection, context.fragmentMap);\n            if (fragment) {\n                // The fragment might === selection if it's an inline fragment, but\n                // could be !== if it's a named fragment ...spread.\n                if (selectionHasNonreactiveDirective(fragment))\n                    return true;\n                return equalBySelectionSet(fragment.selectionSet, \n                // Notice that we reuse the same aResult and bResult values here,\n                // since the fragment ...spread does not specify a field name, but\n                // consists of multiple fields (within the fragment's selection set)\n                // that should be applied to the current result value(s).\n                aResult, bResult, context);\n            }\n        }\n    });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n    return (!!selection.directives && selection.directives.some(directiveIsNonreactive));\n}\nfunction directiveIsNonreactive(dir) {\n    return dir.name.value === \"nonreactive\";\n}\n//# sourceMappingURL=equalByQuery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL2VxdWFsQnlRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStCO0FBQ0c7QUFDOEk7QUFDaEw7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLDZDQUFNO0FBQ3ZDLGlDQUFpQyw2Q0FBTTtBQUN2QyxZQUFZLHlEQUFLO0FBQ2pCLDRCQUE0QixzRUFBaUI7QUFDN0MseUJBQXlCLHNFQUFpQixDQUFDLDJFQUFzQjtBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQU87QUFDbkIsNEJBQTRCLDJFQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkVBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGFwb2xsb1xcY2xpZW50XFxjb3JlXFxlcXVhbEJ5UXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgZXF1YWwgZnJvbSBcIkB3cnkvZXF1YWxpdHlcIjtcbmltcG9ydCB7IGNyZWF0ZUZyYWdtZW50TWFwLCBnZXRGcmFnbWVudERlZmluaXRpb25zLCBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb24sIGdldE1haW5EZWZpbml0aW9uLCBpc0ZpZWxkLCByZXN1bHRLZXlOYW1lRnJvbUZpZWxkLCBzaG91bGRJbmNsdWRlLCB9IGZyb20gXCIuLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbi8vIFJldHVybnMgdHJ1ZSBpZiBhUmVzdWx0IGFuZCBiUmVzdWx0IGFyZSBkZWVwbHkgZXF1YWwgYWNjb3JkaW5nIHRvIHRoZSBmaWVsZHNcbi8vIHNlbGVjdGVkIGJ5IHRoZSBnaXZlbiBxdWVyeSwgaWdub3JpbmcgYW55IGZpZWxkcyBtYXJrZWQgYXMgQG5vbnJlYWN0aXZlLlxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnlRdWVyeShxdWVyeSwgX2EsIF9iLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgYURhdGEgPSBfYS5kYXRhLCBhUmVzdCA9IF9fcmVzdChfYSwgW1wiZGF0YVwiXSk7XG4gICAgdmFyIGJEYXRhID0gX2IuZGF0YSwgYlJlc3QgPSBfX3Jlc3QoX2IsIFtcImRhdGFcIl0pO1xuICAgIHJldHVybiAoZXF1YWwoYVJlc3QsIGJSZXN0KSAmJlxuICAgICAgICBlcXVhbEJ5U2VsZWN0aW9uU2V0KGdldE1haW5EZWZpbml0aW9uKHF1ZXJ5KS5zZWxlY3Rpb25TZXQsIGFEYXRhLCBiRGF0YSwge1xuICAgICAgICAgICAgZnJhZ21lbnRNYXA6IGNyZWF0ZUZyYWdtZW50TWFwKGdldEZyYWdtZW50RGVmaW5pdGlvbnMocXVlcnkpKSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICB9KSk7XG59XG5mdW5jdGlvbiBlcXVhbEJ5U2VsZWN0aW9uU2V0KHNlbGVjdGlvblNldCwgYVJlc3VsdCwgYlJlc3VsdCwgY29udGV4dCkge1xuICAgIGlmIChhUmVzdWx0ID09PSBiUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgc2VlblNlbGVjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgLy8gUmV0dXJuaW5nIHRydWUgZnJvbSB0aGlzIEFycmF5LnByb3RvdHlwZS5ldmVyeSBjYWxsYmFjayBmdW5jdGlvbiBza2lwcyB0aGVcbiAgICAvLyBjdXJyZW50IGZpZWxkL3N1YnRyZWUuIFJldHVybmluZyBmYWxzZSBhYm9ydHMgdGhlIGVudGlyZSB0cmF2ZXJzYWxcbiAgICAvLyBpbW1lZGlhdGVseSwgY2F1c2luZyBlcXVhbEJ5U2VsZWN0aW9uU2V0IHRvIHJldHVybiBmYWxzZS5cbiAgICByZXR1cm4gc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAvLyBBdm9pZCByZS1wcm9jZXNzaW5nIHRoZSBzYW1lIHNlbGVjdGlvbiBhdCB0aGUgc2FtZSBsZXZlbCBvZiByZWN1cnNpb24sIGluXG4gICAgICAgIC8vIGNhc2UgdGhlIHNhbWUgZmllbGQgZ2V0cyBpbmNsdWRlZCB2aWEgbXVsdGlwbGUgaW5kaXJlY3QgZnJhZ21lbnQgc3ByZWFkcy5cbiAgICAgICAgaWYgKHNlZW5TZWxlY3Rpb25zLmhhcyhzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHNlZW5TZWxlY3Rpb25zLmFkZChzZWxlY3Rpb24pO1xuICAgICAgICAvLyBJZ25vcmUgQHNraXAoaWY6IHRydWUpIGFuZCBAaW5jbHVkZShpZjogZmFsc2UpIGZpZWxkcy5cbiAgICAgICAgaWYgKCFzaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgY29udGV4dC52YXJpYWJsZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBvciAobmFtZWQpIGZyYWdtZW50IHNwcmVhZCBoYXMgYSBAbm9ucmVhY3RpdmUgZGlyZWN0aXZlIG9uXG4gICAgICAgIC8vIGl0LCB3ZSBkb24ndCBjYXJlIGlmIGl0J3MgZGlmZmVyZW50LCBzbyB3ZSBwcmV0ZW5kIGl0J3MgdGhlIHNhbWUuXG4gICAgICAgIGlmIChzZWxlY3Rpb25IYXNOb25yZWFjdGl2ZURpcmVjdGl2ZShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRLZXkgPSByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB2YXIgYVJlc3VsdENoaWxkID0gYVJlc3VsdCAmJiBhUmVzdWx0W3Jlc3VsdEtleV07XG4gICAgICAgICAgICB2YXIgYlJlc3VsdENoaWxkID0gYlJlc3VsdCAmJiBiUmVzdWx0W3Jlc3VsdEtleV07XG4gICAgICAgICAgICB2YXIgY2hpbGRTZWxlY3Rpb25TZXQgPSBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0O1xuICAgICAgICAgICAgaWYgKCFjaGlsZFNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBzY2FsYXIgdmFsdWVzLCBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIHdpdGggZGVlcCBlcXVhbFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgcmVkb2luZyB0aGUgbWFpbiByZWN1cnNpdmUgd29yay5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWwoYVJlc3VsdENoaWxkLCBiUmVzdWx0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFDaGlsZElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGFSZXN1bHRDaGlsZCk7XG4gICAgICAgICAgICB2YXIgYkNoaWxkSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYlJlc3VsdENoaWxkKTtcbiAgICAgICAgICAgIGlmIChhQ2hpbGRJc0FycmF5ICE9PSBiQ2hpbGRJc0FycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhQ2hpbGRJc0FycmF5ICYmIGJDaGlsZElzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBhUmVzdWx0Q2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChiUmVzdWx0Q2hpbGQubGVuZ3RoICE9PSBsZW5ndGhfMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzE7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQnlTZWxlY3Rpb25TZXQoY2hpbGRTZWxlY3Rpb25TZXQsIGFSZXN1bHRDaGlsZFtpXSwgYlJlc3VsdENoaWxkW2ldLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVxdWFsQnlTZWxlY3Rpb25TZXQoY2hpbGRTZWxlY3Rpb25TZXQsIGFSZXN1bHRDaGlsZCwgYlJlc3VsdENoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbihzZWxlY3Rpb24sIGNvbnRleHQuZnJhZ21lbnRNYXApO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZyYWdtZW50IG1pZ2h0ID09PSBzZWxlY3Rpb24gaWYgaXQncyBhbiBpbmxpbmUgZnJhZ21lbnQsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGNvdWxkIGJlICE9PSBpZiBpdCdzIGEgbmFtZWQgZnJhZ21lbnQgLi4uc3ByZWFkLlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25IYXNOb25yZWFjdGl2ZURpcmVjdGl2ZShmcmFnbWVudCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbEJ5U2VsZWN0aW9uU2V0KGZyYWdtZW50LnNlbGVjdGlvblNldCwgXG4gICAgICAgICAgICAgICAgLy8gTm90aWNlIHRoYXQgd2UgcmV1c2UgdGhlIHNhbWUgYVJlc3VsdCBhbmQgYlJlc3VsdCB2YWx1ZXMgaGVyZSxcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgZnJhZ21lbnQgLi4uc3ByZWFkIGRvZXMgbm90IHNwZWNpZnkgYSBmaWVsZCBuYW1lLCBidXRcbiAgICAgICAgICAgICAgICAvLyBjb25zaXN0cyBvZiBtdWx0aXBsZSBmaWVsZHMgKHdpdGhpbiB0aGUgZnJhZ21lbnQncyBzZWxlY3Rpb24gc2V0KVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgcmVzdWx0IHZhbHVlKHMpLlxuICAgICAgICAgICAgICAgIGFSZXN1bHQsIGJSZXN1bHQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25IYXNOb25yZWFjdGl2ZURpcmVjdGl2ZShzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gKCEhc2VsZWN0aW9uLmRpcmVjdGl2ZXMgJiYgc2VsZWN0aW9uLmRpcmVjdGl2ZXMuc29tZShkaXJlY3RpdmVJc05vbnJlYWN0aXZlKSk7XG59XG5mdW5jdGlvbiBkaXJlY3RpdmVJc05vbnJlYWN0aXZlKGRpcikge1xuICAgIHJldHVybiBkaXIubmFtZS52YWx1ZSA9PT0gXCJub25yZWFjdGl2ZVwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWxCeVF1ZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/equalByQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js":
/*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/core/networkStatus.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetworkStatus: () => (/* binding */ NetworkStatus),\n/* harmony export */   isNetworkRequestInFlight: () => (/* binding */ isNetworkRequestInFlight),\n/* harmony export */   isNetworkRequestSettled: () => (/* binding */ isNetworkRequestSettled)\n/* harmony export */ });\n/**\n * The current status of a queryâ€™s execution in our system.\n */\nvar NetworkStatus;\n(function (NetworkStatus) {\n    /**\n     * The query has never been run before and the query is now currently running. A query will still\n     * have this network status even if a partial data result was returned from the cache, but a\n     * query was dispatched anyway.\n     */\n    NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n    /**\n     * If `setVariables` was called and a query was fired because of that then the network status\n     * will be `setVariables` until the result of that query comes back.\n     */\n    NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n    /**\n     * Indicates that `fetchMore` was called on this query and that the query created is currently in\n     * flight.\n     */\n    NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n    /**\n     * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n     * and the refetch request is currently in flight.\n     */\n    NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n    /**\n     * Indicates that a polling query is currently in flight. So for example if you are polling a\n     * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n     * a poll request has been sent but not resolved.\n     */\n    NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n    /**\n     * No request is in flight for this query, and no errors happened. Everything is OK.\n     */\n    NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n    /**\n     * No request is in flight for this query, but one or more errors were detected.\n     */\n    NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nfunction isNetworkRequestInFlight(networkStatus) {\n    return networkStatus ? networkStatus < 7 : false;\n}\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nfunction isNetworkRequestSettled(networkStatus) {\n    return networkStatus === 7 || networkStatus === 8;\n}\n//# sourceMappingURL=networkStatus.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jb3JlL25ldHdvcmtTdGF0dXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGFwb2xsb1xcY2xpZW50XFxjb3JlXFxuZXR3b3JrU3RhdHVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGN1cnJlbnQgc3RhdHVzIG9mIGEgcXVlcnnigJlzIGV4ZWN1dGlvbiBpbiBvdXIgc3lzdGVtLlxuICovXG5leHBvcnQgdmFyIE5ldHdvcmtTdGF0dXM7XG4oZnVuY3Rpb24gKE5ldHdvcmtTdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgaGFzIG5ldmVyIGJlZW4gcnVuIGJlZm9yZSBhbmQgdGhlIHF1ZXJ5IGlzIG5vdyBjdXJyZW50bHkgcnVubmluZy4gQSBxdWVyeSB3aWxsIHN0aWxsXG4gICAgICogaGF2ZSB0aGlzIG5ldHdvcmsgc3RhdHVzIGV2ZW4gaWYgYSBwYXJ0aWFsIGRhdGEgcmVzdWx0IHdhcyByZXR1cm5lZCBmcm9tIHRoZSBjYWNoZSwgYnV0IGFcbiAgICAgKiBxdWVyeSB3YXMgZGlzcGF0Y2hlZCBhbnl3YXkuXG4gICAgICovXG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wibG9hZGluZ1wiXSA9IDFdID0gXCJsb2FkaW5nXCI7XG4gICAgLyoqXG4gICAgICogSWYgYHNldFZhcmlhYmxlc2Agd2FzIGNhbGxlZCBhbmQgYSBxdWVyeSB3YXMgZmlyZWQgYmVjYXVzZSBvZiB0aGF0IHRoZW4gdGhlIG5ldHdvcmsgc3RhdHVzXG4gICAgICogd2lsbCBiZSBgc2V0VmFyaWFibGVzYCB1bnRpbCB0aGUgcmVzdWx0IG9mIHRoYXQgcXVlcnkgY29tZXMgYmFjay5cbiAgICAgKi9cbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJzZXRWYXJpYWJsZXNcIl0gPSAyXSA9IFwic2V0VmFyaWFibGVzXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYGZldGNoTW9yZWAgd2FzIGNhbGxlZCBvbiB0aGlzIHF1ZXJ5IGFuZCB0aGF0IHRoZSBxdWVyeSBjcmVhdGVkIGlzIGN1cnJlbnRseSBpblxuICAgICAqIGZsaWdodC5cbiAgICAgKi9cbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJmZXRjaE1vcmVcIl0gPSAzXSA9IFwiZmV0Y2hNb3JlXCI7XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byB0aGUgYHNldFZhcmlhYmxlc2AgbmV0d29yayBzdGF0dXMuIEl0IG1lYW5zIHRoYXQgYHJlZmV0Y2hgIHdhcyBjYWxsZWQgb24gYSBxdWVyeVxuICAgICAqIGFuZCB0aGUgcmVmZXRjaCByZXF1ZXN0IGlzIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAgICovXG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wicmVmZXRjaFwiXSA9IDRdID0gXCJyZWZldGNoXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBwb2xsaW5nIHF1ZXJ5IGlzIGN1cnJlbnRseSBpbiBmbGlnaHQuIFNvIGZvciBleGFtcGxlIGlmIHlvdSBhcmUgcG9sbGluZyBhXG4gICAgICogcXVlcnkgZXZlcnkgMTAgc2Vjb25kcyB0aGVuIHRoZSBuZXR3b3JrIHN0YXR1cyB3aWxsIHN3aXRjaCB0byBgcG9sbGAgZXZlcnkgMTAgc2Vjb25kcyB3aGVuZXZlclxuICAgICAqIGEgcG9sbCByZXF1ZXN0IGhhcyBiZWVuIHNlbnQgYnV0IG5vdCByZXNvbHZlZC5cbiAgICAgKi9cbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJwb2xsXCJdID0gNl0gPSBcInBvbGxcIjtcbiAgICAvKipcbiAgICAgKiBObyByZXF1ZXN0IGlzIGluIGZsaWdodCBmb3IgdGhpcyBxdWVyeSwgYW5kIG5vIGVycm9ycyBoYXBwZW5lZC4gRXZlcnl0aGluZyBpcyBPSy5cbiAgICAgKi9cbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJyZWFkeVwiXSA9IDddID0gXCJyZWFkeVwiO1xuICAgIC8qKlxuICAgICAqIE5vIHJlcXVlc3QgaXMgaW4gZmxpZ2h0IGZvciB0aGlzIHF1ZXJ5LCBidXQgb25lIG9yIG1vcmUgZXJyb3JzIHdlcmUgZGV0ZWN0ZWQuXG4gICAgICovXG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wiZXJyb3JcIl0gPSA4XSA9IFwiZXJyb3JcIjtcbn0pKE5ldHdvcmtTdGF0dXMgfHwgKE5ldHdvcmtTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgbmV0d29yayByZXF1ZXN0IGluIGZsaWdodCBhY2NvcmRpbmcgdG8gYSBnaXZlbiBuZXR3b3JrXG4gKiBzdGF0dXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cykge1xuICAgIHJldHVybiBuZXR3b3JrU3RhdHVzID8gbmV0d29ya1N0YXR1cyA8IDcgOiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBuZXR3b3JrIHJlcXVlc3QgaXMgaW4gcmVhZHkgb3IgZXJyb3Igc3RhdGUgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gbmV0d29ya1xuICogc3RhdHVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOZXR3b3JrUmVxdWVzdFNldHRsZWQobmV0d29ya1N0YXR1cykge1xuICAgIHJldHVybiBuZXR3b3JrU3RhdHVzID09PSA3IHx8IG5ldHdvcmtTdGF0dXMgPT09IDg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrU3RhdHVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/react/hooks/internal/wrapHook.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@apollo/client/react/hooks/internal/wrapHook.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wrapHook: () => (/* binding */ wrapHook)\n/* harmony export */ });\nvar wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nfunction wrapHook(hookName, useHook, clientOrObsQuery) {\n    var queryManager = clientOrObsQuery[\"queryManager\"];\n    var wrappers = queryManager && queryManager[wrapperSymbol];\n    var wrapper = wrappers && wrappers[hookName];\n    return wrapper ? wrapper(useHook) : useHook;\n}\n//# sourceMappingURL=wrapHook.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9ob29rcy9pbnRlcm5hbC93cmFwSG9vay5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZELHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXHJlYWN0XFxob29rc1xcaW50ZXJuYWxcXHdyYXBIb29rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB3cmFwcGVyU3ltYm9sID0gU3ltYm9sLmZvcihcImFwb2xsby5ob29rLndyYXBwZXJzXCIpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBNYWtlcyBhbiBBcG9sbG8gQ2xpZW50IGhvb2sgXCJ3cmFwcGFibGVcIi5cbiAqIFRoYXQgbWVhbnMgdGhhdCB0aGUgQXBvbGxvIENsaWVudCBpbnN0YW5jZSBjYW4gZXhwb3NlIGEgXCJ3cmFwcGVyXCIgdGhhdCB3aWxsIGJlXG4gKiB1c2VkIHRvIHdyYXAgdGhlIG9yaWdpbmFsIGhvb2sgaW1wbGVtZW50YXRpb24gd2l0aCBhZGRpdGlvbmFsIGxvZ2ljLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogLy8gdGhpcyBpcyBhbHJlYWR5IGRvbmUgaW4gYEBhcG9sbG8vY2xpZW50YCBmb3IgYWxsIHdyYXBwYWJsZSBob29rcyAoc2VlIGBXcmFwcGFibGVIb29rc2ApXG4gKiAvLyBmb2xsb3dpbmcgdGhpcyBwYXR0ZXJuXG4gKiBmdW5jdGlvbiB1c2VRdWVyeSgpIHtcbiAqICAgcmV0dXJuIHdyYXBIb29rKCd1c2VRdWVyeScsIF91c2VRdWVyeSwgb3B0aW9ucy5jbGllbnQpKHF1ZXJ5LCBvcHRpb25zKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIF91c2VRdWVyeShxdWVyeSwgb3B0aW9ucykge1xuICogICAvLyBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvblxuICogfVxuICpcbiAqIC8vIHRoaXMgaXMgd2hhdCBhIGxpYnJhcnkgbGlrZSBgQGFwb2xsby9jbGllbnQtcmVhY3Qtc3RyZWFtaW5nYCB3b3VsZCBkb1xuICogY2xhc3MgQXBvbGxvQ2xpZW50V2l0aFN0cmVhbWluZyBleHRlbmRzIEFwb2xsb0NsaWVudCB7XG4gKiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAqICAgICBzdXBlcihvcHRpb25zKTtcbiAqICAgICB0aGlzLnF1ZXJ5TWFuYWdlcltTeW1ib2wuZm9yKFwiYXBvbGxvLmhvb2sud3JhcHBlcnNcIildID0ge1xuICogICAgICAgdXNlUXVlcnk6IChvcmlnaW5hbCkgPT4gKHF1ZXJ5LCBvcHRpb25zKSA9PiB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwidXNlUXVlcnkgd2FzIGNhbGxlZCB3aXRoIG9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gKiAgICAgICAgIHJldHVybiBvcmlnaW5hbChxdWVyeSwgb3B0aW9ucyk7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICogLy8gdGhpcyB3aWxsIG5vdyBsb2cgdGhlIG9wdGlvbnMgYW5kIHRoZW4gY2FsbCB0aGUgb3JpZ2luYWwgYHVzZVF1ZXJ5YFxuICogY29uc3QgY2xpZW50ID0gbmV3IEFwb2xsb0NsaWVudFdpdGhTdHJlYW1pbmcoeyAuLi4gfSk7XG4gKiB1c2VRdWVyeShxdWVyeSwgeyBjbGllbnQgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBIb29rKGhvb2tOYW1lLCB1c2VIb29rLCBjbGllbnRPck9ic1F1ZXJ5KSB7XG4gICAgdmFyIHF1ZXJ5TWFuYWdlciA9IGNsaWVudE9yT2JzUXVlcnlbXCJxdWVyeU1hbmFnZXJcIl07XG4gICAgdmFyIHdyYXBwZXJzID0gcXVlcnlNYW5hZ2VyICYmIHF1ZXJ5TWFuYWdlclt3cmFwcGVyU3ltYm9sXTtcbiAgICB2YXIgd3JhcHBlciA9IHdyYXBwZXJzICYmIHdyYXBwZXJzW2hvb2tOYW1lXTtcbiAgICByZXR1cm4gd3JhcHBlciA/IHdyYXBwZXIodXNlSG9vaykgOiB1c2VIb29rO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcEhvb2suanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/react/hooks/internal/wrapHook.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useLazyQuery.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@apollo/client/react/hooks/useLazyQuery.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLazyQuery: () => (/* binding */ useLazyQuery)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var rehackt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rehackt */ \"(app-pages-browser)/./node_modules/rehackt/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeOptions.js\");\n/* harmony import */ var _useQuery_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useQuery.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useQuery.js\");\n/* harmony import */ var _internal_useIsomorphicLayoutEffect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/useIsomorphicLayoutEffect.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/hooks/internal/useIsomorphicLayoutEffect.js\");\n\n\n\n\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nvar EAGER_METHODS = [\n    \"refetch\",\n    \"reobserve\",\n    \"fetchMore\",\n    \"updateQuery\",\n    \"startPolling\",\n    \"stopPolling\",\n    \"subscribeToMore\",\n];\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nfunction useLazyQuery(query, options) {\n    var _a;\n    var execOptionsRef = rehackt__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    var optionsRef = rehackt__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    var queryRef = rehackt__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    var merged = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeOptions)(options, execOptionsRef.current || {});\n    var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;\n    // Use refs to track options and the used query to ensure the `execute`\n    // function remains referentially stable between renders.\n    optionsRef.current = options;\n    queryRef.current = document;\n    var queryHookOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, merged), { skip: !execOptionsRef.current });\n    var _b = (0,_useQuery_js__WEBPACK_IMPORTED_MODULE_3__.useQueryInternals)(document, queryHookOptions), obsQueryFields = _b.obsQueryFields, useQueryResult = _b.result, client = _b.client, resultData = _b.resultData, observable = _b.observable, onQueryExecuted = _b.onQueryExecuted;\n    var initialFetchPolicy = observable.options.initialFetchPolicy ||\n        (0,_useQuery_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultFetchPolicy)(queryHookOptions.defaultOptions, client.defaultOptions);\n    var forceUpdateState = rehackt__WEBPACK_IMPORTED_MODULE_0__.useReducer(function (tick) { return tick + 1; }, 0)[1];\n    // We use useMemo here to make sure the eager methods have a stable identity.\n    var eagerMethods = rehackt__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n        var eagerMethods = {};\n        var _loop_1 = function (key) {\n            var method = obsQueryFields[key];\n            eagerMethods[key] = function () {\n                if (!execOptionsRef.current) {\n                    execOptionsRef.current = Object.create(null);\n                    // Only the first time populating execOptionsRef.current matters here.\n                    forceUpdateState();\n                }\n                // @ts-expect-error this is just too generic to type\n                return method.apply(this, arguments);\n            };\n        };\n        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n            var key = EAGER_METHODS_1[_i];\n            _loop_1(key);\n        }\n        return eagerMethods;\n    }, [forceUpdateState, obsQueryFields]);\n    var called = !!execOptionsRef.current;\n    var result = rehackt__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () { return ((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, useQueryResult), eagerMethods), { called: called })); }, [useQueryResult, eagerMethods, called]);\n    var execute = rehackt__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (executeOptions) {\n        execOptionsRef.current =\n            executeOptions ? (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {\n                fetchPolicy: initialFetchPolicy,\n            };\n        var options = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_1__.mergeOptions)(optionsRef.current, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({ query: queryRef.current }, execOptionsRef.current));\n        var promise = executeQuery(resultData, observable, client, document, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), { skip: false }), onQueryExecuted).then(function (queryResult) { return Object.assign(queryResult, eagerMethods); });\n        // Because the return value of `useLazyQuery` is usually floated, we need\n        // to catch the promise to prevent unhandled rejections.\n        promise.catch(function () { });\n        return promise;\n    }, [\n        client,\n        document,\n        eagerMethods,\n        initialFetchPolicy,\n        observable,\n        resultData,\n        onQueryExecuted,\n    ]);\n    var executeRef = rehackt__WEBPACK_IMPORTED_MODULE_0__.useRef(execute);\n    (0,_internal_useIsomorphicLayoutEffect_js__WEBPACK_IMPORTED_MODULE_4__.useIsomorphicLayoutEffect)(function () {\n        executeRef.current = execute;\n    });\n    var stableExecute = rehackt__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return executeRef.current.apply(executeRef, args);\n    }, []);\n    return [stableExecute, result];\n}\nfunction executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {\n    var query = options.query || currentQuery;\n    var watchQueryOptions = (0,_useQuery_js__WEBPACK_IMPORTED_MODULE_3__.createMakeWatchQueryOptions)(client, query, options, false)(observable);\n    var concast = observable.reobserveAsConcast((0,_useQuery_js__WEBPACK_IMPORTED_MODULE_3__.getObsQueryOptions)(observable, client, options, watchQueryOptions));\n    onQueryExecuted(watchQueryOptions);\n    return new Promise(function (resolve) {\n        var result;\n        // Subscribe to the concast independently of the ObservableQuery in case\n        // the component gets unmounted before the promise resolves. This prevents\n        // the concast from terminating early and resolving with `undefined` when\n        // there are no more subscribers for the concast.\n        concast.subscribe({\n            next: function (value) {\n                result = value;\n            },\n            error: function () {\n                resolve((0,_useQuery_js__WEBPACK_IMPORTED_MODULE_3__.toQueryResult)(observable.getCurrentResult(), resultData.previousData, observable, client));\n            },\n            complete: function () {\n                resolve((0,_useQuery_js__WEBPACK_IMPORTED_MODULE_3__.toQueryResult)(observable[\"maskResult\"](result), resultData.previousData, observable, client));\n            },\n        });\n    });\n}\n//# sourceMappingURL=useLazyQuery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9ob29rcy91c2VMYXp5UXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBQ0E7QUFDdUI7QUFDa0Y7QUFDdEQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseUJBQXlCLDJDQUFZO0FBQ3JDLHFCQUFxQiwyQ0FBWTtBQUNqQyxtQkFBbUIsMkNBQVk7QUFDL0IsaUJBQWlCLGlFQUFZLHNDQUFzQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxhQUFhLCtCQUErQjtBQUMzRixhQUFhLCtEQUFpQjtBQUM5QjtBQUNBLFFBQVEsbUVBQXFCO0FBQzdCLDJCQUEyQiwrQ0FBZ0IsbUJBQW1CLGtCQUFrQjtBQUNoRjtBQUNBLHVCQUF1Qiw0Q0FBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw2QkFBNkI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIsNENBQWEsZUFBZSxRQUFRLCtDQUFRLENBQUMsK0NBQVEsQ0FBQywrQ0FBUSxHQUFHLG9DQUFvQyxnQkFBZ0IsS0FBSztBQUMzSSxrQkFBa0IsZ0RBQWlCO0FBQ25DO0FBQ0EsNkJBQTZCLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxxQkFBcUIsK0RBQStEO0FBQ3JJO0FBQ0E7QUFDQSxzQkFBc0IsaUVBQVkscUJBQXFCLCtDQUFRLEdBQUcseUJBQXlCO0FBQzNGLDZFQUE2RSwrQ0FBUSxDQUFDLCtDQUFRLEdBQUcsY0FBYyxhQUFhLGtEQUFrRCxrREFBa0Q7QUFDaE87QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFZO0FBQ2pDLElBQUksaUdBQXlCO0FBQzdCO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixnREFBaUI7QUFDekM7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5RUFBMkI7QUFDdkQsZ0RBQWdELGdFQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QiwyREFBYTtBQUNyQyxhQUFhO0FBQ2I7QUFDQSx3QkFBd0IsMkRBQWE7QUFDckMsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXHJlYWN0XFxob29rc1xcdXNlTGF6eVF1ZXJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVoYWNrdFwiO1xuaW1wb3J0IHsgbWVyZ2VPcHRpb25zIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlTWFrZVdhdGNoUXVlcnlPcHRpb25zLCBnZXREZWZhdWx0RmV0Y2hQb2xpY3ksIGdldE9ic1F1ZXJ5T3B0aW9ucywgdG9RdWVyeVJlc3VsdCwgdXNlUXVlcnlJbnRlcm5hbHMsIH0gZnJvbSBcIi4vdXNlUXVlcnkuanNcIjtcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi9pbnRlcm5hbC91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LmpzXCI7XG4vLyBUaGUgZm9sbG93aW5nIG1ldGhvZHMsIHdoZW4gY2FsbGVkIHdpbGwgZXhlY3V0ZSB0aGUgcXVlcnksIHJlZ2FyZGxlc3Mgb2Zcbi8vIHdoZXRoZXIgdGhlIHVzZUxhenlRdWVyeSBleGVjdXRlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYmVmb3JlLlxudmFyIEVBR0VSX01FVEhPRFMgPSBbXG4gICAgXCJyZWZldGNoXCIsXG4gICAgXCJyZW9ic2VydmVcIixcbiAgICBcImZldGNoTW9yZVwiLFxuICAgIFwidXBkYXRlUXVlcnlcIixcbiAgICBcInN0YXJ0UG9sbGluZ1wiLFxuICAgIFwic3RvcFBvbGxpbmdcIixcbiAgICBcInN1YnNjcmliZVRvTW9yZVwiLFxuXTtcbi8qKlxuICogQSBob29rIGZvciBpbXBlcmF0aXZlbHkgZXhlY3V0aW5nIHF1ZXJpZXMgaW4gYW4gQXBvbGxvIGFwcGxpY2F0aW9uLCBlLmcuIGluIHJlc3BvbnNlIHRvIHVzZXIgaW50ZXJhY3Rpb24uXG4gKlxuICogPiBSZWZlciB0byB0aGUgW1F1ZXJpZXMgLSBNYW51YWwgZXhlY3V0aW9uIHdpdGggdXNlTGF6eVF1ZXJ5XShodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL3JlYWN0L2RhdGEvcXVlcmllcyNtYW51YWwtZXhlY3V0aW9uLXdpdGgtdXNlbGF6eXF1ZXJ5KSBzZWN0aW9uIGZvciBhIG1vcmUgaW4tZGVwdGggb3ZlcnZpZXcgb2YgYHVzZUxhenlRdWVyeWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgZ3FsLCB1c2VMYXp5UXVlcnkgfSBmcm9tIFwiQGFwb2xsby9jbGllbnRcIjtcbiAqXG4gKiBjb25zdCBHRVRfR1JFRVRJTkcgPSBncWxgXG4gKiAgIHF1ZXJ5IEdldEdyZWV0aW5nKCRsYW5ndWFnZTogU3RyaW5nISkge1xuICogICAgIGdyZWV0aW5nKGxhbmd1YWdlOiAkbGFuZ3VhZ2UpIHtcbiAqICAgICAgIG1lc3NhZ2VcbiAqICAgICB9XG4gKiAgIH1cbiAqIGA7XG4gKlxuICogZnVuY3Rpb24gSGVsbG8oKSB7XG4gKiAgIGNvbnN0IFtsb2FkR3JlZXRpbmcsIHsgY2FsbGVkLCBsb2FkaW5nLCBkYXRhIH1dID0gdXNlTGF6eVF1ZXJ5KFxuICogICAgIEdFVF9HUkVFVElORyxcbiAqICAgICB7IHZhcmlhYmxlczogeyBsYW5ndWFnZTogXCJlbmdsaXNoXCIgfSB9XG4gKiAgICk7XG4gKiAgIGlmIChjYWxsZWQgJiYgbG9hZGluZykgcmV0dXJuIDxwPkxvYWRpbmcgLi4uPC9wPlxuICogICBpZiAoIWNhbGxlZCkge1xuICogICAgIHJldHVybiA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGxvYWRHcmVldGluZygpfT5Mb2FkIGdyZWV0aW5nPC9idXR0b24+XG4gKiAgIH1cbiAqICAgcmV0dXJuIDxoMT5IZWxsbyB7ZGF0YS5ncmVldGluZy5tZXNzYWdlfSE8L2gxPjtcbiAqIH1cbiAqIGBgYFxuICogQHNpbmNlIDMuMC4wXG4gKlxuICogQHBhcmFtIHF1ZXJ5IC0gQSBHcmFwaFFMIHF1ZXJ5IGRvY3VtZW50IHBhcnNlZCBpbnRvIGFuIEFTVCBieSBgZ3FsYC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRGVmYXVsdCBvcHRpb25zIHRvIGNvbnRyb2wgaG93IHRoZSBxdWVyeSBpcyBleGVjdXRlZC5cbiAqIEByZXR1cm5zIEEgdHVwbGUgaW4gdGhlIGZvcm0gb2YgYFtleGVjdXRlLCByZXN1bHRdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGF6eVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBleGVjT3B0aW9uc1JlZiA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICAgIHZhciBvcHRpb25zUmVmID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgdmFyIHF1ZXJ5UmVmID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgdmFyIG1lcmdlZCA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCBleGVjT3B0aW9uc1JlZi5jdXJyZW50IHx8IHt9KTtcbiAgICB2YXIgZG9jdW1lbnQgPSAoX2EgPSBtZXJnZWQgPT09IG51bGwgfHwgbWVyZ2VkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXJnZWQucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHF1ZXJ5O1xuICAgIC8vIFVzZSByZWZzIHRvIHRyYWNrIG9wdGlvbnMgYW5kIHRoZSB1c2VkIHF1ZXJ5IHRvIGVuc3VyZSB0aGUgYGV4ZWN1dGVgXG4gICAgLy8gZnVuY3Rpb24gcmVtYWlucyByZWZlcmVudGlhbGx5IHN0YWJsZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgb3B0aW9uc1JlZi5jdXJyZW50ID0gb3B0aW9ucztcbiAgICBxdWVyeVJlZi5jdXJyZW50ID0gZG9jdW1lbnQ7XG4gICAgdmFyIHF1ZXJ5SG9va09wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbWVyZ2VkKSwgeyBza2lwOiAhZXhlY09wdGlvbnNSZWYuY3VycmVudCB9KTtcbiAgICB2YXIgX2IgPSB1c2VRdWVyeUludGVybmFscyhkb2N1bWVudCwgcXVlcnlIb29rT3B0aW9ucyksIG9ic1F1ZXJ5RmllbGRzID0gX2Iub2JzUXVlcnlGaWVsZHMsIHVzZVF1ZXJ5UmVzdWx0ID0gX2IucmVzdWx0LCBjbGllbnQgPSBfYi5jbGllbnQsIHJlc3VsdERhdGEgPSBfYi5yZXN1bHREYXRhLCBvYnNlcnZhYmxlID0gX2Iub2JzZXJ2YWJsZSwgb25RdWVyeUV4ZWN1dGVkID0gX2Iub25RdWVyeUV4ZWN1dGVkO1xuICAgIHZhciBpbml0aWFsRmV0Y2hQb2xpY3kgPSBvYnNlcnZhYmxlLm9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5IHx8XG4gICAgICAgIGdldERlZmF1bHRGZXRjaFBvbGljeShxdWVyeUhvb2tPcHRpb25zLmRlZmF1bHRPcHRpb25zLCBjbGllbnQuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHZhciBmb3JjZVVwZGF0ZVN0YXRlID0gUmVhY3QudXNlUmVkdWNlcihmdW5jdGlvbiAodGljaykgeyByZXR1cm4gdGljayArIDE7IH0sIDApWzFdO1xuICAgIC8vIFdlIHVzZSB1c2VNZW1vIGhlcmUgdG8gbWFrZSBzdXJlIHRoZSBlYWdlciBtZXRob2RzIGhhdmUgYSBzdGFibGUgaWRlbnRpdHkuXG4gICAgdmFyIGVhZ2VyTWV0aG9kcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWFnZXJNZXRob2RzID0ge307XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG9ic1F1ZXJ5RmllbGRzW2tleV07XG4gICAgICAgICAgICBlYWdlck1ldGhvZHNba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4ZWNPcHRpb25zUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY09wdGlvbnNSZWYuY3VycmVudCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IHRpbWUgcG9wdWxhdGluZyBleGVjT3B0aW9uc1JlZi5jdXJyZW50IG1hdHRlcnMgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMganVzdCB0b28gZ2VuZXJpYyB0byB0eXBlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBFQUdFUl9NRVRIT0RTXzEgPSBFQUdFUl9NRVRIT0RTOyBfaSA8IEVBR0VSX01FVEhPRFNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBFQUdFUl9NRVRIT0RTXzFbX2ldO1xuICAgICAgICAgICAgX2xvb3BfMShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlYWdlck1ldGhvZHM7XG4gICAgfSwgW2ZvcmNlVXBkYXRlU3RhdGUsIG9ic1F1ZXJ5RmllbGRzXSk7XG4gICAgdmFyIGNhbGxlZCA9ICEhZXhlY09wdGlvbnNSZWYuY3VycmVudDtcbiAgICB2YXIgcmVzdWx0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHVzZVF1ZXJ5UmVzdWx0KSwgZWFnZXJNZXRob2RzKSwgeyBjYWxsZWQ6IGNhbGxlZCB9KSk7IH0sIFt1c2VRdWVyeVJlc3VsdCwgZWFnZXJNZXRob2RzLCBjYWxsZWRdKTtcbiAgICB2YXIgZXhlY3V0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChleGVjdXRlT3B0aW9ucykge1xuICAgICAgICBleGVjT3B0aW9uc1JlZi5jdXJyZW50ID1cbiAgICAgICAgICAgIGV4ZWN1dGVPcHRpb25zID8gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4ZWN1dGVPcHRpb25zKSwgeyBmZXRjaFBvbGljeTogZXhlY3V0ZU9wdGlvbnMuZmV0Y2hQb2xpY3kgfHwgaW5pdGlhbEZldGNoUG9saWN5IH0pIDoge1xuICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiBpbml0aWFsRmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zUmVmLmN1cnJlbnQsIF9fYXNzaWduKHsgcXVlcnk6IHF1ZXJ5UmVmLmN1cnJlbnQgfSwgZXhlY09wdGlvbnNSZWYuY3VycmVudCkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IGV4ZWN1dGVRdWVyeShyZXN1bHREYXRhLCBvYnNlcnZhYmxlLCBjbGllbnQsIGRvY3VtZW50LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgc2tpcDogZmFsc2UgfSksIG9uUXVlcnlFeGVjdXRlZCkudGhlbihmdW5jdGlvbiAocXVlcnlSZXN1bHQpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24ocXVlcnlSZXN1bHQsIGVhZ2VyTWV0aG9kcyk7IH0pO1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgYHVzZUxhenlRdWVyeWAgaXMgdXN1YWxseSBmbG9hdGVkLCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGNhdGNoIHRoZSBwcm9taXNlIHRvIHByZXZlbnQgdW5oYW5kbGVkIHJlamVjdGlvbnMuXG4gICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSwgW1xuICAgICAgICBjbGllbnQsXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICBlYWdlck1ldGhvZHMsXG4gICAgICAgIGluaXRpYWxGZXRjaFBvbGljeSxcbiAgICAgICAgb2JzZXJ2YWJsZSxcbiAgICAgICAgcmVzdWx0RGF0YSxcbiAgICAgICAgb25RdWVyeUV4ZWN1dGVkLFxuICAgIF0pO1xuICAgIHZhciBleGVjdXRlUmVmID0gUmVhY3QudXNlUmVmKGV4ZWN1dGUpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBleGVjdXRlUmVmLmN1cnJlbnQgPSBleGVjdXRlO1xuICAgIH0pO1xuICAgIHZhciBzdGFibGVFeGVjdXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGVjdXRlUmVmLmN1cnJlbnQuYXBwbHkoZXhlY3V0ZVJlZiwgYXJncyk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbc3RhYmxlRXhlY3V0ZSwgcmVzdWx0XTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVRdWVyeShyZXN1bHREYXRhLCBvYnNlcnZhYmxlLCBjbGllbnQsIGN1cnJlbnRRdWVyeSwgb3B0aW9ucywgb25RdWVyeUV4ZWN1dGVkKSB7XG4gICAgdmFyIHF1ZXJ5ID0gb3B0aW9ucy5xdWVyeSB8fCBjdXJyZW50UXVlcnk7XG4gICAgdmFyIHdhdGNoUXVlcnlPcHRpb25zID0gY3JlYXRlTWFrZVdhdGNoUXVlcnlPcHRpb25zKGNsaWVudCwgcXVlcnksIG9wdGlvbnMsIGZhbHNlKShvYnNlcnZhYmxlKTtcbiAgICB2YXIgY29uY2FzdCA9IG9ic2VydmFibGUucmVvYnNlcnZlQXNDb25jYXN0KGdldE9ic1F1ZXJ5T3B0aW9ucyhvYnNlcnZhYmxlLCBjbGllbnQsIG9wdGlvbnMsIHdhdGNoUXVlcnlPcHRpb25zKSk7XG4gICAgb25RdWVyeUV4ZWN1dGVkKHdhdGNoUXVlcnlPcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBjb25jYXN0IGluZGVwZW5kZW50bHkgb2YgdGhlIE9ic2VydmFibGVRdWVyeSBpbiBjYXNlXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgZ2V0cyB1bm1vdW50ZWQgYmVmb3JlIHRoZSBwcm9taXNlIHJlc29sdmVzLiBUaGlzIHByZXZlbnRzXG4gICAgICAgIC8vIHRoZSBjb25jYXN0IGZyb20gdGVybWluYXRpbmcgZWFybHkgYW5kIHJlc29sdmluZyB3aXRoIGB1bmRlZmluZWRgIHdoZW5cbiAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG1vcmUgc3Vic2NyaWJlcnMgZm9yIHRoZSBjb25jYXN0LlxuICAgICAgICBjb25jYXN0LnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodG9RdWVyeVJlc3VsdChvYnNlcnZhYmxlLmdldEN1cnJlbnRSZXN1bHQoKSwgcmVzdWx0RGF0YS5wcmV2aW91c0RhdGEsIG9ic2VydmFibGUsIGNsaWVudCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0b1F1ZXJ5UmVzdWx0KG9ic2VydmFibGVbXCJtYXNrUmVzdWx0XCJdKHJlc3VsdCksIHJlc3VsdERhdGEucHJldmlvdXNEYXRhLCBvYnNlcnZhYmxlLCBjbGllbnQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTGF6eVF1ZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useLazyQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useQuery.js":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/react/hooks/useQuery.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMakeWatchQueryOptions: () => (/* binding */ createMakeWatchQueryOptions),\n/* harmony export */   getDefaultFetchPolicy: () => (/* binding */ getDefaultFetchPolicy),\n/* harmony export */   getObsQueryOptions: () => (/* binding */ getObsQueryOptions),\n/* harmony export */   toApolloError: () => (/* binding */ toApolloError),\n/* harmony export */   toQueryResult: () => (/* binding */ toQueryResult),\n/* harmony export */   useQuery: () => (/* binding */ useQuery),\n/* harmony export */   useQueryInternals: () => (/* binding */ useQueryInternals)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var rehackt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rehackt */ \"(app-pages-browser)/./node_modules/rehackt/index.js\");\n/* harmony import */ var _useSyncExternalStore_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./useSyncExternalStore.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useSyncExternalStore.js\");\n/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wry/equality */ \"(app-pages-browser)/./node_modules/@wry/equality/lib/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/mergeOptions.js\");\n/* harmony import */ var _context_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../context/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/context/ApolloContext.js\");\n/* harmony import */ var _errors_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../errors/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/errors/index.js\");\n/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/ObservableQuery.js\");\n/* harmony import */ var _core_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/core/networkStatus.js\");\n/* harmony import */ var _parser_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parser/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/parser/index.js\");\n/* harmony import */ var _useApolloClient_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useApolloClient.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useApolloClient.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/compact.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js\");\n/* harmony import */ var _internal_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/react/hooks/internal/wrapHook.js\");\n\n/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n * isSSRAllowed\n * disableNetworkFetches\n * partialRefetch\n * renderPromises\n * isSyncSSR\n * callbacks\n */\n/** */\n\n\n\n\n\n\n\n\n\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction noop() { }\nvar lastWatchOptions = Symbol();\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nfunction useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return (0,_internal_index_js__WEBPACK_IMPORTED_MODULE_3__.wrapHook)(\"useQuery\", \n    // eslint-disable-next-line react-compiler/react-compiler\n    useQuery_, (0,_useApolloClient_js__WEBPACK_IMPORTED_MODULE_4__.useApolloClient)(options && options.client))(query, options);\n}\nfunction useQuery_(query, options) {\n    var _a = useQueryInternals(query, options), result = _a.result, obsQueryFields = _a.obsQueryFields;\n    return rehackt__WEBPACK_IMPORTED_MODULE_1__.useMemo(function () { return ((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({}, result), obsQueryFields)); }, [result, obsQueryFields]);\n}\nfunction useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {\n    function createInternalState(previous) {\n        var _a;\n        (0,_parser_index_js__WEBPACK_IMPORTED_MODULE_6__.verifyDocumentType)(query, _parser_index_js__WEBPACK_IMPORTED_MODULE_6__.DocumentType.Query);\n        var internalState = {\n            client: client,\n            query: query,\n            observable: \n            // See if there is an existing observable that was used to fetch the same\n            // data and if so, use it instead since it will contain the proper queryId\n            // to fetch the result set. This is used during SSR.\n            (renderPromises &&\n                renderPromises.getSSRObservable(makeWatchQueryOptions())) ||\n                _core_index_js__WEBPACK_IMPORTED_MODULE_7__.ObservableQuery[\"inactiveOnCreation\"].withValue(!renderPromises, function () {\n                    return client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions()));\n                }),\n            resultData: {\n                // Reuse previousData from previous InternalState (if any) to provide\n                // continuity of previousData even if/when the query or client changes.\n                previousData: (_a = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a === void 0 ? void 0 : _a.data,\n            },\n        };\n        return internalState;\n    }\n    var _a = rehackt__WEBPACK_IMPORTED_MODULE_1__.useState(createInternalState), internalState = _a[0], updateInternalState = _a[1];\n    /**\n     * Used by `useLazyQuery` when a new query is executed.\n     * We keep this logic here since it needs to update things in unsafe\n     * ways and here we at least can keep track of that in a single place.\n     */\n    function onQueryExecuted(watchQueryOptions) {\n        var _a;\n        var _b;\n        // this needs to be set to prevent an immediate `resubscribe` in the\n        // next rerender of the `useQuery` internals\n        Object.assign(internalState.observable, (_a = {},\n            _a[lastWatchOptions] = watchQueryOptions,\n            _a));\n        var resultData = internalState.resultData;\n        updateInternalState((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({}, internalState), { \n            // might be a different query\n            query: watchQueryOptions.query, resultData: Object.assign(resultData, {\n                // We need to modify the previous `resultData` object as we rely on the\n                // object reference in other places\n                previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,\n                current: undefined,\n            }) }));\n    }\n    if (client !== internalState.client || query !== internalState.query) {\n        // If the client or query have changed, we need to create a new InternalState.\n        // This will trigger a re-render with the new state, but it will also continue\n        // to run the current render function to completion.\n        // Since we sometimes trigger some side-effects in the render function, we\n        // re-assign `state` to the new state to ensure that those side-effects are\n        // triggered with the new state.\n        var newInternalState = createInternalState(internalState);\n        updateInternalState(newInternalState);\n        return [newInternalState, onQueryExecuted];\n    }\n    return [internalState, onQueryExecuted];\n}\nfunction useQueryInternals(query, options) {\n    var client = (0,_useApolloClient_js__WEBPACK_IMPORTED_MODULE_4__.useApolloClient)(options.client);\n    var renderPromises = rehackt__WEBPACK_IMPORTED_MODULE_1__.useContext((0,_context_index_js__WEBPACK_IMPORTED_MODULE_8__.getApolloContext)()).renderPromises;\n    var isSyncSSR = !!renderPromises;\n    var disableNetworkFetches = client.disableNetworkFetches;\n    var ssrAllowed = options.ssr !== false && !options.skip;\n    var partialRefetch = options.partialRefetch;\n    var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);\n    var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a[1];\n    var watchQueryOptions = makeWatchQueryOptions(observable);\n    useResubscribeIfNecessary(resultData, // might get mutated during render\n    observable, // might get mutated during render\n    client, options, watchQueryOptions);\n    var obsQueryFields = rehackt__WEBPACK_IMPORTED_MODULE_1__.useMemo(function () { return bindObservableMethods(observable); }, [observable]);\n    useRegisterSSRObservable(observable, renderPromises, ssrAllowed);\n    var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {\n        onCompleted: options.onCompleted || noop,\n        onError: options.onError || noop,\n    });\n    return {\n        result: result,\n        obsQueryFields: obsQueryFields,\n        observable: observable,\n        resultData: resultData,\n        client: client,\n        onQueryExecuted: onQueryExecuted,\n    };\n}\nfunction useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {\n    var callbackRef = rehackt__WEBPACK_IMPORTED_MODULE_1__.useRef(callbacks);\n    rehackt__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n        // Make sure state.onCompleted and state.onError always reflect the latest\n        // options.onCompleted and options.onError callbacks provided to useQuery,\n        // since those functions are often recreated every time useQuery is called.\n        // Like the forceUpdate method, the versions of these methods inherited from\n        // InternalState.prototype are empty no-ops, but we can override them on the\n        // base state object (without modifying the prototype).\n        // eslint-disable-next-line react-compiler/react-compiler\n        callbackRef.current = callbacks;\n    });\n    var resultOverride = ((isSyncSSR || disableNetworkFetches) &&\n        options.ssr === false &&\n        !options.skip) ?\n        // If SSR has been explicitly disabled, and this function has been called\n        // on the server side, return the default loading state.\n        ssrDisabledResult\n        : options.skip || watchQueryOptions.fetchPolicy === \"standby\" ?\n            // When skipping a query (ie. we're not querying for data but still want to\n            // render children), make sure the `data` is cleared out and `loading` is\n            // set to `false` (since we aren't loading anything).\n            //\n            // NOTE: We no longer think this is the correct behavior. Skipping should\n            // not automatically set `data` to `undefined`, but instead leave the\n            // previous data in place. In other words, skipping should not mandate that\n            // previously received data is all of a sudden removed. Unfortunately,\n            // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n            // to address this.\n            skipStandbyResult\n            : void 0;\n    var previousData = resultData.previousData;\n    var currentResultOverride = rehackt__WEBPACK_IMPORTED_MODULE_1__.useMemo(function () {\n        return resultOverride &&\n            toQueryResult(resultOverride, previousData, observable, client);\n    }, [client, observable, resultOverride, previousData]);\n    return (0,_useSyncExternalStore_js__WEBPACK_IMPORTED_MODULE_9__.useSyncExternalStore)(rehackt__WEBPACK_IMPORTED_MODULE_1__.useCallback(function (handleStoreChange) {\n        // reference `disableNetworkFetches` here to ensure that the rules of hooks\n        // keep it as a dependency of this effect, even though it's not used\n        disableNetworkFetches;\n        if (isSyncSSR) {\n            return function () { };\n        }\n        var onNext = function () {\n            var previousResult = resultData.current;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            var result = observable.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (previousResult &&\n                previousResult.loading === result.loading &&\n                previousResult.networkStatus === result.networkStatus &&\n                (0,_wry_equality__WEBPACK_IMPORTED_MODULE_2__.equal)(previousResult.data, result.data)) {\n                return;\n            }\n            setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n        };\n        var onError = function (error) {\n            subscription.current.unsubscribe();\n            subscription.current = observable.resubscribeAfterError(onNext, onError);\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n                // The error is not a GraphQL error\n                throw error;\n            }\n            var previousResult = resultData.current;\n            if (!previousResult ||\n                (previousResult && previousResult.loading) ||\n                !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_2__.equal)(error, previousResult.error)) {\n                setResult({\n                    data: (previousResult &&\n                        previousResult.data),\n                    error: error,\n                    loading: false,\n                    networkStatus: _core_index_js__WEBPACK_IMPORTED_MODULE_10__.NetworkStatus.error,\n                }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n            }\n        };\n        // TODO evaluate if we keep this in\n        // React Compiler cannot handle scoped `let` access, but a mutable object\n        // like this is fine.\n        // was:\n        // let subscription = observable.subscribe(onNext, onError);\n        var subscription = { current: observable.subscribe(onNext, onError) };\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return function () {\n            setTimeout(function () { return subscription.current.unsubscribe(); });\n        };\n    }, [\n        disableNetworkFetches,\n        isSyncSSR,\n        observable,\n        resultData,\n        partialRefetch,\n        client,\n    ]), function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    }, function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    });\n}\nfunction useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {\n    if (renderPromises && ssrAllowed) {\n        renderPromises.registerSSRObservable(observable);\n        if (observable.getCurrentResult().loading) {\n            // TODO: This is a legacy API which could probably be cleaned up\n            renderPromises.addObservableQueryPromise(observable);\n        }\n    }\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(\n/** this hook will mutate properties on `resultData` */\nresultData, \n/** this hook will mutate properties on `observable` */\nobservable, client, options, watchQueryOptions) {\n    var _a;\n    if (observable[lastWatchOptions] &&\n        !(0,_wry_equality__WEBPACK_IMPORTED_MODULE_2__.equal)(observable[lastWatchOptions], watchQueryOptions)) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        resultData.previousData =\n            ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;\n        resultData.current = void 0;\n    }\n    observable[lastWatchOptions] = watchQueryOptions;\n}\n/*\n * A function to massage options before passing them to ObservableQuery.\n * This is two-step curried because we want to reuse the `make` function,\n * but the `observable` might differ between calls to `make`.\n */\nfunction createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {\n    if (_a === void 0) { _a = {}; }\n    var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, \n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    otherOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    return function (observable) {\n        // This Object.assign is safe because otherOptions is a fresh ...rest object\n        // that did not exist until just now, so modifications are still allowed.\n        var watchQueryOptions = Object.assign(otherOptions, { query: query });\n        if (isSyncSSR &&\n            (watchQueryOptions.fetchPolicy === \"network-only\" ||\n                watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n            // this behavior was added to react-apollo without explanation in this PR\n            // https://github.com/apollographql/react-apollo/pull/1579\n            watchQueryOptions.fetchPolicy = \"cache-first\";\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            // When skipping, we set watchQueryOptions.fetchPolicy initially to\n            // \"standby\", but we also need/want to preserve the initial non-standby\n            // fetchPolicy that would have been used if not skipping.\n            watchQueryOptions.initialFetchPolicy =\n                watchQueryOptions.initialFetchPolicy ||\n                    watchQueryOptions.fetchPolicy ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n            watchQueryOptions.fetchPolicy = \"standby\";\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n        }\n        return watchQueryOptions;\n    };\n}\nfunction getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {\n    var toMerge = [];\n    var globalDefaults = client.defaultOptions.watchQuery;\n    if (globalDefaults)\n        toMerge.push(globalDefaults);\n    if (queryHookOptions.defaultOptions) {\n        toMerge.push(queryHookOptions.defaultOptions);\n    }\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push((0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_11__.compact)(observable && observable.options, watchQueryOptions));\n    return toMerge.reduce(_utilities_index_js__WEBPACK_IMPORTED_MODULE_12__.mergeOptions);\n}\nfunction setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {\n    var previousResult = resultData.current;\n    if (previousResult && previousResult.data) {\n        resultData.previousData = previousResult.data;\n    }\n    if (!nextResult.error && (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.isNonEmptyArray)(nextResult.errors)) {\n        // Until a set naming convention for networkError and graphQLErrors is\n        // decided upon, we map errors (graphQLErrors) to the error options.\n        // TODO: Is it possible for both result.error and result.errors to be\n        // defined here?\n        nextResult.error = new _errors_index_js__WEBPACK_IMPORTED_MODULE_14__.ApolloError({ graphQLErrors: nextResult.errors });\n    }\n    resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    forceUpdate();\n    handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);\n}\nfunction handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {\n    if (!result.loading) {\n        var error_1 = toApolloError(result);\n        // wait a tick in case we are in the middle of rendering a component\n        Promise.resolve()\n            .then(function () {\n            if (error_1) {\n                callbacks.onError(error_1);\n            }\n            else if (result.data &&\n                previousNetworkStatus !== result.networkStatus &&\n                result.networkStatus === _core_index_js__WEBPACK_IMPORTED_MODULE_10__.NetworkStatus.ready) {\n                callbacks.onCompleted(result.data);\n            }\n        })\n            .catch(function (error) {\n            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(error);\n        });\n    }\n}\nfunction getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!resultData.current) {\n        // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n        // this could call unsafeHandlePartialRefetch\n        setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function () { }, callbacks);\n    }\n    return resultData.current;\n}\nfunction getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {\n    var _a;\n    return ((queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) ||\n        ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n        \"cache-first\");\n}\nfunction toApolloError(result) {\n    return (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_13__.isNonEmptyArray)(result.errors) ?\n        new _errors_index_js__WEBPACK_IMPORTED_MODULE_14__.ApolloError({ graphQLErrors: result.errors })\n        : result.error;\n}\nfunction toQueryResult(result, previousData, observable, client) {\n    var data = result.data, partial = result.partial, resultWithoutPartial = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(result, [\"data\", \"partial\"]);\n    var queryResult = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({ data: data }, resultWithoutPartial), { client: client, observable: observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData: previousData });\n    return queryResult;\n}\nfunction unsafeHandlePartialRefetch(result, observable, partialRefetch) {\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (result.partial &&\n        partialRefetch &&\n        !result.loading &&\n        (!result.data || Object.keys(result.data).length === 0) &&\n        observable.options.fetchPolicy !== \"cache-only\") {\n        observable.refetch();\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__assign)({}, result), { loading: true, networkStatus: _core_index_js__WEBPACK_IMPORTED_MODULE_10__.NetworkStatus.refetch });\n    }\n    return result;\n}\nvar ssrDisabledResult = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_15__.maybeDeepFreeze)({\n    loading: true,\n    data: void 0,\n    error: void 0,\n    networkStatus: _core_index_js__WEBPACK_IMPORTED_MODULE_10__.NetworkStatus.loading,\n});\nvar skipStandbyResult = (0,_utilities_index_js__WEBPACK_IMPORTED_MODULE_15__.maybeDeepFreeze)({\n    loading: false,\n    data: void 0,\n    error: void 0,\n    networkStatus: _core_index_js__WEBPACK_IMPORTED_MODULE_10__.NetworkStatus.ready,\n});\nfunction bindObservableMethods(observable) {\n    return {\n        refetch: observable.refetch.bind(observable),\n        reobserve: observable.reobserve.bind(observable),\n        fetchMore: observable.fetchMore.bind(observable),\n        updateQuery: observable.updateQuery.bind(observable),\n        startPolling: observable.startPolling.bind(observable),\n        stopPolling: observable.stopPolling.bind(observable),\n        subscribeToMore: observable.subscribeToMore.bind(observable),\n    };\n}\n//# sourceMappingURL=useQuery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9ob29rcy91c2VRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUM1QjtBQUNnQztBQUMzQjtBQUNrQjtBQUNEO0FBQ0g7QUFDaUI7QUFDQztBQUNmO0FBQytCO0FBQ3ZDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLG9CQUFvQixxQkFBcUI7QUFDekMsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCLFdBQVcsNERBQVE7QUFDbkI7QUFDQSxlQUFlLG9FQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQWEsZUFBZSxRQUFRLCtDQUFRLENBQUMsK0NBQVEsR0FBRyw4QkFBOEI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFrQixRQUFRLDBEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBZTtBQUMvQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZDQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBUSxDQUFDLCtDQUFRLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixvRUFBZTtBQUNoQyx5QkFBeUIsK0NBQWdCLENBQUMsbUVBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUFhLGVBQWUsMkNBQTJDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJDQUFZO0FBQ2xDLElBQUksOENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUFhO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyw4RUFBb0IsQ0FBQyxnREFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBEQUFhO0FBQ2hELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRDQUE0QztBQUNqRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQU87QUFDeEIsMEJBQTBCLDhEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxRUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwREFBVyxHQUFHLGtDQUFrQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQWE7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QyxrRUFBUztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdIO0FBQ2hIO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxRUFBZTtBQUMxQixZQUFZLDBEQUFXLEdBQUcsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDTztBQUNQLDZFQUE2RSw2Q0FBTTtBQUNuRixzQkFBc0IsK0NBQVEsQ0FBQywrQ0FBUSxHQUFHLFlBQVksMkJBQTJCLDJLQUEySztBQUM1UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxhQUFhLDhCQUE4QiwwREFBYSxVQUFVO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQWE7QUFDaEMsQ0FBQztBQUNELHdCQUF3QixxRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQWE7QUFDaEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXHJlYWN0XFxob29rc1xcdXNlUXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiBGdW5jdGlvbiBwYXJhbWV0ZXJzIGluIHRoaXMgZmlsZSB0cnkgdG8gZm9sbG93IGEgY29tbW9uIG9yZGVyIGZvciB0aGUgc2FrZSBvZlxuICogcmVhZGFiaWxpdHkgYW5kIGNvbnNpc3RlbmN5LiBUaGUgb3JkZXIgaXMgYXMgZm9sbG93czpcbiAqXG4gKiByZXN1bHREYXRhXG4gKiBvYnNlcnZhYmxlXG4gKiBjbGllbnRcbiAqIHF1ZXJ5XG4gKiBvcHRpb25zXG4gKiB3YXRjaFF1ZXJ5T3B0aW9uc1xuICogbWFrZVdhdGNoUXVlcnlPcHRpb25zXG4gKiBpc1NTUkFsbG93ZWRcbiAqIGRpc2FibGVOZXR3b3JrRmV0Y2hlc1xuICogcGFydGlhbFJlZmV0Y2hcbiAqIHJlbmRlclByb21pc2VzXG4gKiBpc1N5bmNTU1JcbiAqIGNhbGxiYWNrc1xuICovXG4vKiogKi9cbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlaGFja3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSBcIi4vdXNlU3luY0V4dGVybmFsU3RvcmUuanNcIjtcbmltcG9ydCB7IGVxdWFsIH0gZnJvbSBcIkB3cnkvZXF1YWxpdHlcIjtcbmltcG9ydCB7IG1lcmdlT3B0aW9ucyB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFwb2xsb0NvbnRleHQgfSBmcm9tIFwiLi4vY29udGV4dC9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQXBvbGxvRXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3JzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlUXVlcnksIE5ldHdvcmtTdGF0dXMgfSBmcm9tIFwiLi4vLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgRG9jdW1lbnRUeXBlLCB2ZXJpZnlEb2N1bWVudFR5cGUgfSBmcm9tIFwiLi4vcGFyc2VyL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1c2VBcG9sbG9DbGllbnQgfSBmcm9tIFwiLi91c2VBcG9sbG9DbGllbnQuanNcIjtcbmltcG9ydCB7IGNvbXBhY3QsIGlzTm9uRW1wdHlBcnJheSwgbWF5YmVEZWVwRnJlZXplLCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IHdyYXBIb29rIH0gZnJvbSBcIi4vaW50ZXJuYWwvaW5kZXguanNcIjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG52YXIgbGFzdFdhdGNoT3B0aW9ucyA9IFN5bWJvbCgpO1xuLyoqXG4gKiBBIGhvb2sgZm9yIGV4ZWN1dGluZyBxdWVyaWVzIGluIGFuIEFwb2xsbyBhcHBsaWNhdGlvbi5cbiAqXG4gKiBUbyBydW4gYSBxdWVyeSB3aXRoaW4gYSBSZWFjdCBjb21wb25lbnQsIGNhbGwgYHVzZVF1ZXJ5YCBhbmQgcGFzcyBpdCBhIEdyYXBoUUwgcXVlcnkgZG9jdW1lbnQuXG4gKlxuICogV2hlbiB5b3VyIGNvbXBvbmVudCByZW5kZXJzLCBgdXNlUXVlcnlgIHJldHVybnMgYW4gb2JqZWN0IGZyb20gQXBvbGxvIENsaWVudCB0aGF0IGNvbnRhaW5zIGBsb2FkaW5nYCwgYGVycm9yYCwgYW5kIGBkYXRhYCBwcm9wZXJ0aWVzIHlvdSBjYW4gdXNlIHRvIHJlbmRlciB5b3VyIFVJLlxuICpcbiAqID4gUmVmZXIgdG8gdGhlIFtRdWVyaWVzXShodHRwczovL3d3dy5hcG9sbG9ncmFwaHFsLmNvbS9kb2NzL3JlYWN0L2RhdGEvcXVlcmllcykgc2VjdGlvbiBmb3IgYSBtb3JlIGluLWRlcHRoIG92ZXJ2aWV3IG9mIGB1c2VRdWVyeWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgZ3FsLCB1c2VRdWVyeSB9IGZyb20gJ0BhcG9sbG8vY2xpZW50JztcbiAqXG4gKiBjb25zdCBHRVRfR1JFRVRJTkcgPSBncWxgXG4gKiAgIHF1ZXJ5IEdldEdyZWV0aW5nKCRsYW5ndWFnZTogU3RyaW5nISkge1xuICogICAgIGdyZWV0aW5nKGxhbmd1YWdlOiAkbGFuZ3VhZ2UpIHtcbiAqICAgICAgIG1lc3NhZ2VcbiAqICAgICB9XG4gKiAgIH1cbiAqIGA7XG4gKlxuICogZnVuY3Rpb24gSGVsbG8oKSB7XG4gKiAgIGNvbnN0IHsgbG9hZGluZywgZXJyb3IsIGRhdGEgfSA9IHVzZVF1ZXJ5KEdFVF9HUkVFVElORywge1xuICogICAgIHZhcmlhYmxlczogeyBsYW5ndWFnZTogJ2VuZ2xpc2gnIH0sXG4gKiAgIH0pO1xuICogICBpZiAobG9hZGluZykgcmV0dXJuIDxwPkxvYWRpbmcgLi4uPC9wPjtcbiAqICAgcmV0dXJuIDxoMT5IZWxsbyB7ZGF0YS5ncmVldGluZy5tZXNzYWdlfSE8L2gxPjtcbiAqIH1cbiAqIGBgYFxuICogQHNpbmNlIDMuMC4wXG4gKiBAcGFyYW0gcXVlcnkgLSBBIEdyYXBoUUwgcXVlcnkgZG9jdW1lbnQgcGFyc2VkIGludG8gYW4gQVNUIGJ5IGBncWxgLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbnRyb2wgaG93IHRoZSBxdWVyeSBpcyBleGVjdXRlZC5cbiAqIEByZXR1cm5zIFF1ZXJ5IHJlc3VsdCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiB3cmFwSG9vayhcInVzZVF1ZXJ5XCIsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1jb21waWxlci9yZWFjdC1jb21waWxlclxuICAgIHVzZVF1ZXJ5XywgdXNlQXBvbGxvQ2xpZW50KG9wdGlvbnMgJiYgb3B0aW9ucy5jbGllbnQpKShxdWVyeSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VRdWVyeV8ocXVlcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EgPSB1c2VRdWVyeUludGVybmFscyhxdWVyeSwgb3B0aW9ucyksIHJlc3VsdCA9IF9hLnJlc3VsdCwgb2JzUXVlcnlGaWVsZHMgPSBfYS5vYnNRdWVyeUZpZWxkcztcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdCksIG9ic1F1ZXJ5RmllbGRzKSk7IH0sIFtyZXN1bHQsIG9ic1F1ZXJ5RmllbGRzXSk7XG59XG5mdW5jdGlvbiB1c2VJbnRlcm5hbFN0YXRlKGNsaWVudCwgcXVlcnksIG9wdGlvbnMsIHJlbmRlclByb21pc2VzLCBtYWtlV2F0Y2hRdWVyeU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbFN0YXRlKHByZXZpb3VzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmVyaWZ5RG9jdW1lbnRUeXBlKHF1ZXJ5LCBEb2N1bWVudFR5cGUuUXVlcnkpO1xuICAgICAgICB2YXIgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgb2JzZXJ2YWJsZTogXG4gICAgICAgICAgICAvLyBTZWUgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgb2JzZXJ2YWJsZSB0aGF0IHdhcyB1c2VkIHRvIGZldGNoIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBkYXRhIGFuZCBpZiBzbywgdXNlIGl0IGluc3RlYWQgc2luY2UgaXQgd2lsbCBjb250YWluIHRoZSBwcm9wZXIgcXVlcnlJZFxuICAgICAgICAgICAgLy8gdG8gZmV0Y2ggdGhlIHJlc3VsdCBzZXQuIFRoaXMgaXMgdXNlZCBkdXJpbmcgU1NSLlxuICAgICAgICAgICAgKHJlbmRlclByb21pc2VzICYmXG4gICAgICAgICAgICAgICAgcmVuZGVyUHJvbWlzZXMuZ2V0U1NST2JzZXJ2YWJsZShtYWtlV2F0Y2hRdWVyeU9wdGlvbnMoKSkpIHx8XG4gICAgICAgICAgICAgICAgT2JzZXJ2YWJsZVF1ZXJ5W1wiaW5hY3RpdmVPbkNyZWF0aW9uXCJdLndpdGhWYWx1ZSghcmVuZGVyUHJvbWlzZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC53YXRjaFF1ZXJ5KGdldE9ic1F1ZXJ5T3B0aW9ucyh2b2lkIDAsIGNsaWVudCwgb3B0aW9ucywgbWFrZVdhdGNoUXVlcnlPcHRpb25zKCkpKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlc3VsdERhdGE6IHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBwcmV2aW91c0RhdGEgZnJvbSBwcmV2aW91cyBJbnRlcm5hbFN0YXRlIChpZiBhbnkpIHRvIHByb3ZpZGVcbiAgICAgICAgICAgICAgICAvLyBjb250aW51aXR5IG9mIHByZXZpb3VzRGF0YSBldmVuIGlmL3doZW4gdGhlIHF1ZXJ5IG9yIGNsaWVudCBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIHByZXZpb3VzRGF0YTogKF9hID0gcHJldmlvdXMgPT09IG51bGwgfHwgcHJldmlvdXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZpb3VzLnJlc3VsdERhdGEuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxTdGF0ZTtcbiAgICB9XG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoY3JlYXRlSW50ZXJuYWxTdGF0ZSksIGludGVybmFsU3RhdGUgPSBfYVswXSwgdXBkYXRlSW50ZXJuYWxTdGF0ZSA9IF9hWzFdO1xuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVzZUxhenlRdWVyeWAgd2hlbiBhIG5ldyBxdWVyeSBpcyBleGVjdXRlZC5cbiAgICAgKiBXZSBrZWVwIHRoaXMgbG9naWMgaGVyZSBzaW5jZSBpdCBuZWVkcyB0byB1cGRhdGUgdGhpbmdzIGluIHVuc2FmZVxuICAgICAqIHdheXMgYW5kIGhlcmUgd2UgYXQgbGVhc3QgY2FuIGtlZXAgdHJhY2sgb2YgdGhhdCBpbiBhIHNpbmdsZSBwbGFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblF1ZXJ5RXhlY3V0ZWQod2F0Y2hRdWVyeU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgc2V0IHRvIHByZXZlbnQgYW4gaW1tZWRpYXRlIGByZXN1YnNjcmliZWAgaW4gdGhlXG4gICAgICAgIC8vIG5leHQgcmVyZW5kZXIgb2YgdGhlIGB1c2VRdWVyeWAgaW50ZXJuYWxzXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW50ZXJuYWxTdGF0ZS5vYnNlcnZhYmxlLCAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW2xhc3RXYXRjaE9wdGlvbnNdID0gd2F0Y2hRdWVyeU9wdGlvbnMsXG4gICAgICAgICAgICBfYSkpO1xuICAgICAgICB2YXIgcmVzdWx0RGF0YSA9IGludGVybmFsU3RhdGUucmVzdWx0RGF0YTtcbiAgICAgICAgdXBkYXRlSW50ZXJuYWxTdGF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW50ZXJuYWxTdGF0ZSksIHsgXG4gICAgICAgICAgICAvLyBtaWdodCBiZSBhIGRpZmZlcmVudCBxdWVyeVxuICAgICAgICAgICAgcXVlcnk6IHdhdGNoUXVlcnlPcHRpb25zLnF1ZXJ5LCByZXN1bHREYXRhOiBPYmplY3QuYXNzaWduKHJlc3VsdERhdGEsIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1vZGlmeSB0aGUgcHJldmlvdXMgYHJlc3VsdERhdGFgIG9iamVjdCBhcyB3ZSByZWx5IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIG9iamVjdCByZWZlcmVuY2UgaW4gb3RoZXIgcGxhY2VzXG4gICAgICAgICAgICAgICAgcHJldmlvdXNEYXRhOiAoKF9iID0gcmVzdWx0RGF0YS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0YSkgfHwgcmVzdWx0RGF0YS5wcmV2aW91c0RhdGEsXG4gICAgICAgICAgICAgICAgY3VycmVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSkgfSkpO1xuICAgIH1cbiAgICBpZiAoY2xpZW50ICE9PSBpbnRlcm5hbFN0YXRlLmNsaWVudCB8fCBxdWVyeSAhPT0gaW50ZXJuYWxTdGF0ZS5xdWVyeSkge1xuICAgICAgICAvLyBJZiB0aGUgY2xpZW50IG9yIHF1ZXJ5IGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgSW50ZXJuYWxTdGF0ZS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSByZS1yZW5kZXIgd2l0aCB0aGUgbmV3IHN0YXRlLCBidXQgaXQgd2lsbCBhbHNvIGNvbnRpbnVlXG4gICAgICAgIC8vIHRvIHJ1biB0aGUgY3VycmVudCByZW5kZXIgZnVuY3Rpb24gdG8gY29tcGxldGlvbi5cbiAgICAgICAgLy8gU2luY2Ugd2Ugc29tZXRpbWVzIHRyaWdnZXIgc29tZSBzaWRlLWVmZmVjdHMgaW4gdGhlIHJlbmRlciBmdW5jdGlvbiwgd2VcbiAgICAgICAgLy8gcmUtYXNzaWduIGBzdGF0ZWAgdG8gdGhlIG5ldyBzdGF0ZSB0byBlbnN1cmUgdGhhdCB0aG9zZSBzaWRlLWVmZmVjdHMgYXJlXG4gICAgICAgIC8vIHRyaWdnZXJlZCB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgICAgIHZhciBuZXdJbnRlcm5hbFN0YXRlID0gY3JlYXRlSW50ZXJuYWxTdGF0ZShpbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgdXBkYXRlSW50ZXJuYWxTdGF0ZShuZXdJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIFtuZXdJbnRlcm5hbFN0YXRlLCBvblF1ZXJ5RXhlY3V0ZWRdO1xuICAgIH1cbiAgICByZXR1cm4gW2ludGVybmFsU3RhdGUsIG9uUXVlcnlFeGVjdXRlZF07XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlUXVlcnlJbnRlcm5hbHMocXVlcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xpZW50ID0gdXNlQXBvbGxvQ2xpZW50KG9wdGlvbnMuY2xpZW50KTtcbiAgICB2YXIgcmVuZGVyUHJvbWlzZXMgPSBSZWFjdC51c2VDb250ZXh0KGdldEFwb2xsb0NvbnRleHQoKSkucmVuZGVyUHJvbWlzZXM7XG4gICAgdmFyIGlzU3luY1NTUiA9ICEhcmVuZGVyUHJvbWlzZXM7XG4gICAgdmFyIGRpc2FibGVOZXR3b3JrRmV0Y2hlcyA9IGNsaWVudC5kaXNhYmxlTmV0d29ya0ZldGNoZXM7XG4gICAgdmFyIHNzckFsbG93ZWQgPSBvcHRpb25zLnNzciAhPT0gZmFsc2UgJiYgIW9wdGlvbnMuc2tpcDtcbiAgICB2YXIgcGFydGlhbFJlZmV0Y2ggPSBvcHRpb25zLnBhcnRpYWxSZWZldGNoO1xuICAgIHZhciBtYWtlV2F0Y2hRdWVyeU9wdGlvbnMgPSBjcmVhdGVNYWtlV2F0Y2hRdWVyeU9wdGlvbnMoY2xpZW50LCBxdWVyeSwgb3B0aW9ucywgaXNTeW5jU1NSKTtcbiAgICB2YXIgX2EgPSB1c2VJbnRlcm5hbFN0YXRlKGNsaWVudCwgcXVlcnksIG9wdGlvbnMsIHJlbmRlclByb21pc2VzLCBtYWtlV2F0Y2hRdWVyeU9wdGlvbnMpLCBfYiA9IF9hWzBdLCBvYnNlcnZhYmxlID0gX2Iub2JzZXJ2YWJsZSwgcmVzdWx0RGF0YSA9IF9iLnJlc3VsdERhdGEsIG9uUXVlcnlFeGVjdXRlZCA9IF9hWzFdO1xuICAgIHZhciB3YXRjaFF1ZXJ5T3B0aW9ucyA9IG1ha2VXYXRjaFF1ZXJ5T3B0aW9ucyhvYnNlcnZhYmxlKTtcbiAgICB1c2VSZXN1YnNjcmliZUlmTmVjZXNzYXJ5KHJlc3VsdERhdGEsIC8vIG1pZ2h0IGdldCBtdXRhdGVkIGR1cmluZyByZW5kZXJcbiAgICBvYnNlcnZhYmxlLCAvLyBtaWdodCBnZXQgbXV0YXRlZCBkdXJpbmcgcmVuZGVyXG4gICAgY2xpZW50LCBvcHRpb25zLCB3YXRjaFF1ZXJ5T3B0aW9ucyk7XG4gICAgdmFyIG9ic1F1ZXJ5RmllbGRzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBiaW5kT2JzZXJ2YWJsZU1ldGhvZHMob2JzZXJ2YWJsZSk7IH0sIFtvYnNlcnZhYmxlXSk7XG4gICAgdXNlUmVnaXN0ZXJTU1JPYnNlcnZhYmxlKG9ic2VydmFibGUsIHJlbmRlclByb21pc2VzLCBzc3JBbGxvd2VkKTtcbiAgICB2YXIgcmVzdWx0ID0gdXNlT2JzZXJ2YWJsZVN1YnNjcmlwdGlvblJlc3VsdChyZXN1bHREYXRhLCBvYnNlcnZhYmxlLCBjbGllbnQsIG9wdGlvbnMsIHdhdGNoUXVlcnlPcHRpb25zLCBkaXNhYmxlTmV0d29ya0ZldGNoZXMsIHBhcnRpYWxSZWZldGNoLCBpc1N5bmNTU1IsIHtcbiAgICAgICAgb25Db21wbGV0ZWQ6IG9wdGlvbnMub25Db21wbGV0ZWQgfHwgbm9vcCxcbiAgICAgICAgb25FcnJvcjogb3B0aW9ucy5vbkVycm9yIHx8IG5vb3AsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgIG9ic1F1ZXJ5RmllbGRzOiBvYnNRdWVyeUZpZWxkcyxcbiAgICAgICAgb2JzZXJ2YWJsZTogb2JzZXJ2YWJsZSxcbiAgICAgICAgcmVzdWx0RGF0YTogcmVzdWx0RGF0YSxcbiAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgIG9uUXVlcnlFeGVjdXRlZDogb25RdWVyeUV4ZWN1dGVkLFxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VPYnNlcnZhYmxlU3Vic2NyaXB0aW9uUmVzdWx0KHJlc3VsdERhdGEsIG9ic2VydmFibGUsIGNsaWVudCwgb3B0aW9ucywgd2F0Y2hRdWVyeU9wdGlvbnMsIGRpc2FibGVOZXR3b3JrRmV0Y2hlcywgcGFydGlhbFJlZmV0Y2gsIGlzU3luY1NTUiwgY2FsbGJhY2tzKSB7XG4gICAgdmFyIGNhbGxiYWNrUmVmID0gUmVhY3QudXNlUmVmKGNhbGxiYWNrcyk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHN0YXRlLm9uQ29tcGxldGVkIGFuZCBzdGF0ZS5vbkVycm9yIGFsd2F5cyByZWZsZWN0IHRoZSBsYXRlc3RcbiAgICAgICAgLy8gb3B0aW9ucy5vbkNvbXBsZXRlZCBhbmQgb3B0aW9ucy5vbkVycm9yIGNhbGxiYWNrcyBwcm92aWRlZCB0byB1c2VRdWVyeSxcbiAgICAgICAgLy8gc2luY2UgdGhvc2UgZnVuY3Rpb25zIGFyZSBvZnRlbiByZWNyZWF0ZWQgZXZlcnkgdGltZSB1c2VRdWVyeSBpcyBjYWxsZWQuXG4gICAgICAgIC8vIExpa2UgdGhlIGZvcmNlVXBkYXRlIG1ldGhvZCwgdGhlIHZlcnNpb25zIG9mIHRoZXNlIG1ldGhvZHMgaW5oZXJpdGVkIGZyb21cbiAgICAgICAgLy8gSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUgYXJlIGVtcHR5IG5vLW9wcywgYnV0IHdlIGNhbiBvdmVycmlkZSB0aGVtIG9uIHRoZVxuICAgICAgICAvLyBiYXNlIHN0YXRlIG9iamVjdCAod2l0aG91dCBtb2RpZnlpbmcgdGhlIHByb3RvdHlwZSkuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1jb21waWxlci9yZWFjdC1jb21waWxlclxuICAgICAgICBjYWxsYmFja1JlZi5jdXJyZW50ID0gY2FsbGJhY2tzO1xuICAgIH0pO1xuICAgIHZhciByZXN1bHRPdmVycmlkZSA9ICgoaXNTeW5jU1NSIHx8IGRpc2FibGVOZXR3b3JrRmV0Y2hlcykgJiZcbiAgICAgICAgb3B0aW9ucy5zc3IgPT09IGZhbHNlICYmXG4gICAgICAgICFvcHRpb25zLnNraXApID9cbiAgICAgICAgLy8gSWYgU1NSIGhhcyBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQsIGFuZCB0aGlzIGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZFxuICAgICAgICAvLyBvbiB0aGUgc2VydmVyIHNpZGUsIHJldHVybiB0aGUgZGVmYXVsdCBsb2FkaW5nIHN0YXRlLlxuICAgICAgICBzc3JEaXNhYmxlZFJlc3VsdFxuICAgICAgICA6IG9wdGlvbnMuc2tpcCB8fCB3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gXCJzdGFuZGJ5XCIgP1xuICAgICAgICAgICAgLy8gV2hlbiBza2lwcGluZyBhIHF1ZXJ5IChpZS4gd2UncmUgbm90IHF1ZXJ5aW5nIGZvciBkYXRhIGJ1dCBzdGlsbCB3YW50IHRvXG4gICAgICAgICAgICAvLyByZW5kZXIgY2hpbGRyZW4pLCBtYWtlIHN1cmUgdGhlIGBkYXRhYCBpcyBjbGVhcmVkIG91dCBhbmQgYGxvYWRpbmdgIGlzXG4gICAgICAgICAgICAvLyBzZXQgdG8gYGZhbHNlYCAoc2luY2Ugd2UgYXJlbid0IGxvYWRpbmcgYW55dGhpbmcpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE5PVEU6IFdlIG5vIGxvbmdlciB0aGluayB0aGlzIGlzIHRoZSBjb3JyZWN0IGJlaGF2aW9yLiBTa2lwcGluZyBzaG91bGRcbiAgICAgICAgICAgIC8vIG5vdCBhdXRvbWF0aWNhbGx5IHNldCBgZGF0YWAgdG8gYHVuZGVmaW5lZGAsIGJ1dCBpbnN0ZWFkIGxlYXZlIHRoZVxuICAgICAgICAgICAgLy8gcHJldmlvdXMgZGF0YSBpbiBwbGFjZS4gSW4gb3RoZXIgd29yZHMsIHNraXBwaW5nIHNob3VsZCBub3QgbWFuZGF0ZSB0aGF0XG4gICAgICAgICAgICAvLyBwcmV2aW91c2x5IHJlY2VpdmVkIGRhdGEgaXMgYWxsIG9mIGEgc3VkZGVuIHJlbW92ZWQuIFVuZm9ydHVuYXRlbHksXG4gICAgICAgICAgICAvLyBjaGFuZ2luZyB0aGlzIGlzIGJyZWFraW5nLCBzbyB3ZSdsbCBoYXZlIHRvIHdhaXQgdW50aWwgQXBvbGxvIENsaWVudCA0LjBcbiAgICAgICAgICAgIC8vIHRvIGFkZHJlc3MgdGhpcy5cbiAgICAgICAgICAgIHNraXBTdGFuZGJ5UmVzdWx0XG4gICAgICAgICAgICA6IHZvaWQgMDtcbiAgICB2YXIgcHJldmlvdXNEYXRhID0gcmVzdWx0RGF0YS5wcmV2aW91c0RhdGE7XG4gICAgdmFyIGN1cnJlbnRSZXN1bHRPdmVycmlkZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0T3ZlcnJpZGUgJiZcbiAgICAgICAgICAgIHRvUXVlcnlSZXN1bHQocmVzdWx0T3ZlcnJpZGUsIHByZXZpb3VzRGF0YSwgb2JzZXJ2YWJsZSwgY2xpZW50KTtcbiAgICB9LCBbY2xpZW50LCBvYnNlcnZhYmxlLCByZXN1bHRPdmVycmlkZSwgcHJldmlvdXNEYXRhXSk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChoYW5kbGVTdG9yZUNoYW5nZSkge1xuICAgICAgICAvLyByZWZlcmVuY2UgYGRpc2FibGVOZXR3b3JrRmV0Y2hlc2AgaGVyZSB0byBlbnN1cmUgdGhhdCB0aGUgcnVsZXMgb2YgaG9va3NcbiAgICAgICAgLy8ga2VlcCBpdCBhcyBhIGRlcGVuZGVuY3kgb2YgdGhpcyBlZmZlY3QsIGV2ZW4gdGhvdWdoIGl0J3Mgbm90IHVzZWRcbiAgICAgICAgZGlzYWJsZU5ldHdvcmtGZXRjaGVzO1xuICAgICAgICBpZiAoaXNTeW5jU1NSKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbk5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSZXN1bHQgPSByZXN1bHREYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBXZSB1c2UgYGdldEN1cnJlbnRSZXN1bHQoKWAgaW5zdGVhZCBvZiB0aGUgb25OZXh0IGFyZ3VtZW50IGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgZGlmZmVyIHNsaWdodGx5LiBTcGVjaWZpY2FsbHksIGxvYWRpbmcgcmVzdWx0cyB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIGFuIGVtcHR5IG9iamVjdCBmb3IgZGF0YSBpbnN0ZWFkIG9mIGB1bmRlZmluZWRgIGZvciBzb21lIHJlYXNvbi5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYnNlcnZhYmxlLmdldEN1cnJlbnRSZXN1bHQoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgYXR0ZW1wdGluZyB0byByZS1yZW5kZXIgc2ltaWxhciByZXN1bHRzXG4gICAgICAgICAgICBpZiAocHJldmlvdXNSZXN1bHQgJiZcbiAgICAgICAgICAgICAgICBwcmV2aW91c1Jlc3VsdC5sb2FkaW5nID09PSByZXN1bHQubG9hZGluZyAmJlxuICAgICAgICAgICAgICAgIHByZXZpb3VzUmVzdWx0Lm5ldHdvcmtTdGF0dXMgPT09IHJlc3VsdC5uZXR3b3JrU3RhdHVzICYmXG4gICAgICAgICAgICAgICAgZXF1YWwocHJldmlvdXNSZXN1bHQuZGF0YSwgcmVzdWx0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UmVzdWx0KHJlc3VsdCwgcmVzdWx0RGF0YSwgb2JzZXJ2YWJsZSwgY2xpZW50LCBwYXJ0aWFsUmVmZXRjaCwgaGFuZGxlU3RvcmVDaGFuZ2UsIGNhbGxiYWNrUmVmLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmN1cnJlbnQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jdXJyZW50ID0gb2JzZXJ2YWJsZS5yZXN1YnNjcmliZUFmdGVyRXJyb3Iob25OZXh0LCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChlcnJvciwgXCJncmFwaFFMRXJyb3JzXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGlzIG5vdCBhIEdyYXBoUUwgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2aW91c1Jlc3VsdCA9IHJlc3VsdERhdGEuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghcHJldmlvdXNSZXN1bHQgfHxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNSZXN1bHQgJiYgcHJldmlvdXNSZXN1bHQubG9hZGluZykgfHxcbiAgICAgICAgICAgICAgICAhZXF1YWwoZXJyb3IsIHByZXZpb3VzUmVzdWx0LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIHNldFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IChwcmV2aW91c1Jlc3VsdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSZXN1bHQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IE5ldHdvcmtTdGF0dXMuZXJyb3IsXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0RGF0YSwgb2JzZXJ2YWJsZSwgY2xpZW50LCBwYXJ0aWFsUmVmZXRjaCwgaGFuZGxlU3RvcmVDaGFuZ2UsIGNhbGxiYWNrUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPIGV2YWx1YXRlIGlmIHdlIGtlZXAgdGhpcyBpblxuICAgICAgICAvLyBSZWFjdCBDb21waWxlciBjYW5ub3QgaGFuZGxlIHNjb3BlZCBgbGV0YCBhY2Nlc3MsIGJ1dCBhIG11dGFibGUgb2JqZWN0XG4gICAgICAgIC8vIGxpa2UgdGhpcyBpcyBmaW5lLlxuICAgICAgICAvLyB3YXM6XG4gICAgICAgIC8vIGxldCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShvbk5leHQsIG9uRXJyb3IpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0geyBjdXJyZW50OiBvYnNlcnZhYmxlLnN1YnNjcmliZShvbk5leHQsIG9uRXJyb3IpIH07XG4gICAgICAgIC8vIERvIHRoZSBcInVuc3Vic2NyaWJlXCIgd2l0aCBhIHNob3J0IGRlbGF5LlxuICAgICAgICAvLyBUaGlzIHdheSwgYW4gZXhpc3Rpbmcgc3Vic2NyaXB0aW9uIGNhbiBiZSByZXVzZWQgd2l0aG91dCBhbiBhZGRpdGlvbmFsXG4gICAgICAgIC8vIHJlcXVlc3QgaWYgXCJ1bnN1YnNjcmliZVwiICBhbmQgXCJyZXN1YnNjcmliZVwiIHRvIHRoZSBzYW1lIE9ic2VydmFibGVRdWVyeVxuICAgICAgICAvLyBoYXBwZW4gaW4gdmVyeSBmYXN0IHN1Y2Nlc3Npb24uXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmlwdGlvbi5jdXJyZW50LnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgZGlzYWJsZU5ldHdvcmtGZXRjaGVzLFxuICAgICAgICBpc1N5bmNTU1IsXG4gICAgICAgIG9ic2VydmFibGUsXG4gICAgICAgIHJlc3VsdERhdGEsXG4gICAgICAgIHBhcnRpYWxSZWZldGNoLFxuICAgICAgICBjbGllbnQsXG4gICAgXSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRPdmVycmlkZSB8fFxuICAgICAgICAgICAgZ2V0Q3VycmVudFJlc3VsdChyZXN1bHREYXRhLCBvYnNlcnZhYmxlLCBjYWxsYmFja1JlZi5jdXJyZW50LCBwYXJ0aWFsUmVmZXRjaCwgY2xpZW50KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzdWx0T3ZlcnJpZGUgfHxcbiAgICAgICAgICAgIGdldEN1cnJlbnRSZXN1bHQocmVzdWx0RGF0YSwgb2JzZXJ2YWJsZSwgY2FsbGJhY2tSZWYuY3VycmVudCwgcGFydGlhbFJlZmV0Y2gsIGNsaWVudCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1c2VSZWdpc3RlclNTUk9ic2VydmFibGUob2JzZXJ2YWJsZSwgcmVuZGVyUHJvbWlzZXMsIHNzckFsbG93ZWQpIHtcbiAgICBpZiAocmVuZGVyUHJvbWlzZXMgJiYgc3NyQWxsb3dlZCkge1xuICAgICAgICByZW5kZXJQcm9taXNlcy5yZWdpc3RlclNTUk9ic2VydmFibGUob2JzZXJ2YWJsZSk7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlLmdldEN1cnJlbnRSZXN1bHQoKS5sb2FkaW5nKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGEgbGVnYWN5IEFQSSB3aGljaCBjb3VsZCBwcm9iYWJseSBiZSBjbGVhbmVkIHVwXG4gICAgICAgICAgICByZW5kZXJQcm9taXNlcy5hZGRPYnNlcnZhYmxlUXVlcnlQcm9taXNlKG9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gdGhpcyBob29rIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYW55IHJ1bGVzIG9mIFJlYWN0LCBhbmQgdGhlcmUncyBubyBnb29kIHdheSB0byByZXdyaXRlIGl0LlxuLy8gaXQgc2hvdWxkIHN0YXkgYSBzZXBhcmF0ZSBob29rIHRoYXQgd2lsbCBub3QgYmUgb3B0aW1pemVkIGJ5IHRoZSBjb21waWxlclxuZnVuY3Rpb24gdXNlUmVzdWJzY3JpYmVJZk5lY2Vzc2FyeShcbi8qKiB0aGlzIGhvb2sgd2lsbCBtdXRhdGUgcHJvcGVydGllcyBvbiBgcmVzdWx0RGF0YWAgKi9cbnJlc3VsdERhdGEsIFxuLyoqIHRoaXMgaG9vayB3aWxsIG11dGF0ZSBwcm9wZXJ0aWVzIG9uIGBvYnNlcnZhYmxlYCAqL1xub2JzZXJ2YWJsZSwgY2xpZW50LCBvcHRpb25zLCB3YXRjaFF1ZXJ5T3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAob2JzZXJ2YWJsZVtsYXN0V2F0Y2hPcHRpb25zXSAmJlxuICAgICAgICAhZXF1YWwob2JzZXJ2YWJsZVtsYXN0V2F0Y2hPcHRpb25zXSwgd2F0Y2hRdWVyeU9wdGlvbnMpKSB7XG4gICAgICAgIC8vIFRob3VnaCBpdCBtaWdodCBiZSB0ZW1wdGluZyB0byBwb3N0cG9uZSB0aGlzIHJlb2JzZXJ2ZSBjYWxsIHRvIHRoZVxuICAgICAgICAvLyB1c2VFZmZlY3QgYmxvY2ssIHdlIG5lZWQgZ2V0Q3VycmVudFJlc3VsdCB0byByZXR1cm4gYW4gYXBwcm9wcmlhdGVcbiAgICAgICAgLy8gbG9hZGluZzp0cnVlIHJlc3VsdCBzeW5jaHJvbm91c2x5IChsYXRlciB3aXRoaW4gdGhlIHNhbWUgY2FsbCB0b1xuICAgICAgICAvLyB1c2VRdWVyeSkuIFNpbmNlIHdlIGFscmVhZHkgaGF2ZSB0aGlzLm9ic2VydmFibGUgaGVyZSAobm90IHRydWUgZm9yXG4gICAgICAgIC8vIHRoZSB2ZXJ5IGZpcnN0IGNhbGwgdG8gdXNlUXVlcnkpLCB3ZSBhcmUgbm90IGluaXRpYXRpbmcgYW55IG5ld1xuICAgICAgICAvLyBzdWJzY3JpcHRpb25zLCB0aG91Z2ggaXQgZG9lcyBmZWVsIGxlc3MgdGhhbiBpZGVhbCB0aGF0IHJlb2JzZXJ2ZVxuICAgICAgICAvLyAocG90ZW50aWFsbHkpIGtpY2tzIG9mZiBhIG5ldHdvcmsgcmVxdWVzdCAoZm9yIGV4YW1wbGUsIHdoZW4gdGhlXG4gICAgICAgIC8vIHZhcmlhYmxlcyBoYXZlIGNoYW5nZWQpLCB3aGljaCBpcyB0ZWNobmljYWxseSBhIHNpZGUtZWZmZWN0LlxuICAgICAgICBvYnNlcnZhYmxlLnJlb2JzZXJ2ZShnZXRPYnNRdWVyeU9wdGlvbnMob2JzZXJ2YWJsZSwgY2xpZW50LCBvcHRpb25zLCB3YXRjaFF1ZXJ5T3B0aW9ucykpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgZ2V0Q3VycmVudFJlc3VsdCByZXR1cm5zIGEgZnJlc2ggQXBvbGxvUXVlcnlSZXN1bHQ8VERhdGE+LFxuICAgICAgICAvLyBidXQgc2F2ZSB0aGUgY3VycmVudCBkYXRhIGFzIHRoaXMucHJldmlvdXNEYXRhLCBqdXN0IGxpa2Ugc2V0UmVzdWx0XG4gICAgICAgIC8vIHVzdWFsbHkgZG9lcy5cbiAgICAgICAgcmVzdWx0RGF0YS5wcmV2aW91c0RhdGEgPVxuICAgICAgICAgICAgKChfYSA9IHJlc3VsdERhdGEuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpIHx8IHJlc3VsdERhdGEucHJldmlvdXNEYXRhO1xuICAgICAgICByZXN1bHREYXRhLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgfVxuICAgIG9ic2VydmFibGVbbGFzdFdhdGNoT3B0aW9uc10gPSB3YXRjaFF1ZXJ5T3B0aW9ucztcbn1cbi8qXG4gKiBBIGZ1bmN0aW9uIHRvIG1hc3NhZ2Ugb3B0aW9ucyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIE9ic2VydmFibGVRdWVyeS5cbiAqIFRoaXMgaXMgdHdvLXN0ZXAgY3VycmllZCBiZWNhdXNlIHdlIHdhbnQgdG8gcmV1c2UgdGhlIGBtYWtlYCBmdW5jdGlvbixcbiAqIGJ1dCB0aGUgYG9ic2VydmFibGVgIG1pZ2h0IGRpZmZlciBiZXR3ZWVuIGNhbGxzIHRvIGBtYWtlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1ha2VXYXRjaFF1ZXJ5T3B0aW9ucyhjbGllbnQsIHF1ZXJ5LCBfYSwgaXNTeW5jU1NSKSB7XG4gICAgaWYgKF9hID09PSB2b2lkIDApIHsgX2EgPSB7fTsgfVxuICAgIHZhciBza2lwID0gX2Euc2tpcCwgc3NyID0gX2Euc3NyLCBvbkNvbXBsZXRlZCA9IF9hLm9uQ29tcGxldGVkLCBvbkVycm9yID0gX2Eub25FcnJvciwgZGVmYXVsdE9wdGlvbnMgPSBfYS5kZWZhdWx0T3B0aW9ucywgXG4gICAgLy8gVGhlIGFib3ZlIG9wdGlvbnMgYXJlIHVzZVF1ZXJ5LXNwZWNpZmljLCBzbyB0aGlzIC4uLm90aGVyT3B0aW9ucyBzcHJlYWRcbiAgICAvLyBtYWtlcyBvdGhlck9wdGlvbnMgYWxtb3N0IGEgV2F0Y2hRdWVyeU9wdGlvbnMgb2JqZWN0LCBleGNlcHQgZm9yIHRoZVxuICAgIC8vIHF1ZXJ5IHByb3BlcnR5IHRoYXQgd2UgYWRkIGJlbG93LlxuICAgIG90aGVyT3B0aW9ucyA9IF9fcmVzdChfYSwgW1wic2tpcFwiLCBcInNzclwiLCBcIm9uQ29tcGxldGVkXCIsIFwib25FcnJvclwiLCBcImRlZmF1bHRPcHRpb25zXCJdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgLy8gVGhpcyBPYmplY3QuYXNzaWduIGlzIHNhZmUgYmVjYXVzZSBvdGhlck9wdGlvbnMgaXMgYSBmcmVzaCAuLi5yZXN0IG9iamVjdFxuICAgICAgICAvLyB0aGF0IGRpZCBub3QgZXhpc3QgdW50aWwganVzdCBub3csIHNvIG1vZGlmaWNhdGlvbnMgYXJlIHN0aWxsIGFsbG93ZWQuXG4gICAgICAgIHZhciB3YXRjaFF1ZXJ5T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3RoZXJPcHRpb25zLCB7IHF1ZXJ5OiBxdWVyeSB9KTtcbiAgICAgICAgaWYgKGlzU3luY1NTUiAmJlxuICAgICAgICAgICAgKHdhdGNoUXVlcnlPcHRpb25zLmZldGNoUG9saWN5ID09PSBcIm5ldHdvcmstb25seVwiIHx8XG4gICAgICAgICAgICAgICAgd2F0Y2hRdWVyeU9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09IFwiY2FjaGUtYW5kLW5ldHdvcmtcIikpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgYmVoYXZpb3Igd2FzIGFkZGVkIHRvIHJlYWN0LWFwb2xsbyB3aXRob3V0IGV4cGxhbmF0aW9uIGluIHRoaXMgUFJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcG9sbG9ncmFwaHFsL3JlYWN0LWFwb2xsby9wdWxsLzE1NzlcbiAgICAgICAgICAgIHdhdGNoUXVlcnlPcHRpb25zLmZldGNoUG9saWN5ID0gXCJjYWNoZS1maXJzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2F0Y2hRdWVyeU9wdGlvbnMudmFyaWFibGVzKSB7XG4gICAgICAgICAgICB3YXRjaFF1ZXJ5T3B0aW9ucy52YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgLy8gV2hlbiBza2lwcGluZywgd2Ugc2V0IHdhdGNoUXVlcnlPcHRpb25zLmZldGNoUG9saWN5IGluaXRpYWxseSB0b1xuICAgICAgICAgICAgLy8gXCJzdGFuZGJ5XCIsIGJ1dCB3ZSBhbHNvIG5lZWQvd2FudCB0byBwcmVzZXJ2ZSB0aGUgaW5pdGlhbCBub24tc3RhbmRieVxuICAgICAgICAgICAgLy8gZmV0Y2hQb2xpY3kgdGhhdCB3b3VsZCBoYXZlIGJlZW4gdXNlZCBpZiBub3Qgc2tpcHBpbmcuXG4gICAgICAgICAgICB3YXRjaFF1ZXJ5T3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kgPVxuICAgICAgICAgICAgICAgIHdhdGNoUXVlcnlPcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSB8fFxuICAgICAgICAgICAgICAgICAgICB3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSB8fFxuICAgICAgICAgICAgICAgICAgICBnZXREZWZhdWx0RmV0Y2hQb2xpY3koZGVmYXVsdE9wdGlvbnMsIGNsaWVudC5kZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgICAgICB3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSA9IFwic3RhbmRieVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSkge1xuICAgICAgICAgICAgd2F0Y2hRdWVyeU9wdGlvbnMuZmV0Y2hQb2xpY3kgPVxuICAgICAgICAgICAgICAgIChvYnNlcnZhYmxlID09PSBudWxsIHx8IG9ic2VydmFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9ic2VydmFibGUub3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kpIHx8XG4gICAgICAgICAgICAgICAgICAgIGdldERlZmF1bHRGZXRjaFBvbGljeShkZWZhdWx0T3B0aW9ucywgY2xpZW50LmRlZmF1bHRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hRdWVyeU9wdGlvbnM7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPYnNRdWVyeU9wdGlvbnMob2JzZXJ2YWJsZSwgY2xpZW50LCBxdWVyeUhvb2tPcHRpb25zLCB3YXRjaFF1ZXJ5T3B0aW9ucykge1xuICAgIHZhciB0b01lcmdlID0gW107XG4gICAgdmFyIGdsb2JhbERlZmF1bHRzID0gY2xpZW50LmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnk7XG4gICAgaWYgKGdsb2JhbERlZmF1bHRzKVxuICAgICAgICB0b01lcmdlLnB1c2goZ2xvYmFsRGVmYXVsdHMpO1xuICAgIGlmIChxdWVyeUhvb2tPcHRpb25zLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHRvTWVyZ2UucHVzaChxdWVyeUhvb2tPcHRpb25zLmRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gV2UgdXNlIGNvbXBhY3QgcmF0aGVyIHRoYW4gbWVyZ2VPcHRpb25zIGZvciB0aGlzIHBhcnQgb2YgdGhlIG1lcmdlLFxuICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB3YXRjaFF1ZXJ5T3B0aW9ucy52YXJpYWJsZXMgKGlmIGRlZmluZWQpIHRvIHJlcGxhY2VcbiAgICAvLyB0aGlzLm9ic2VydmFibGUub3B0aW9ucy52YXJpYWJsZXMgd2hvbGUuIFRoaXMgcmVwbGFjZW1lbnQgYWxsb3dzXG4gICAgLy8gcmVtb3ZpbmcgdmFyaWFibGVzIGJ5IHJlbW92aW5nIHRoZW0gZnJvbSB0aGUgdmFyaWFibGVzIGlucHV0IHRvXG4gICAgLy8gdXNlUXVlcnkuIElmIHRoZSB2YXJpYWJsZXMgd2VyZSBhbHdheXMgbWVyZ2VkIHRvZ2V0aGVyIChyYXRoZXIgdGhhblxuICAgIC8vIHJlcGxhY2VkKSwgdGhlcmUgd291bGQgYmUgbm8gd2F5IHRvIHJlbW92ZSBleGlzdGluZyB2YXJpYWJsZXMuXG4gICAgLy8gSG93ZXZlciwgdGhlIHZhcmlhYmxlcyBmcm9tIG9wdGlvbnMuZGVmYXVsdE9wdGlvbnMgYW5kIGdsb2JhbERlZmF1bHRzXG4gICAgLy8gKGlmIHByb3ZpZGVkKSBzaG91bGQgYmUgbWVyZ2VkLCB0byBlbnN1cmUgaW5kaXZpZHVhbCBkZWZhdWx0ZWRcbiAgICAvLyB2YXJpYWJsZXMgYWx3YXlzIGhhdmUgdmFsdWVzLCBpZiBub3Qgb3RoZXJ3aXNlIGRlZmluZWQgaW5cbiAgICAvLyBvYnNlcnZhYmxlLm9wdGlvbnMgb3Igd2F0Y2hRdWVyeU9wdGlvbnMuXG4gICAgdG9NZXJnZS5wdXNoKGNvbXBhY3Qob2JzZXJ2YWJsZSAmJiBvYnNlcnZhYmxlLm9wdGlvbnMsIHdhdGNoUXVlcnlPcHRpb25zKSk7XG4gICAgcmV0dXJuIHRvTWVyZ2UucmVkdWNlKG1lcmdlT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzZXRSZXN1bHQobmV4dFJlc3VsdCwgcmVzdWx0RGF0YSwgb2JzZXJ2YWJsZSwgY2xpZW50LCBwYXJ0aWFsUmVmZXRjaCwgZm9yY2VVcGRhdGUsIGNhbGxiYWNrcykge1xuICAgIHZhciBwcmV2aW91c1Jlc3VsdCA9IHJlc3VsdERhdGEuY3VycmVudDtcbiAgICBpZiAocHJldmlvdXNSZXN1bHQgJiYgcHJldmlvdXNSZXN1bHQuZGF0YSkge1xuICAgICAgICByZXN1bHREYXRhLnByZXZpb3VzRGF0YSA9IHByZXZpb3VzUmVzdWx0LmRhdGE7XG4gICAgfVxuICAgIGlmICghbmV4dFJlc3VsdC5lcnJvciAmJiBpc05vbkVtcHR5QXJyYXkobmV4dFJlc3VsdC5lcnJvcnMpKSB7XG4gICAgICAgIC8vIFVudGlsIGEgc2V0IG5hbWluZyBjb252ZW50aW9uIGZvciBuZXR3b3JrRXJyb3IgYW5kIGdyYXBoUUxFcnJvcnMgaXNcbiAgICAgICAgLy8gZGVjaWRlZCB1cG9uLCB3ZSBtYXAgZXJyb3JzIChncmFwaFFMRXJyb3JzKSB0byB0aGUgZXJyb3Igb3B0aW9ucy5cbiAgICAgICAgLy8gVE9ETzogSXMgaXQgcG9zc2libGUgZm9yIGJvdGggcmVzdWx0LmVycm9yIGFuZCByZXN1bHQuZXJyb3JzIHRvIGJlXG4gICAgICAgIC8vIGRlZmluZWQgaGVyZT9cbiAgICAgICAgbmV4dFJlc3VsdC5lcnJvciA9IG5ldyBBcG9sbG9FcnJvcih7IGdyYXBoUUxFcnJvcnM6IG5leHRSZXN1bHQuZXJyb3JzIH0pO1xuICAgIH1cbiAgICByZXN1bHREYXRhLmN1cnJlbnQgPSB0b1F1ZXJ5UmVzdWx0KHVuc2FmZUhhbmRsZVBhcnRpYWxSZWZldGNoKG5leHRSZXN1bHQsIG9ic2VydmFibGUsIHBhcnRpYWxSZWZldGNoKSwgcmVzdWx0RGF0YS5wcmV2aW91c0RhdGEsIG9ic2VydmFibGUsIGNsaWVudCk7XG4gICAgLy8gQ2FsbGluZyBzdGF0ZS5zZXRSZXN1bHQgYWx3YXlzIHRyaWdnZXJzIGFuIHVwZGF0ZSwgdGhvdWdoIHNvbWUgY2FsbCBzaXRlc1xuICAgIC8vIHBlcmZvcm0gYWRkaXRpb25hbCBlcXVhbGl0eSBjaGVja3MgYmVmb3JlIGNvbW1pdHRpbmcgdG8gYW4gdXBkYXRlLlxuICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgaGFuZGxlRXJyb3JPckNvbXBsZXRlZChuZXh0UmVzdWx0LCBwcmV2aW91c1Jlc3VsdCA9PT0gbnVsbCB8fCBwcmV2aW91c1Jlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXNSZXN1bHQubmV0d29ya1N0YXR1cywgY2FsbGJhY2tzKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yT3JDb21wbGV0ZWQocmVzdWx0LCBwcmV2aW91c05ldHdvcmtTdGF0dXMsIGNhbGxiYWNrcykge1xuICAgIGlmICghcmVzdWx0LmxvYWRpbmcpIHtcbiAgICAgICAgdmFyIGVycm9yXzEgPSB0b0Fwb2xsb0Vycm9yKHJlc3VsdCk7XG4gICAgICAgIC8vIHdhaXQgYSB0aWNrIGluIGNhc2Ugd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nIGEgY29tcG9uZW50XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JfMSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkVycm9yKGVycm9yXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmRhdGEgJiZcbiAgICAgICAgICAgICAgICBwcmV2aW91c05ldHdvcmtTdGF0dXMgIT09IHJlc3VsdC5uZXR3b3JrU3RhdHVzICYmXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5ldHdvcmtTdGF0dXMgPT09IE5ldHdvcmtTdGF0dXMucmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25Db21wbGV0ZWQocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQud2FybihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRSZXN1bHQocmVzdWx0RGF0YSwgb2JzZXJ2YWJsZSwgY2FsbGJhY2tzLCBwYXJ0aWFsUmVmZXRjaCwgY2xpZW50KSB7XG4gICAgLy8gVXNpbmcgdGhpcy5yZXN1bHQgYXMgYSBjYWNoZSBlbnN1cmVzIGdldEN1cnJlbnRSZXN1bHQgY29udGludWVzIHJldHVybmluZ1xuICAgIC8vIHRoZSBzYW1lICg9PT0pIHJlc3VsdCBvYmplY3QsIHVubGVzcyBzdGF0ZS5zZXRSZXN1bHQgaGFzIGJlZW4gY2FsbGVkLCBvclxuICAgIC8vIHdlJ3JlIGRvaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZXJlZm9yZSBvdmVycmlkZSB0aGUgcmVzdWx0IGJlbG93LlxuICAgIGlmICghcmVzdWx0RGF0YS5jdXJyZW50KSB7XG4gICAgICAgIC8vIFdBUk5JTkc6IFNJREUtRUZGRUNUUyBJTiBUSEUgUkVOREVSIEZVTkNUSU9OXG4gICAgICAgIC8vIHRoaXMgY291bGQgY2FsbCB1bnNhZmVIYW5kbGVQYXJ0aWFsUmVmZXRjaFxuICAgICAgICBzZXRSZXN1bHQob2JzZXJ2YWJsZS5nZXRDdXJyZW50UmVzdWx0KCksIHJlc3VsdERhdGEsIG9ic2VydmFibGUsIGNsaWVudCwgcGFydGlhbFJlZmV0Y2gsIGZ1bmN0aW9uICgpIHsgfSwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdERhdGEuY3VycmVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RmV0Y2hQb2xpY3kocXVlcnlIb29rRGVmYXVsdE9wdGlvbnMsIGNsaWVudERlZmF1bHRPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKHF1ZXJ5SG9va0RlZmF1bHRPcHRpb25zID09PSBudWxsIHx8IHF1ZXJ5SG9va0RlZmF1bHRPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBxdWVyeUhvb2tEZWZhdWx0T3B0aW9ucy5mZXRjaFBvbGljeSkgfHxcbiAgICAgICAgKChfYSA9IGNsaWVudERlZmF1bHRPcHRpb25zID09PSBudWxsIHx8IGNsaWVudERlZmF1bHRPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGllbnREZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmV0Y2hQb2xpY3kpIHx8XG4gICAgICAgIFwiY2FjaGUtZmlyc3RcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9BcG9sbG9FcnJvcihyZXN1bHQpIHtcbiAgICByZXR1cm4gaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpID9cbiAgICAgICAgbmV3IEFwb2xsb0Vycm9yKHsgZ3JhcGhRTEVycm9yczogcmVzdWx0LmVycm9ycyB9KVxuICAgICAgICA6IHJlc3VsdC5lcnJvcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1F1ZXJ5UmVzdWx0KHJlc3VsdCwgcHJldmlvdXNEYXRhLCBvYnNlcnZhYmxlLCBjbGllbnQpIHtcbiAgICB2YXIgZGF0YSA9IHJlc3VsdC5kYXRhLCBwYXJ0aWFsID0gcmVzdWx0LnBhcnRpYWwsIHJlc3VsdFdpdGhvdXRQYXJ0aWFsID0gX19yZXN0KHJlc3VsdCwgW1wiZGF0YVwiLCBcInBhcnRpYWxcIl0pO1xuICAgIHZhciBxdWVyeVJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHsgZGF0YTogZGF0YSB9LCByZXN1bHRXaXRob3V0UGFydGlhbCksIHsgY2xpZW50OiBjbGllbnQsIG9ic2VydmFibGU6IG9ic2VydmFibGUsIHZhcmlhYmxlczogb2JzZXJ2YWJsZS52YXJpYWJsZXMsIGNhbGxlZDogcmVzdWx0ICE9PSBzc3JEaXNhYmxlZFJlc3VsdCAmJiByZXN1bHQgIT09IHNraXBTdGFuZGJ5UmVzdWx0LCBwcmV2aW91c0RhdGE6IHByZXZpb3VzRGF0YSB9KTtcbiAgICByZXR1cm4gcXVlcnlSZXN1bHQ7XG59XG5mdW5jdGlvbiB1bnNhZmVIYW5kbGVQYXJ0aWFsUmVmZXRjaChyZXN1bHQsIG9ic2VydmFibGUsIHBhcnRpYWxSZWZldGNoKSB7XG4gICAgLy8gVE9ETzogVGhpcyBjb2RlIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gdGhlIHBhcnRpYWxSZWZldGNoIG9wdGlvbiBpc1xuICAgIC8vIHJlbW92ZWQuIEkgd2FzIHVuYWJsZSB0byBnZXQgdGhpcyBob29rIHRvIGJlaGF2ZSByZWFzb25hYmx5IGluIGNlcnRhaW5cbiAgICAvLyBlZGdlIGNhc2VzIHdoZW4gdGhpcyBibG9jayB3YXMgcHV0IGluIGFuIGVmZmVjdC5cbiAgICBpZiAocmVzdWx0LnBhcnRpYWwgJiZcbiAgICAgICAgcGFydGlhbFJlZmV0Y2ggJiZcbiAgICAgICAgIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICghcmVzdWx0LmRhdGEgfHwgT2JqZWN0LmtleXMocmVzdWx0LmRhdGEpLmxlbmd0aCA9PT0gMCkgJiZcbiAgICAgICAgb2JzZXJ2YWJsZS5vcHRpb25zLmZldGNoUG9saWN5ICE9PSBcImNhY2hlLW9ubHlcIikge1xuICAgICAgICBvYnNlcnZhYmxlLnJlZmV0Y2goKTtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IGxvYWRpbmc6IHRydWUsIG5ldHdvcmtTdGF0dXM6IE5ldHdvcmtTdGF0dXMucmVmZXRjaCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBzc3JEaXNhYmxlZFJlc3VsdCA9IG1heWJlRGVlcEZyZWV6ZSh7XG4gICAgbG9hZGluZzogdHJ1ZSxcbiAgICBkYXRhOiB2b2lkIDAsXG4gICAgZXJyb3I6IHZvaWQgMCxcbiAgICBuZXR3b3JrU3RhdHVzOiBOZXR3b3JrU3RhdHVzLmxvYWRpbmcsXG59KTtcbnZhciBza2lwU3RhbmRieVJlc3VsdCA9IG1heWJlRGVlcEZyZWV6ZSh7XG4gICAgbG9hZGluZzogZmFsc2UsXG4gICAgZGF0YTogdm9pZCAwLFxuICAgIGVycm9yOiB2b2lkIDAsXG4gICAgbmV0d29ya1N0YXR1czogTmV0d29ya1N0YXR1cy5yZWFkeSxcbn0pO1xuZnVuY3Rpb24gYmluZE9ic2VydmFibGVNZXRob2RzKG9ic2VydmFibGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWZldGNoOiBvYnNlcnZhYmxlLnJlZmV0Y2guYmluZChvYnNlcnZhYmxlKSxcbiAgICAgICAgcmVvYnNlcnZlOiBvYnNlcnZhYmxlLnJlb2JzZXJ2ZS5iaW5kKG9ic2VydmFibGUpLFxuICAgICAgICBmZXRjaE1vcmU6IG9ic2VydmFibGUuZmV0Y2hNb3JlLmJpbmQob2JzZXJ2YWJsZSksXG4gICAgICAgIHVwZGF0ZVF1ZXJ5OiBvYnNlcnZhYmxlLnVwZGF0ZVF1ZXJ5LmJpbmQob2JzZXJ2YWJsZSksXG4gICAgICAgIHN0YXJ0UG9sbGluZzogb2JzZXJ2YWJsZS5zdGFydFBvbGxpbmcuYmluZChvYnNlcnZhYmxlKSxcbiAgICAgICAgc3RvcFBvbGxpbmc6IG9ic2VydmFibGUuc3RvcFBvbGxpbmcuYmluZChvYnNlcnZhYmxlKSxcbiAgICAgICAgc3Vic2NyaWJlVG9Nb3JlOiBvYnNlcnZhYmxlLnN1YnNjcmliZVRvTW9yZS5iaW5kKG9ic2VydmFibGUpLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VRdWVyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useSyncExternalStore.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@apollo/client/react/hooks/useSyncExternalStore.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("var rehackt__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSyncExternalStore: () => (/* binding */ useSyncExternalStore)\n/* harmony export */ });\n/* harmony import */ var _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var rehackt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rehackt */ \"(app-pages-browser)/./node_modules/rehackt/index.js\");\n/* harmony import */ var _utilities_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utilities/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n\n\n\nvar didWarnUncachedGetSnapshot = false;\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = /*#__PURE__*/ (rehackt__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (rehackt__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(rehackt__WEBPACK_IMPORTED_MODULE_1__, 2)))[uSESKey];\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nvar useSyncExternalStore = realHook ||\n    (function (subscribe, getSnapshot, getServerSnapshot) {\n        // Read the current snapshot from the store on every render. Again, this\n        // breaks the rules of React, and only works here because of specific\n        // implementation details, most importantly that updates are\n        // always synchronous.\n        var value = getSnapshot();\n        if (\n        // DEVIATION: Using __DEV__\n        globalThis.__DEV__ !== false &&\n            !didWarnUncachedGetSnapshot &&\n            // DEVIATION: Not using Object.is because we know our snapshots will never\n            // be exotic primitive values like NaN, which is !== itself.\n            value !== getSnapshot()) {\n            didWarnUncachedGetSnapshot = true;\n            // DEVIATION: Using invariant.error instead of console.error directly.\n            globalThis.__DEV__ !== false && _utilities_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.error(68);\n        }\n        // Because updates are synchronous, we don't queue them. Instead we force a\n        // re-render whenever the subscribed state changes by updating an some\n        // arbitrary useState hook. Then, during render, we call getSnapshot to read\n        // the current value.\n        //\n        // Because we don't actually use the state returned by the useState hook, we\n        // can save a bit of memory by storing other stuff in that slot.\n        //\n        // To implement the early bailout, we need to track some things on a mutable\n        // object. Usually, we would put that in a useRef hook, but we can stash it in\n        // our useState hook instead.\n        //\n        // To force a re-render, we call forceUpdate({inst}). That works because the\n        // new object always fails an equality check.\n        var _a = rehackt__WEBPACK_IMPORTED_MODULE_1__.useState({\n            inst: { value: value, getSnapshot: getSnapshot },\n        }), inst = _a[0].inst, forceUpdate = _a[1];\n        // Track the latest getSnapshot function with a ref. This needs to be updated\n        // in the layout phase so we can access it during the tearing check that\n        // happens on subscribe.\n        if (_utilities_index_js__WEBPACK_IMPORTED_MODULE_2__.canUseLayoutEffect) {\n            // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n            // which may seem like a conditional hook, but this code ends up behaving\n            // unconditionally (one way or the other) because canUseLayoutEffect is\n            // constant.\n            rehackt__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(function () {\n                Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n                // Whenever getSnapshot or subscribe changes, we need to check in the\n                // commit phase if there was an interleaved mutation. In concurrent mode\n                // this can happen all the time, but even in synchronous mode, an earlier\n                // effect may have mutated the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n                // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n            }, [subscribe, value, getSnapshot]);\n        }\n        else {\n            Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n        }\n        rehackt__WEBPACK_IMPORTED_MODULE_1__.useEffect(function () {\n            // Check for changes right before subscribing. Subsequent changes will be\n            // detected in the subscription handler.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceUpdate({ inst: inst });\n            }\n            // Subscribe to the store and return a clean-up function.\n            return subscribe(function handleStoreChange() {\n                // TODO: Because there is no cross-renderer API for batching updates, it's\n                // up to the consumer of this library to wrap their subscription event\n                // with unstable_batchedUpdates. Should we try to detect when this isn't\n                // the case and print a warning in development?\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n            });\n            // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [subscribe]);\n        return value;\n    });\nfunction checkIfSnapshotChanged(_a) {\n    var value = _a.value, getSnapshot = _a.getSnapshot;\n    try {\n        return value !== getSnapshot();\n    }\n    catch (_b) {\n        return true;\n    }\n}\n//# sourceMappingURL=useSyncExternalStore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9ob29rcy91c2VTeW5jRXh0ZXJuYWxTdG9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2RDtBQUM1QjtBQUM2QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrTEFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrRUFBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0EsaUJBQWlCLDZDQUFjO0FBQy9CLG9CQUFvQix3Q0FBd0M7QUFDNUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBcUI7QUFDakMsc0NBQXNDLHdDQUF3QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtDQUFrQyx3Q0FBd0M7QUFDMUU7QUFDQSxRQUFRLDhDQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGFwb2xsb1xcY2xpZW50XFxyZWFjdFxcaG9va3NcXHVzZVN5bmNFeHRlcm5hbFN0b3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvZ2xvYmFscy9pbmRleC5qc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlaGFja3RcIjtcbmltcG9ydCB7IGNhblVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvaW5kZXguanNcIjtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlO1xuLy8gUHJldmVudCB3ZWJwYWNrIGZyb20gY29tcGxhaW5pbmcgYWJvdXQgb3VyIGZlYXR1cmUgZGV0ZWN0aW9uIG9mIHRoZVxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgcHJvcGVydHkgb2YgdGhlIFJlYWN0IG5hbWVzcGFjZSwgd2hpY2ggaXMgZXhwZWN0ZWQgbm90XG4vLyB0byBleGlzdCB3aGVuIHVzaW5nIFJlYWN0IDE3IGFuZCBlYXJsaWVyLCBhbmQgdGhhdCdzIGZpbmUuXG52YXIgdVNFU0tleSA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbnZhciByZWFsSG9vayA9IFJlYWN0W3VTRVNLZXldO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLCB3aXRoXG4vLyBBcG9sbG8gQ2xpZW50IGRldmlhdGlvbnMgY2FsbGVkIG91dCBieSBcIi8vIERFVklBVElPTiAuLi5cIiBjb21tZW50cy5cbi8vIFdoZW4vaWYgUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgaXMgZGVmaW5lZCwgZGVsZWdhdGUgZnVsbHkgdG8gaXQuXG5leHBvcnQgdmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gcmVhbEhvb2sgfHxcbiAgICAoZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICAgIC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAgICAgICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gICAgICAgIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBERVZJQVRJT046IFVzaW5nIF9fREVWX19cbiAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ICYmXG4gICAgICAgICAgICAvLyBERVZJQVRJT046IE5vdCB1c2luZyBPYmplY3QuaXMgYmVjYXVzZSB3ZSBrbm93IG91ciBzbmFwc2hvdHMgd2lsbCBuZXZlclxuICAgICAgICAgICAgLy8gYmUgZXhvdGljIHByaW1pdGl2ZSB2YWx1ZXMgbGlrZSBOYU4sIHdoaWNoIGlzICE9PSBpdHNlbGYuXG4gICAgICAgICAgICB2YWx1ZSAhPT0gZ2V0U25hcHNob3QoKSkge1xuICAgICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICAgICAgLy8gREVWSUFUSU9OOiBVc2luZyBpbnZhcmlhbnQuZXJyb3IgaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yIGRpcmVjdGx5LlxuICAgICAgICAgICAgZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSAmJiBpbnZhcmlhbnQuZXJyb3IoNjgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAgICAgICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gICAgICAgIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgICAgICAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gICAgICAgIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAgICAgICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuICAgICAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgICAgICAgICBpbnN0OiB7IHZhbHVlOiB2YWx1ZSwgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90IH0sXG4gICAgICAgIH0pLCBpbnN0ID0gX2FbMF0uaW5zdCwgZm9yY2VVcGRhdGUgPSBfYVsxXTtcbiAgICAgICAgLy8gVHJhY2sgdGhlIGxhdGVzdCBnZXRTbmFwc2hvdCBmdW5jdGlvbiB3aXRoIGEgcmVmLiBUaGlzIG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgLy8gaW4gdGhlIGxheW91dCBwaGFzZSBzbyB3ZSBjYW4gYWNjZXNzIGl0IGR1cmluZyB0aGUgdGVhcmluZyBjaGVjayB0aGF0XG4gICAgICAgIC8vIGhhcHBlbnMgb24gc3Vic2NyaWJlLlxuICAgICAgICBpZiAoY2FuVXNlTGF5b3V0RWZmZWN0KSB7XG4gICAgICAgICAgICAvLyBERVZJQVRJT046IFdlIGF2b2lkIGNhbGxpbmcgdXNlTGF5b3V0RWZmZWN0IHdoZW4gIWNhblVzZUxheW91dEVmZmVjdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1heSBzZWVtIGxpa2UgYSBjb25kaXRpb25hbCBob29rLCBidXQgdGhpcyBjb2RlIGVuZHMgdXAgYmVoYXZpbmdcbiAgICAgICAgICAgIC8vIHVuY29uZGl0aW9uYWxseSAob25lIHdheSBvciB0aGUgb3RoZXIpIGJlY2F1c2UgY2FuVXNlTGF5b3V0RWZmZWN0IGlzXG4gICAgICAgICAgICAvLyBjb25zdGFudC5cbiAgICAgICAgICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0LCB7IHZhbHVlOiB2YWx1ZSwgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90IH0pO1xuICAgICAgICAgICAgICAgIC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcbiAgICAgICAgICAgICAgICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVhY3QgSG9vayBSZWFjdC51c2VMYXlvdXRFZmZlY3QgaGFzIGEgbWlzc2luZyBkZXBlbmRlbmN5OiAnaW5zdCcuIEVpdGhlciBpbmNsdWRlIGl0IG9yIHJlbW92ZSB0aGUgZGVwZW5kZW5jeSBhcnJheS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdCwgeyB2YWx1ZTogdmFsdWUsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgcmlnaHQgYmVmb3JlIHN1YnNjcmliaW5nLiBTdWJzZXF1ZW50IGNoYW5nZXMgd2lsbCBiZVxuICAgICAgICAgICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgICAgICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh7IGluc3Q6IGluc3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gYSBjbGVhbi11cCBmdW5jdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gaGFuZGxlU3RvcmVDaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgICAgICAgICAgICAvLyB1cCB0byB0aGUgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5IHRvIHdyYXAgdGhlaXIgc3Vic2NyaXB0aW9uIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2l0aCB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcy4gU2hvdWxkIHdlIHRyeSB0byBkZXRlY3Qgd2hlbiB0aGlzIGlzbid0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgICAgICAgICAgICAvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuICAgICAgICAgICAgICAgIC8vIHJlYWQgZnJvbSB0aGUgc3RvcmUuXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFJlYWN0IEhvb2sgUmVhY3QudXNlRWZmZWN0IGhhcyBhIG1pc3NpbmcgZGVwZW5kZW5jeTogJ2luc3QnLiBFaXRoZXIgaW5jbHVkZSBpdCBvciByZW1vdmUgdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIH0sIFtzdWJzY3JpYmVdKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChfYSkge1xuICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBnZXRTbmFwc2hvdCA9IF9hLmdldFNuYXBzaG90O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gZ2V0U25hcHNob3QoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZVN5bmNFeHRlcm5hbFN0b3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useSyncExternalStore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js":
/*!****************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/arrays.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isNonEmptyArray: () => (/* binding */ isNonEmptyArray)\n/* harmony export */ });\n// A version of Array.isArray that works better with readonly arrays.\nvar isArray = Array.isArray;\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n//# sourceMappingURL=arrays.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2FycmF5cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXHV0aWxpdGllc1xcY29tbW9uXFxhcnJheXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSB2ZXJzaW9uIG9mIEFycmF5LmlzQXJyYXkgdGhhdCB3b3JrcyBiZXR0ZXIgd2l0aCByZWFkb25seSBhcnJheXMuXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/arrays.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/canonicalStringify.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonicalStringify: () => (/* binding */ canonicalStringify)\n/* harmony export */ });\n/* harmony import */ var _utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utilities/caching/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/caches.js\");\n/* harmony import */ var _utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utilities/caching/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/sizes.js\");\n/* harmony import */ var _caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../caching/getMemoryInternals.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/caching/getMemoryInternals.js\");\n\n\n/**\n * Like JSON.stringify, but with object keys always sorted in the same order.\n *\n * To achieve performant sorting, this function uses a Map from JSON-serialized\n * arrays of keys (in any order) to sorted arrays of the same keys, with a\n * single sorted array reference shared by all permutations of the keys.\n *\n * As a drawback, this function will add a little bit more memory for every\n * object encountered that has different (more, less, a different order of) keys\n * than in the past.\n *\n * In a typical application, this extra memory usage should not play a\n * significant role, as `canonicalStringify` will be called for only a limited\n * number of object shapes, and the cache will not grow beyond a certain point.\n * But in some edge cases, this could be a problem, so we provide\n * canonicalStringify.reset() as a way of clearing the cache.\n * */\nvar canonicalStringify = Object.assign(function canonicalStringify(value) {\n    return JSON.stringify(value, stableObjectReplacer);\n}, {\n    reset: function () {\n        // Clearing the sortingMap will reclaim all cached memory, without\n        // affecting the logical results of canonicalStringify, but potentially\n        // sacrificing performance until the cache is refilled.\n        sortingMap = new _utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_0__.AutoCleanedStrongCache(_utilities_caching_index_js__WEBPACK_IMPORTED_MODULE_1__.cacheSizes.canonicalStringify || 1000 /* defaultCacheSizes.canonicalStringify */);\n    },\n});\nif (globalThis.__DEV__ !== false) {\n    (0,_caching_getMemoryInternals_js__WEBPACK_IMPORTED_MODULE_2__.registerGlobalCache)(\"canonicalStringify\", function () { return sortingMap.size; });\n}\n// Values are JSON-serialized arrays of object keys (in any order), and values\n// are sorted arrays of the same keys.\nvar sortingMap;\ncanonicalStringify.reset();\n// The JSON.stringify function takes an optional second argument called a\n// replacer function. This function is called for each key-value pair in the\n// object being stringified, and its return value is used instead of the\n// original value. If the replacer function returns a new value, that value is\n// stringified as JSON instead of the original value of the property.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter\nfunction stableObjectReplacer(key, value) {\n    if (value && typeof value === \"object\") {\n        var proto = Object.getPrototypeOf(value);\n        // We don't want to mess with objects that are not \"plain\" objects, which\n        // means their prototype is either Object.prototype or null. This check also\n        // prevents needlessly rearranging the indices of arrays.\n        if (proto === Object.prototype || proto === null) {\n            var keys = Object.keys(value);\n            // If keys is already sorted, let JSON.stringify serialize the original\n            // value instead of creating a new object with keys in the same order.\n            if (keys.every(everyKeyInOrder))\n                return value;\n            var unsortedKey = JSON.stringify(keys);\n            var sortedKeys = sortingMap.get(unsortedKey);\n            if (!sortedKeys) {\n                keys.sort();\n                var sortedKey = JSON.stringify(keys);\n                // Checking for sortedKey in the sortingMap allows us to share the same\n                // sorted array reference for all permutations of the same set of keys.\n                sortedKeys = sortingMap.get(sortedKey) || keys;\n                sortingMap.set(unsortedKey, sortedKeys);\n                sortingMap.set(sortedKey, sortedKeys);\n            }\n            var sortedObject_1 = Object.create(proto);\n            // Reassigning the keys in sorted order will cause JSON.stringify to\n            // serialize them in sorted order.\n            sortedKeys.forEach(function (key) {\n                sortedObject_1[key] = value[key];\n            });\n            return sortedObject_1;\n        }\n    }\n    return value;\n}\n// Since everything that happens in stableObjectReplacer benefits from being as\n// efficient as possible, we use a static function as the callback for\n// keys.every in order to test if the provided keys are already sorted without\n// allocating extra memory for a callback.\nfunction everyKeyInOrder(key, i, keys) {\n    return i === 0 || keys[i - 1] <= key;\n}\n//# sourceMappingURL=canonicalStringify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2Nhbm9uaWNhbFN0cmluZ2lmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVGO0FBQ2hCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtFQUFzQixDQUFDLG1FQUFVO0FBQzFELEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxJQUFJLG1GQUFtQixxQ0FBcUMseUJBQXlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXHV0aWxpdGllc1xcY29tbW9uXFxjYW5vbmljYWxTdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0b0NsZWFuZWRTdHJvbmdDYWNoZSwgY2FjaGVTaXplcywgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2NhY2hpbmcvaW5kZXguanNcIjtcbmltcG9ydCB7IHJlZ2lzdGVyR2xvYmFsQ2FjaGUgfSBmcm9tIFwiLi4vY2FjaGluZy9nZXRNZW1vcnlJbnRlcm5hbHMuanNcIjtcbi8qKlxuICogTGlrZSBKU09OLnN0cmluZ2lmeSwgYnV0IHdpdGggb2JqZWN0IGtleXMgYWx3YXlzIHNvcnRlZCBpbiB0aGUgc2FtZSBvcmRlci5cbiAqXG4gKiBUbyBhY2hpZXZlIHBlcmZvcm1hbnQgc29ydGluZywgdGhpcyBmdW5jdGlvbiB1c2VzIGEgTWFwIGZyb20gSlNPTi1zZXJpYWxpemVkXG4gKiBhcnJheXMgb2Yga2V5cyAoaW4gYW55IG9yZGVyKSB0byBzb3J0ZWQgYXJyYXlzIG9mIHRoZSBzYW1lIGtleXMsIHdpdGggYVxuICogc2luZ2xlIHNvcnRlZCBhcnJheSByZWZlcmVuY2Ugc2hhcmVkIGJ5IGFsbCBwZXJtdXRhdGlvbnMgb2YgdGhlIGtleXMuXG4gKlxuICogQXMgYSBkcmF3YmFjaywgdGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBhIGxpdHRsZSBiaXQgbW9yZSBtZW1vcnkgZm9yIGV2ZXJ5XG4gKiBvYmplY3QgZW5jb3VudGVyZWQgdGhhdCBoYXMgZGlmZmVyZW50IChtb3JlLCBsZXNzLCBhIGRpZmZlcmVudCBvcmRlciBvZikga2V5c1xuICogdGhhbiBpbiB0aGUgcGFzdC5cbiAqXG4gKiBJbiBhIHR5cGljYWwgYXBwbGljYXRpb24sIHRoaXMgZXh0cmEgbWVtb3J5IHVzYWdlIHNob3VsZCBub3QgcGxheSBhXG4gKiBzaWduaWZpY2FudCByb2xlLCBhcyBgY2Fub25pY2FsU3RyaW5naWZ5YCB3aWxsIGJlIGNhbGxlZCBmb3Igb25seSBhIGxpbWl0ZWRcbiAqIG51bWJlciBvZiBvYmplY3Qgc2hhcGVzLCBhbmQgdGhlIGNhY2hlIHdpbGwgbm90IGdyb3cgYmV5b25kIGEgY2VydGFpbiBwb2ludC5cbiAqIEJ1dCBpbiBzb21lIGVkZ2UgY2FzZXMsIHRoaXMgY291bGQgYmUgYSBwcm9ibGVtLCBzbyB3ZSBwcm92aWRlXG4gKiBjYW5vbmljYWxTdHJpbmdpZnkucmVzZXQoKSBhcyBhIHdheSBvZiBjbGVhcmluZyB0aGUgY2FjaGUuXG4gKiAqL1xuZXhwb3J0IHZhciBjYW5vbmljYWxTdHJpbmdpZnkgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGNhbm9uaWNhbFN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgc3RhYmxlT2JqZWN0UmVwbGFjZXIpO1xufSwge1xuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENsZWFyaW5nIHRoZSBzb3J0aW5nTWFwIHdpbGwgcmVjbGFpbSBhbGwgY2FjaGVkIG1lbW9yeSwgd2l0aG91dFxuICAgICAgICAvLyBhZmZlY3RpbmcgdGhlIGxvZ2ljYWwgcmVzdWx0cyBvZiBjYW5vbmljYWxTdHJpbmdpZnksIGJ1dCBwb3RlbnRpYWxseVxuICAgICAgICAvLyBzYWNyaWZpY2luZyBwZXJmb3JtYW5jZSB1bnRpbCB0aGUgY2FjaGUgaXMgcmVmaWxsZWQuXG4gICAgICAgIHNvcnRpbmdNYXAgPSBuZXcgQXV0b0NsZWFuZWRTdHJvbmdDYWNoZShjYWNoZVNpemVzLmNhbm9uaWNhbFN0cmluZ2lmeSB8fCAxMDAwIC8qIGRlZmF1bHRDYWNoZVNpemVzLmNhbm9uaWNhbFN0cmluZ2lmeSAqLyk7XG4gICAgfSxcbn0pO1xuaWYgKGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UpIHtcbiAgICByZWdpc3Rlckdsb2JhbENhY2hlKFwiY2Fub25pY2FsU3RyaW5naWZ5XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvcnRpbmdNYXAuc2l6ZTsgfSk7XG59XG4vLyBWYWx1ZXMgYXJlIEpTT04tc2VyaWFsaXplZCBhcnJheXMgb2Ygb2JqZWN0IGtleXMgKGluIGFueSBvcmRlciksIGFuZCB2YWx1ZXNcbi8vIGFyZSBzb3J0ZWQgYXJyYXlzIG9mIHRoZSBzYW1lIGtleXMuXG52YXIgc29ydGluZ01hcDtcbmNhbm9uaWNhbFN0cmluZ2lmeS5yZXNldCgpO1xuLy8gVGhlIEpTT04uc3RyaW5naWZ5IGZ1bmN0aW9uIHRha2VzIGFuIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCBjYWxsZWQgYVxuLy8gcmVwbGFjZXIgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyIGluIHRoZVxuLy8gb2JqZWN0IGJlaW5nIHN0cmluZ2lmaWVkLCBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlXG4vLyBvcmlnaW5hbCB2YWx1ZS4gSWYgdGhlIHJlcGxhY2VyIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgdmFsdWUsIHRoYXQgdmFsdWUgaXNcbi8vIHN0cmluZ2lmaWVkIGFzIEpTT04gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjdGhlX3JlcGxhY2VyX3BhcmFtZXRlclxuZnVuY3Rpb24gc3RhYmxlT2JqZWN0UmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBtZXNzIHdpdGggb2JqZWN0cyB0aGF0IGFyZSBub3QgXCJwbGFpblwiIG9iamVjdHMsIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZWlyIHByb3RvdHlwZSBpcyBlaXRoZXIgT2JqZWN0LnByb3RvdHlwZSBvciBudWxsLiBUaGlzIGNoZWNrIGFsc29cbiAgICAgICAgLy8gcHJldmVudHMgbmVlZGxlc3NseSByZWFycmFuZ2luZyB0aGUgaW5kaWNlcyBvZiBhcnJheXMuXG4gICAgICAgIGlmIChwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBJZiBrZXlzIGlzIGFscmVhZHkgc29ydGVkLCBsZXQgSlNPTi5zdHJpbmdpZnkgc2VyaWFsaXplIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gdmFsdWUgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvYmplY3Qgd2l0aCBrZXlzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgaWYgKGtleXMuZXZlcnkoZXZlcnlLZXlJbk9yZGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB2YXIgdW5zb3J0ZWRLZXkgPSBKU09OLnN0cmluZ2lmeShrZXlzKTtcbiAgICAgICAgICAgIHZhciBzb3J0ZWRLZXlzID0gc29ydGluZ01hcC5nZXQodW5zb3J0ZWRLZXkpO1xuICAgICAgICAgICAgaWYgKCFzb3J0ZWRLZXlzKSB7XG4gICAgICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRlZEtleSA9IEpTT04uc3RyaW5naWZ5KGtleXMpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNraW5nIGZvciBzb3J0ZWRLZXkgaW4gdGhlIHNvcnRpbmdNYXAgYWxsb3dzIHVzIHRvIHNoYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gc29ydGVkIGFycmF5IHJlZmVyZW5jZSBmb3IgYWxsIHBlcm11dGF0aW9ucyBvZiB0aGUgc2FtZSBzZXQgb2Yga2V5cy5cbiAgICAgICAgICAgICAgICBzb3J0ZWRLZXlzID0gc29ydGluZ01hcC5nZXQoc29ydGVkS2V5KSB8fCBrZXlzO1xuICAgICAgICAgICAgICAgIHNvcnRpbmdNYXAuc2V0KHVuc29ydGVkS2V5LCBzb3J0ZWRLZXlzKTtcbiAgICAgICAgICAgICAgICBzb3J0aW5nTWFwLnNldChzb3J0ZWRLZXksIHNvcnRlZEtleXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvcnRlZE9iamVjdF8xID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgICAgICAvLyBSZWFzc2lnbmluZyB0aGUga2V5cyBpbiBzb3J0ZWQgb3JkZXIgd2lsbCBjYXVzZSBKU09OLnN0cmluZ2lmeSB0b1xuICAgICAgICAgICAgLy8gc2VyaWFsaXplIHRoZW0gaW4gc29ydGVkIG9yZGVyLlxuICAgICAgICAgICAgc29ydGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBzb3J0ZWRPYmplY3RfMVtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZE9iamVjdF8xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIFNpbmNlIGV2ZXJ5dGhpbmcgdGhhdCBoYXBwZW5zIGluIHN0YWJsZU9iamVjdFJlcGxhY2VyIGJlbmVmaXRzIGZyb20gYmVpbmcgYXNcbi8vIGVmZmljaWVudCBhcyBwb3NzaWJsZSwgd2UgdXNlIGEgc3RhdGljIGZ1bmN0aW9uIGFzIHRoZSBjYWxsYmFjayBmb3Jcbi8vIGtleXMuZXZlcnkgaW4gb3JkZXIgdG8gdGVzdCBpZiB0aGUgcHJvdmlkZWQga2V5cyBhcmUgYWxyZWFkeSBzb3J0ZWQgd2l0aG91dFxuLy8gYWxsb2NhdGluZyBleHRyYSBtZW1vcnkgZm9yIGEgY2FsbGJhY2suXG5mdW5jdGlvbiBldmVyeUtleUluT3JkZXIoa2V5LCBpLCBrZXlzKSB7XG4gICAgcmV0dXJuIGkgPT09IDAgfHwga2V5c1tpIC0gMV0gPD0ga2V5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2Fub25pY2FsU3RyaW5naWZ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/cloneDeep.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/cloneDeep.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep)\n/* harmony export */ });\nvar toString = Object.prototype.toString;\n/**\n * Deeply clones a value to create a new instance.\n */\nfunction cloneDeep(value) {\n    return cloneDeepHelper(value);\n}\nfunction cloneDeepHelper(val, seen) {\n    switch (toString.call(val)) {\n        case \"[object Array]\": {\n            seen = seen || new Map();\n            if (seen.has(val))\n                return seen.get(val);\n            var copy_1 = val.slice(0);\n            seen.set(val, copy_1);\n            copy_1.forEach(function (child, i) {\n                copy_1[i] = cloneDeepHelper(child, seen);\n            });\n            return copy_1;\n        }\n        case \"[object Object]\": {\n            seen = seen || new Map();\n            if (seen.has(val))\n                return seen.get(val);\n            // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n            // possible in all JS environments, so we will assume they exist/work.\n            var copy_2 = Object.create(Object.getPrototypeOf(val));\n            seen.set(val, copy_2);\n            Object.keys(val).forEach(function (key) {\n                copy_2[key] = cloneDeepHelper(val[key], seen);\n            });\n            return copy_2;\n        }\n        default:\n            return val;\n    }\n}\n//# sourceMappingURL=cloneDeep.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL2Nsb25lRGVlcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGFwb2xsb1xcY2xpZW50XFx1dGlsaXRpZXNcXGNvbW1vblxcY2xvbmVEZWVwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vKipcbiAqIERlZXBseSBjbG9uZXMgYSB2YWx1ZSB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICByZXR1cm4gY2xvbmVEZWVwSGVscGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGVlcEhlbHBlcih2YWwsIHNlZW4pIHtcbiAgICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjoge1xuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHZhbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4uZ2V0KHZhbCk7XG4gICAgICAgICAgICB2YXIgY29weV8xID0gdmFsLnNsaWNlKDApO1xuICAgICAgICAgICAgc2Vlbi5zZXQodmFsLCBjb3B5XzEpO1xuICAgICAgICAgICAgY29weV8xLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgICAgICAgICAgY29weV8xW2ldID0gY2xvbmVEZWVwSGVscGVyKGNoaWxkLCBzZWVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlfMTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6IHtcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2YWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLmdldCh2YWwpO1xuICAgICAgICAgICAgLy8gSGlnaCBmaWRlbGl0eSBwb2x5ZmlsbHMgb2YgT2JqZWN0LmNyZWF0ZSBhbmQgT2JqZWN0LmdldFByb3RvdHlwZU9mIGFyZVxuICAgICAgICAgICAgLy8gcG9zc2libGUgaW4gYWxsIEpTIGVudmlyb25tZW50cywgc28gd2Ugd2lsbCBhc3N1bWUgdGhleSBleGlzdC93b3JrLlxuICAgICAgICAgICAgdmFyIGNvcHlfMiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCkpO1xuICAgICAgICAgICAgc2Vlbi5zZXQodmFsLCBjb3B5XzIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjb3B5XzJba2V5XSA9IGNsb25lRGVlcEhlbHBlcih2YWxba2V5XSwgc2Vlbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5XzI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmVEZWVwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/cloneDeep.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepFreeze: () => (/* binding */ deepFreeze),\n/* harmony export */   maybeDeepFreeze: () => (/* binding */ maybeDeepFreeze)\n/* harmony export */ });\n/* harmony import */ var _objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n\nfunction deepFreeze(value) {\n    var workSet = new Set([value]);\n    workSet.forEach(function (obj) {\n        if ((0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(obj) && shallowFreeze(obj) === obj) {\n            Object.getOwnPropertyNames(obj).forEach(function (name) {\n                if ((0,_objects_js__WEBPACK_IMPORTED_MODULE_0__.isNonNullObject)(obj[name]))\n                    workSet.add(obj[name]);\n            });\n        }\n    });\n    return value;\n}\nfunction shallowFreeze(obj) {\n    if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {\n        try {\n            Object.freeze(obj);\n        }\n        catch (e) {\n            // Some types like Uint8Array and Node.js's Buffer cannot be frozen, but\n            // they all throw a TypeError when you try, so we re-throw any exceptions\n            // that are not TypeErrors, since that would be unexpected.\n            if (e instanceof TypeError)\n                return null;\n            throw e;\n        }\n    }\n    return obj;\n}\nfunction maybeDeepFreeze(obj) {\n    if (globalThis.__DEV__ !== false) {\n        deepFreeze(obj);\n    }\n    return obj;\n}\n//# sourceMappingURL=maybeDeepFreeze.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvY29tbW9uL21heWJlRGVlcEZyZWV6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEM7QUFDUDtBQUNBO0FBQ0EsWUFBWSw0REFBZTtBQUMzQjtBQUNBLG9CQUFvQiw0REFBZTtBQUNuQztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXHV0aWxpdGllc1xcY29tbW9uXFxtYXliZURlZXBGcmVlemUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOb25OdWxsT2JqZWN0IH0gZnJvbSBcIi4vb2JqZWN0cy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBGcmVlemUodmFsdWUpIHtcbiAgICB2YXIgd29ya1NldCA9IG5ldyBTZXQoW3ZhbHVlXSk7XG4gICAgd29ya1NldC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdChvYmopICYmIHNoYWxsb3dGcmVlemUob2JqKSA9PT0gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25OdWxsT2JqZWN0KG9ialtuYW1lXSkpXG4gICAgICAgICAgICAgICAgICAgIHdvcmtTZXQuYWRkKG9ialtuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dGcmVlemUob2JqKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgIU9iamVjdC5pc0Zyb3plbihvYmopKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgdHlwZXMgbGlrZSBVaW50OEFycmF5IGFuZCBOb2RlLmpzJ3MgQnVmZmVyIGNhbm5vdCBiZSBmcm96ZW4sIGJ1dFxuICAgICAgICAgICAgLy8gdGhleSBhbGwgdGhyb3cgYSBUeXBlRXJyb3Igd2hlbiB5b3UgdHJ5LCBzbyB3ZSByZS10aHJvdyBhbnkgZXhjZXB0aW9uc1xuICAgICAgICAgICAgLy8gdGhhdCBhcmUgbm90IFR5cGVFcnJvcnMsIHNpbmNlIHRoYXQgd291bGQgYmUgdW5leHBlY3RlZC5cbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlRGVlcEZyZWV6ZShvYmopIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgICAgICBkZWVwRnJlZXplKG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXliZURlZXBGcmVlemUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/directives.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDirectiveNames: () => (/* binding */ getDirectiveNames),\n/* harmony export */   getFragmentMaskMode: () => (/* binding */ getFragmentMaskMode),\n/* harmony export */   getInclusionDirectives: () => (/* binding */ getInclusionDirectives),\n/* harmony export */   hasAllDirectives: () => (/* binding */ hasAllDirectives),\n/* harmony export */   hasAnyDirectives: () => (/* binding */ hasAnyDirectives),\n/* harmony export */   hasClientExports: () => (/* binding */ hasClientExports),\n/* harmony export */   hasDirectives: () => (/* binding */ hasDirectives),\n/* harmony export */   shouldInclude: () => (/* binding */ shouldInclude)\n/* harmony export */ });\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\");\n\n\nfunction shouldInclude(_a, variables) {\n    var directives = _a.directives;\n    if (!directives || !directives.length) {\n        return true;\n    }\n    return getInclusionDirectives(directives).every(function (_a) {\n        var directive = _a.directive, ifArgument = _a.ifArgument;\n        var evaledValue = false;\n        if (ifArgument.value.kind === \"Variable\") {\n            evaledValue =\n                variables && variables[ifArgument.value.name.value];\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(evaledValue !== void 0, 78, directive.name.value);\n        }\n        else {\n            evaledValue = ifArgument.value.value;\n        }\n        return directive.name.value === \"skip\" ? !evaledValue : evaledValue;\n    });\n}\nfunction getDirectiveNames(root) {\n    var names = [];\n    (0,graphql__WEBPACK_IMPORTED_MODULE_1__.visit)(root, {\n        Directive: function (node) {\n            names.push(node.name.value);\n        },\n    });\n    return names;\n}\nvar hasAnyDirectives = function (names, root) {\n    return hasDirectives(names, root, false);\n};\nvar hasAllDirectives = function (names, root) {\n    return hasDirectives(names, root, true);\n};\nfunction hasDirectives(names, root, all) {\n    var nameSet = new Set(names);\n    var uniqueCount = nameSet.size;\n    (0,graphql__WEBPACK_IMPORTED_MODULE_1__.visit)(root, {\n        Directive: function (node) {\n            if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {\n                return graphql__WEBPACK_IMPORTED_MODULE_1__.BREAK;\n            }\n        },\n    });\n    // If we found all the names, nameSet will be empty. If we only care about\n    // finding some of them, the < condition is sufficient.\n    return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\nfunction hasClientExports(document) {\n    return document && hasDirectives([\"client\", \"export\"], document, true);\n}\nfunction isInclusionDirective(_a) {\n    var value = _a.name.value;\n    return value === \"skip\" || value === \"include\";\n}\nfunction getInclusionDirectives(directives) {\n    var result = [];\n    if (directives && directives.length) {\n        directives.forEach(function (directive) {\n            if (!isInclusionDirective(directive))\n                return;\n            var directiveArguments = directive.arguments;\n            var directiveName = directive.name.value;\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(directiveArguments && directiveArguments.length === 1, 79, directiveName);\n            var ifArgument = directiveArguments[0];\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(ifArgument.name && ifArgument.name.value === \"if\", 80, directiveName);\n            var ifValue = ifArgument.value;\n            // means it has to be a variable value if this is a valid @skip or @include directive\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(ifValue &&\n                (ifValue.kind === \"Variable\" || ifValue.kind === \"BooleanValue\"), 81, directiveName);\n            result.push({ directive: directive, ifArgument: ifArgument });\n        });\n    }\n    return result;\n}\n/** @internal */\nfunction getFragmentMaskMode(fragment) {\n    var _a, _b;\n    var directive = (_a = fragment.directives) === null || _a === void 0 ? void 0 : _a.find(function (_a) {\n        var name = _a.name;\n        return name.value === \"unmask\";\n    });\n    if (!directive) {\n        return \"mask\";\n    }\n    var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function (_a) {\n        var name = _a.name;\n        return name.value === \"mode\";\n    });\n    if (globalThis.__DEV__ !== false) {\n        if (modeArg) {\n            if (modeArg.value.kind === graphql__WEBPACK_IMPORTED_MODULE_2__.Kind.VARIABLE) {\n                globalThis.__DEV__ !== false && _globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(82);\n            }\n            else if (modeArg.value.kind !== graphql__WEBPACK_IMPORTED_MODULE_2__.Kind.STRING) {\n                globalThis.__DEV__ !== false && _globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(83);\n            }\n            else if (modeArg.value.value !== \"migrate\") {\n                globalThis.__DEV__ !== false && _globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant.warn(84, modeArg.value.value);\n            }\n        }\n    }\n    if (modeArg &&\n        \"value\" in modeArg.value &&\n        modeArg.value.value === \"migrate\") {\n        return \"migrate\";\n    }\n    return \"unmask\";\n}\n//# sourceMappingURL=directives.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9kaXJlY3RpdmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0g7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQSxJQUFJLDhDQUFLO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksOENBQUs7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFLO0FBQzVCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQVM7QUFDckI7QUFDQSxZQUFZLDREQUFTO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZLDREQUFTO0FBQ3JCO0FBQ0EsMEJBQTBCLDhDQUE4QztBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLHlDQUFJO0FBQzNDLGdEQUFnRCx3REFBUztBQUN6RDtBQUNBLDRDQUE0Qyx5Q0FBSTtBQUNoRCxnREFBZ0Qsd0RBQVM7QUFDekQ7QUFDQTtBQUNBLGdEQUFnRCx3REFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBhcG9sbG9cXGNsaWVudFxcdXRpbGl0aWVzXFxncmFwaHFsXFxkaXJlY3RpdmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGludmFyaWFudCB9IGZyb20gXCIuLi9nbG9iYWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB2aXNpdCwgQlJFQUssIEtpbmQgfSBmcm9tIFwiZ3JhcGhxbFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEluY2x1ZGUoX2EsIHZhcmlhYmxlcykge1xuICAgIHZhciBkaXJlY3RpdmVzID0gX2EuZGlyZWN0aXZlcztcbiAgICBpZiAoIWRpcmVjdGl2ZXMgfHwgIWRpcmVjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcyhkaXJlY3RpdmVzKS5ldmVyeShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IF9hLmRpcmVjdGl2ZSwgaWZBcmd1bWVudCA9IF9hLmlmQXJndW1lbnQ7XG4gICAgICAgIHZhciBldmFsZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaWZBcmd1bWVudC52YWx1ZS5raW5kID09PSBcIlZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAgIGV2YWxlZFZhbHVlID1cbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgJiYgdmFyaWFibGVzW2lmQXJndW1lbnQudmFsdWUubmFtZS52YWx1ZV07XG4gICAgICAgICAgICBpbnZhcmlhbnQoZXZhbGVkVmFsdWUgIT09IHZvaWQgMCwgNzgsIGRpcmVjdGl2ZS5uYW1lLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2YWxlZFZhbHVlID0gaWZBcmd1bWVudC52YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09IFwic2tpcFwiID8gIWV2YWxlZFZhbHVlIDogZXZhbGVkVmFsdWU7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlyZWN0aXZlTmFtZXMocm9vdCkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIHZpc2l0KHJvb3QsIHtcbiAgICAgICAgRGlyZWN0aXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbmFtZXMucHVzaChub2RlLm5hbWUudmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmV4cG9ydCB2YXIgaGFzQW55RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChuYW1lcywgcm9vdCkge1xuICAgIHJldHVybiBoYXNEaXJlY3RpdmVzKG5hbWVzLCByb290LCBmYWxzZSk7XG59O1xuZXhwb3J0IHZhciBoYXNBbGxEaXJlY3RpdmVzID0gZnVuY3Rpb24gKG5hbWVzLCByb290KSB7XG4gICAgcmV0dXJuIGhhc0RpcmVjdGl2ZXMobmFtZXMsIHJvb3QsIHRydWUpO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBoYXNEaXJlY3RpdmVzKG5hbWVzLCByb290LCBhbGwpIHtcbiAgICB2YXIgbmFtZVNldCA9IG5ldyBTZXQobmFtZXMpO1xuICAgIHZhciB1bmlxdWVDb3VudCA9IG5hbWVTZXQuc2l6ZTtcbiAgICB2aXNpdChyb290LCB7XG4gICAgICAgIERpcmVjdGl2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lU2V0LmRlbGV0ZShub2RlLm5hbWUudmFsdWUpICYmICghYWxsIHx8ICFuYW1lU2V0LnNpemUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIElmIHdlIGZvdW5kIGFsbCB0aGUgbmFtZXMsIG5hbWVTZXQgd2lsbCBiZSBlbXB0eS4gSWYgd2Ugb25seSBjYXJlIGFib3V0XG4gICAgLy8gZmluZGluZyBzb21lIG9mIHRoZW0sIHRoZSA8IGNvbmRpdGlvbiBpcyBzdWZmaWNpZW50LlxuICAgIHJldHVybiBhbGwgPyAhbmFtZVNldC5zaXplIDogbmFtZVNldC5zaXplIDwgdW5pcXVlQ291bnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xpZW50RXhwb3J0cyhkb2N1bWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudCAmJiBoYXNEaXJlY3RpdmVzKFtcImNsaWVudFwiLCBcImV4cG9ydFwiXSwgZG9jdW1lbnQsIHRydWUpO1xufVxuZnVuY3Rpb24gaXNJbmNsdXNpb25EaXJlY3RpdmUoX2EpIHtcbiAgICB2YXIgdmFsdWUgPSBfYS5uYW1lLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gXCJza2lwXCIgfHwgdmFsdWUgPT09IFwiaW5jbHVkZVwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEluY2x1c2lvbkRpcmVjdGl2ZXMoZGlyZWN0aXZlcykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKCFpc0luY2x1c2lvbkRpcmVjdGl2ZShkaXJlY3RpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVBcmd1bWVudHMgPSBkaXJlY3RpdmUuYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubmFtZS52YWx1ZTtcbiAgICAgICAgICAgIGludmFyaWFudChkaXJlY3RpdmVBcmd1bWVudHMgJiYgZGlyZWN0aXZlQXJndW1lbnRzLmxlbmd0aCA9PT0gMSwgNzksIGRpcmVjdGl2ZU5hbWUpO1xuICAgICAgICAgICAgdmFyIGlmQXJndW1lbnQgPSBkaXJlY3RpdmVBcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpbnZhcmlhbnQoaWZBcmd1bWVudC5uYW1lICYmIGlmQXJndW1lbnQubmFtZS52YWx1ZSA9PT0gXCJpZlwiLCA4MCwgZGlyZWN0aXZlTmFtZSk7XG4gICAgICAgICAgICB2YXIgaWZWYWx1ZSA9IGlmQXJndW1lbnQudmFsdWU7XG4gICAgICAgICAgICAvLyBtZWFucyBpdCBoYXMgdG8gYmUgYSB2YXJpYWJsZSB2YWx1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgQHNraXAgb3IgQGluY2x1ZGUgZGlyZWN0aXZlXG4gICAgICAgICAgICBpbnZhcmlhbnQoaWZWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIChpZlZhbHVlLmtpbmQgPT09IFwiVmFyaWFibGVcIiB8fCBpZlZhbHVlLmtpbmQgPT09IFwiQm9vbGVhblZhbHVlXCIpLCA4MSwgZGlyZWN0aXZlTmFtZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGRpcmVjdGl2ZTogZGlyZWN0aXZlLCBpZkFyZ3VtZW50OiBpZkFyZ3VtZW50IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudE1hc2tNb2RlKGZyYWdtZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgZGlyZWN0aXZlID0gKF9hID0gZnJhZ21lbnQuZGlyZWN0aXZlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBuYW1lID0gX2EubmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWUudmFsdWUgPT09IFwidW5tYXNrXCI7XG4gICAgfSk7XG4gICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIFwibWFza1wiO1xuICAgIH1cbiAgICB2YXIgbW9kZUFyZyA9IChfYiA9IGRpcmVjdGl2ZS5hcmd1bWVudHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgIHJldHVybiBuYW1lLnZhbHVlID09PSBcIm1vZGVcIjtcbiAgICB9KTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5fX0RFVl9fICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAobW9kZUFyZykge1xuICAgICAgICAgICAgaWYgKG1vZGVBcmcudmFsdWUua2luZCA9PT0gS2luZC5WQVJJQUJMRSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50Lndhcm4oODIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZUFyZy52YWx1ZS5raW5kICE9PSBLaW5kLlNUUklORykge1xuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuX19ERVZfXyAhPT0gZmFsc2UgJiYgaW52YXJpYW50Lndhcm4oODMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZUFyZy52YWx1ZS52YWx1ZSAhPT0gXCJtaWdyYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLl9fREVWX18gIT09IGZhbHNlICYmIGludmFyaWFudC53YXJuKDg0LCBtb2RlQXJnLnZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZUFyZyAmJlxuICAgICAgICBcInZhbHVlXCIgaW4gbW9kZUFyZy52YWx1ZSAmJlxuICAgICAgICBtb2RlQXJnLnZhbHVlLnZhbHVlID09PSBcIm1pZ3JhdGVcIikge1xuICAgICAgICByZXR1cm4gXCJtaWdyYXRlXCI7XG4gICAgfVxuICAgIHJldHVybiBcInVubWFza1wiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/directives.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js":
/*!********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/fragments.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFragmentMap: () => (/* binding */ createFragmentMap),\n/* harmony export */   getFragmentFromSelection: () => (/* binding */ getFragmentFromSelection),\n/* harmony export */   getFragmentQueryDocument: () => (/* binding */ getFragmentQueryDocument),\n/* harmony export */   isFullyUnmaskedOperation: () => (/* binding */ isFullyUnmaskedOperation)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphql */ \"(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\");\n\n\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nfunction getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    // Build an array of all our fragment definitions that will be used for\n    // validations. We also do some validations on the other definitions in the\n    // document while building this list.\n    var fragments = [];\n    document.definitions.forEach(function (definition) {\n        // Throw an error if we encounter an operation definition because we will\n        // define our own operation definition later on.\n        if (definition.kind === \"OperationDefinition\") {\n            throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(\n                85,\n                definition.operation,\n                definition.name ? \" named '\".concat(definition.name.value, \"'\") : \"\"\n            );\n        }\n        // Add our definition to the fragments array if it is a fragment\n        // definition.\n        if (definition.kind === \"FragmentDefinition\") {\n            fragments.push(definition);\n        }\n    });\n    // If the user did not give us a fragment name then let us try to get a\n    // name from a single fragment in the definition.\n    if (typeof actualFragmentName === \"undefined\") {\n        (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragments.length === 1, 86, fragments.length);\n        actualFragmentName = fragments[0].name.value;\n    }\n    // Generate a query document with an operation that simply spreads the\n    // fragment inside of it.\n    var query = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, document), { definitions: (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([\n            {\n                kind: \"OperationDefinition\",\n                // OperationTypeNode is an enum\n                operation: \"query\",\n                selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                        {\n                            kind: \"FragmentSpread\",\n                            name: {\n                                kind: \"Name\",\n                                value: actualFragmentName,\n                            },\n                        },\n                    ],\n                },\n            }\n        ], document.definitions, true) });\n    return query;\n}\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nfunction createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nfunction getFragmentFromSelection(selection, fragmentMap) {\n    switch (selection.kind) {\n        case \"InlineFragment\":\n            return selection;\n        case \"FragmentSpread\": {\n            var fragmentName = selection.name.value;\n            if (typeof fragmentMap === \"function\") {\n                return fragmentMap(fragmentName);\n            }\n            var fragment = fragmentMap && fragmentMap[fragmentName];\n            (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragment, 87, fragmentName);\n            return fragment || null;\n        }\n        default:\n            return null;\n    }\n}\nfunction isFullyUnmaskedOperation(document) {\n    var isUnmasked = true;\n    (0,graphql__WEBPACK_IMPORTED_MODULE_2__.visit)(document, {\n        FragmentSpread: function (node) {\n            isUnmasked =\n                !!node.directives &&\n                    node.directives.some(function (directive) { return directive.name.value === \"unmask\"; });\n            if (!isUnmasked) {\n                return graphql__WEBPACK_IMPORTED_MODULE_2__.BREAK;\n            }\n        },\n    });\n    return isUnmasked;\n}\n//# sourceMappingURL=fragments.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9mcmFnbWVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnRDtBQUNtQjtBQUM1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9FQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFRLENBQUMsK0NBQVEsR0FBRyxlQUFlLGFBQWEsb0RBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLDhDQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJDQUEyQztBQUMzRztBQUNBLHVCQUF1QiwwQ0FBSztBQUM1QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBhcG9sbG9cXGNsaWVudFxcdXRpbGl0aWVzXFxncmFwaHFsXFxmcmFnbWVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGludmFyaWFudCwgbmV3SW52YXJpYW50RXJyb3IgfSBmcm9tIFwiLi4vZ2xvYmFscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQlJFQUssIHZpc2l0IH0gZnJvbSBcImdyYXBocWxcIjtcbi8qKlxuICogUmV0dXJucyBhIHF1ZXJ5IGRvY3VtZW50IHdoaWNoIGFkZHMgYSBzaW5nbGUgcXVlcnkgb3BlcmF0aW9uIHRoYXQgb25seVxuICogc3ByZWFkcyB0aGUgdGFyZ2V0IGZyYWdtZW50IGluc2lkZSBvZiBpdC5cbiAqXG4gKiBTbyBmb3IgZXhhbXBsZSBhIGRvY3VtZW50IG9mOlxuICpcbiAqIGBgYGdyYXBocWxcbiAqIGZyYWdtZW50IGZvbyBvbiBGb28geyBhIGIgYyB9XG4gKiBgYGBcbiAqXG4gKiBUdXJucyBpbnRvOlxuICpcbiAqIGBgYGdyYXBocWxcbiAqIHsgLi4uZm9vIH1cbiAqXG4gKiBmcmFnbWVudCBmb28gb24gRm9vIHsgYSBiIGMgfVxuICogYGBgXG4gKlxuICogVGhlIHRhcmdldCBmcmFnbWVudCB3aWxsIGVpdGhlciBiZSB0aGUgb25seSBmcmFnbWVudCBpbiB0aGUgZG9jdW1lbnQsIG9yIGFcbiAqIGZyYWdtZW50IHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgYGZyYWdtZW50TmFtZWAuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmVcbiAqIGZyYWdtZW50LCBidXQgYSBgZnJhZ21lbnROYW1lYCB3YXMgbm90IGRlZmluZWQgdGhlbiBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50UXVlcnlEb2N1bWVudChkb2N1bWVudCwgZnJhZ21lbnROYW1lKSB7XG4gICAgdmFyIGFjdHVhbEZyYWdtZW50TmFtZSA9IGZyYWdtZW50TmFtZTtcbiAgICAvLyBCdWlsZCBhbiBhcnJheSBvZiBhbGwgb3VyIGZyYWdtZW50IGRlZmluaXRpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGZvclxuICAgIC8vIHZhbGlkYXRpb25zLiBXZSBhbHNvIGRvIHNvbWUgdmFsaWRhdGlvbnMgb24gdGhlIG90aGVyIGRlZmluaXRpb25zIGluIHRoZVxuICAgIC8vIGRvY3VtZW50IHdoaWxlIGJ1aWxkaW5nIHRoaXMgbGlzdC5cbiAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgZG9jdW1lbnQuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiB3ZSBlbmNvdW50ZXIgYW4gb3BlcmF0aW9uIGRlZmluaXRpb24gYmVjYXVzZSB3ZSB3aWxsXG4gICAgICAgIC8vIGRlZmluZSBvdXIgb3duIG9wZXJhdGlvbiBkZWZpbml0aW9uIGxhdGVyIG9uLlxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoXG4gICAgICAgICAgICAgICAgODUsXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5vcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID8gXCIgbmFtZWQgJ1wiLmNvbmNhdChkZWZpbml0aW9uLm5hbWUudmFsdWUsIFwiJ1wiKSA6IFwiXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG91ciBkZWZpbml0aW9uIHRvIHRoZSBmcmFnbWVudHMgYXJyYXkgaWYgaXQgaXMgYSBmcmFnbWVudFxuICAgICAgICAvLyBkZWZpbml0aW9uLlxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSBcIkZyYWdtZW50RGVmaW5pdGlvblwiKSB7XG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElmIHRoZSB1c2VyIGRpZCBub3QgZ2l2ZSB1cyBhIGZyYWdtZW50IG5hbWUgdGhlbiBsZXQgdXMgdHJ5IHRvIGdldCBhXG4gICAgLy8gbmFtZSBmcm9tIGEgc2luZ2xlIGZyYWdtZW50IGluIHRoZSBkZWZpbml0aW9uLlxuICAgIGlmICh0eXBlb2YgYWN0dWFsRnJhZ21lbnROYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGludmFyaWFudChmcmFnbWVudHMubGVuZ3RoID09PSAxLCA4NiwgZnJhZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgIGFjdHVhbEZyYWdtZW50TmFtZSA9IGZyYWdtZW50c1swXS5uYW1lLnZhbHVlO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBhIHF1ZXJ5IGRvY3VtZW50IHdpdGggYW4gb3BlcmF0aW9uIHRoYXQgc2ltcGx5IHNwcmVhZHMgdGhlXG4gICAgLy8gZnJhZ21lbnQgaW5zaWRlIG9mIGl0LlxuICAgIHZhciBxdWVyeSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb2N1bWVudCksIHsgZGVmaW5pdGlvbnM6IF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwiT3BlcmF0aW9uRGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgICAgIC8vIE9wZXJhdGlvblR5cGVOb2RlIGlzIGFuIGVudW1cbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicXVlcnlcIixcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogXCJTZWxlY3Rpb25TZXRcIixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiRnJhZ21lbnRTcHJlYWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiTmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWN0dWFsRnJhZ21lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sIGRvY3VtZW50LmRlZmluaXRpb25zLCB0cnVlKSB9KTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBsaXN0IG9mIGZyYWdtZW50IGRlZmluaXRpb25zIGFuZCBtYWtlcyBhIGhhc2ggb3V0IG9mIHRoZW1cbi8vIHRoYXQgbWFwcyB0aGUgbmFtZSBvZiB0aGUgZnJhZ21lbnQgdG8gdGhlIGZyYWdtZW50IGRlZmluaXRpb24uXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRNYXAoZnJhZ21lbnRzKSB7XG4gICAgaWYgKGZyYWdtZW50cyA9PT0gdm9pZCAwKSB7IGZyYWdtZW50cyA9IFtdOyB9XG4gICAgdmFyIHN5bVRhYmxlID0ge307XG4gICAgZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIHN5bVRhYmxlW2ZyYWdtZW50Lm5hbWUudmFsdWVdID0gZnJhZ21lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN5bVRhYmxlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbihzZWxlY3Rpb24sIGZyYWdtZW50TWFwKSB7XG4gICAgc3dpdGNoIChzZWxlY3Rpb24ua2luZCkge1xuICAgICAgICBjYXNlIFwiSW5saW5lRnJhZ21lbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgICAgIGNhc2UgXCJGcmFnbWVudFNwcmVhZFwiOiB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnROYW1lID0gc2VsZWN0aW9uLm5hbWUudmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyYWdtZW50TWFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRNYXAoZnJhZ21lbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGZyYWdtZW50TWFwICYmIGZyYWdtZW50TWFwW2ZyYWdtZW50TmFtZV07XG4gICAgICAgICAgICBpbnZhcmlhbnQoZnJhZ21lbnQsIDg3LCBmcmFnbWVudE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGx5VW5tYXNrZWRPcGVyYXRpb24oZG9jdW1lbnQpIHtcbiAgICB2YXIgaXNVbm1hc2tlZCA9IHRydWU7XG4gICAgdmlzaXQoZG9jdW1lbnQsIHtcbiAgICAgICAgRnJhZ21lbnRTcHJlYWQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpc1VubWFza2VkID1cbiAgICAgICAgICAgICAgICAhIW5vZGUuZGlyZWN0aXZlcyAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gXCJ1bm1hc2tcIjsgfSk7XG4gICAgICAgICAgICBpZiAoIWlzVW5tYXNrZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzVW5tYXNrZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/getFromAST.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkDocument: () => (/* binding */ checkDocument),\n/* harmony export */   getDefaultValues: () => (/* binding */ getDefaultValues),\n/* harmony export */   getFragmentDefinition: () => (/* binding */ getFragmentDefinition),\n/* harmony export */   getFragmentDefinitions: () => (/* binding */ getFragmentDefinitions),\n/* harmony export */   getMainDefinition: () => (/* binding */ getMainDefinition),\n/* harmony export */   getOperationDefinition: () => (/* binding */ getOperationDefinition),\n/* harmony export */   getOperationName: () => (/* binding */ getOperationName),\n/* harmony export */   getQueryDefinition: () => (/* binding */ getQueryDefinition)\n/* harmony export */ });\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _storeUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storeUtils.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\");\n\n\n// Checks the document for errors and throws an exception if there is an error.\nfunction checkDocument(doc) {\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc && doc.kind === \"Document\", 88);\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== \"FragmentDefinition\"; })\n        .map(function (definition) {\n        if (definition.kind !== \"OperationDefinition\") {\n            throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(89, definition.kind);\n        }\n        return definition;\n    });\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(operations.length <= 1, 90, operations.length);\n    return doc;\n}\nfunction getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) {\n        return definition.kind === \"OperationDefinition\";\n    })[0];\n}\nfunction getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === \"OperationDefinition\" && !!definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\n// Returns the FragmentDefinitions from a particular document as an array\nfunction getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) {\n        return definition.kind === \"FragmentDefinition\";\n    });\n}\nfunction getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(queryDef && queryDef.operation === \"query\", 91);\n    return queryDef;\n}\nfunction getFragmentDefinition(doc) {\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc.kind === \"Document\", 92);\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(doc.definitions.length <= 1, 93);\n    var fragmentDef = doc.definitions[0];\n    (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.invariant)(fragmentDef.kind === \"FragmentDefinition\", 94);\n    return fragmentDef;\n}\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nfunction getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === \"OperationDefinition\") {\n            var operation = definition.operation;\n            if (operation === \"query\" ||\n                operation === \"mutation\" ||\n                operation === \"subscription\") {\n                return definition;\n            }\n        }\n        if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n            // we do this because we want to allow multiple fragment definitions\n            // to precede an operation definition.\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(95);\n}\nfunction getDefaultValues(definition) {\n    var defaultValues = Object.create(null);\n    var defs = definition && definition.variableDefinitions;\n    if (defs && defs.length) {\n        defs.forEach(function (def) {\n            if (def.defaultValue) {\n                (0,_storeUtils_js__WEBPACK_IMPORTED_MODULE_1__.valueToObjectRepresentation)(defaultValues, def.variable.name, def.defaultValue);\n            }\n        });\n    }\n    return defaultValues;\n}\n//# sourceMappingURL=getFromAST.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9nZXRGcm9tQVNULmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBbUU7QUFDTDtBQUM5RDtBQUNPO0FBQ1AsSUFBSSw0REFBUztBQUNiO0FBQ0EsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0Esa0JBQWtCLG9FQUFpQjtBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNERBQVM7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0EsSUFBSSw0REFBUztBQUNiO0FBQ0E7QUFDTztBQUNQLElBQUksNERBQVM7QUFDYixJQUFJLDREQUFTO0FBQ2I7QUFDQSxJQUFJLDREQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0VBQWlCO0FBQzNCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJFQUEyQjtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAYXBvbGxvXFxjbGllbnRcXHV0aWxpdGllc1xcZ3JhcGhxbFxcZ2V0RnJvbUFTVC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnZhcmlhbnQsIG5ld0ludmFyaWFudEVycm9yIH0gZnJvbSBcIi4uL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbiB9IGZyb20gXCIuL3N0b3JlVXRpbHMuanNcIjtcbi8vIENoZWNrcyB0aGUgZG9jdW1lbnQgZm9yIGVycm9ycyBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbiBlcnJvci5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RvY3VtZW50KGRvYykge1xuICAgIGludmFyaWFudChkb2MgJiYgZG9jLmtpbmQgPT09IFwiRG9jdW1lbnRcIiwgODgpO1xuICAgIHZhciBvcGVyYXRpb25zID0gZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2luZCAhPT0gXCJGcmFnbWVudERlZmluaXRpb25cIjsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kICE9PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3SW52YXJpYW50RXJyb3IoODksIGRlZmluaXRpb24ua2luZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfSk7XG4gICAgaW52YXJpYW50KG9wZXJhdGlvbnMubGVuZ3RoIDw9IDEsIDkwLCBvcGVyYXRpb25zLmxlbmd0aCk7XG4gICAgcmV0dXJuIGRvYztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25EZWZpbml0aW9uKGRvYykge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jKTtcbiAgICByZXR1cm4gZG9jLmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIjtcbiAgICB9KVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25OYW1lKGRvYykge1xuICAgIHJldHVybiAoZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gXCJPcGVyYXRpb25EZWZpbml0aW9uXCIgJiYgISFkZWZpbml0aW9uLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5uYW1lLnZhbHVlOyB9KVswXSB8fCBudWxsKTtcbn1cbi8vIFJldHVybnMgdGhlIEZyYWdtZW50RGVmaW5pdGlvbnMgZnJvbSBhIHBhcnRpY3VsYXIgZG9jdW1lbnQgYXMgYW4gYXJyYXlcbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudERlZmluaXRpb25zKGRvYykge1xuICAgIHJldHVybiBkb2MuZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLmtpbmQgPT09IFwiRnJhZ21lbnREZWZpbml0aW9uXCI7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlEZWZpbml0aW9uKGRvYykge1xuICAgIHZhciBxdWVyeURlZiA9IGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jKTtcbiAgICBpbnZhcmlhbnQocXVlcnlEZWYgJiYgcXVlcnlEZWYub3BlcmF0aW9uID09PSBcInF1ZXJ5XCIsIDkxKTtcbiAgICByZXR1cm4gcXVlcnlEZWY7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnREZWZpbml0aW9uKGRvYykge1xuICAgIGludmFyaWFudChkb2Mua2luZCA9PT0gXCJEb2N1bWVudFwiLCA5Mik7XG4gICAgaW52YXJpYW50KGRvYy5kZWZpbml0aW9ucy5sZW5ndGggPD0gMSwgOTMpO1xuICAgIHZhciBmcmFnbWVudERlZiA9IGRvYy5kZWZpbml0aW9uc1swXTtcbiAgICBpbnZhcmlhbnQoZnJhZ21lbnREZWYua2luZCA9PT0gXCJGcmFnbWVudERlZmluaXRpb25cIiwgOTQpO1xuICAgIHJldHVybiBmcmFnbWVudERlZjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgb3BlcmF0aW9uIGRlZmluaXRpb24gZm91bmQgaW4gdGhpcyBkb2N1bWVudC5cbiAqIElmIG5vIG9wZXJhdGlvbiBkZWZpbml0aW9uIGlzIGZvdW5kLCB0aGUgZmlyc3QgZnJhZ21lbnQgZGVmaW5pdGlvbiB3aWxsIGJlIHJldHVybmVkLlxuICogSWYgbm8gZGVmaW5pdGlvbnMgYXJlIGZvdW5kLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1haW5EZWZpbml0aW9uKHF1ZXJ5RG9jKSB7XG4gICAgY2hlY2tEb2N1bWVudChxdWVyeURvYyk7XG4gICAgdmFyIGZyYWdtZW50RGVmaW5pdGlvbjtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcXVlcnlEb2MuZGVmaW5pdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0gX2FbX2ldO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIikge1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGRlZmluaXRpb24ub3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gXCJxdWVyeVwiIHx8XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID09PSBcIm11dGF0aW9uXCIgfHxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPT09IFwic3Vic2NyaXB0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSBcIkZyYWdtZW50RGVmaW5pdGlvblwiICYmICFmcmFnbWVudERlZmluaXRpb24pIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIHRoaXMgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IG11bHRpcGxlIGZyYWdtZW50IGRlZmluaXRpb25zXG4gICAgICAgICAgICAvLyB0byBwcmVjZWRlIGFuIG9wZXJhdGlvbiBkZWZpbml0aW9uLlxuICAgICAgICAgICAgZnJhZ21lbnREZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnREZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudERlZmluaXRpb247XG4gICAgfVxuICAgIHRocm93IG5ld0ludmFyaWFudEVycm9yKDk1KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWVzKGRlZmluaXRpb24pIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGRlZnMgPSBkZWZpbml0aW9uICYmIGRlZmluaXRpb24udmFyaWFibGVEZWZpbml0aW9ucztcbiAgICBpZiAoZGVmcyAmJiBkZWZzLmxlbmd0aCkge1xuICAgICAgICBkZWZzLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgaWYgKGRlZi5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oZGVmYXVsdFZhbHVlcywgZGVmLnZhcmlhYmxlLm5hbWUsIGRlZi5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGcm9tQVNULmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/getFromAST.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/graphql/storeUtils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   argumentsObjectFromField: () => (/* binding */ argumentsObjectFromField),\n/* harmony export */   getStoreKeyName: () => (/* binding */ getStoreKeyName),\n/* harmony export */   getTypenameFromResult: () => (/* binding */ getTypenameFromResult),\n/* harmony export */   isDocumentNode: () => (/* binding */ isDocumentNode),\n/* harmony export */   isField: () => (/* binding */ isField),\n/* harmony export */   isInlineFragment: () => (/* binding */ isInlineFragment),\n/* harmony export */   isReference: () => (/* binding */ isReference),\n/* harmony export */   makeReference: () => (/* binding */ makeReference),\n/* harmony export */   resultKeyNameFromField: () => (/* binding */ resultKeyNameFromField),\n/* harmony export */   storeKeyNameFromField: () => (/* binding */ storeKeyNameFromField),\n/* harmony export */   valueToObjectRepresentation: () => (/* binding */ valueToObjectRepresentation)\n/* harmony export */ });\n/* harmony import */ var _globals_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globals/index.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/globals/index.js\");\n/* harmony import */ var _common_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/objects.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/objects.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragments.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/fragments.js\");\n/* harmony import */ var _common_canonicalStringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/canonicalStringify.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canonicalStringify.js\");\n\n\n\n\nfunction makeReference(id) {\n    return { __ref: String(id) };\n}\nfunction isReference(obj) {\n    return Boolean(obj && typeof obj === \"object\" && typeof obj.__ref === \"string\");\n}\nfunction isDocumentNode(value) {\n    return ((0,_common_objects_js__WEBPACK_IMPORTED_MODULE_1__.isNonNullObject)(value) &&\n        value.kind === \"Document\" &&\n        Array.isArray(value.definitions));\n}\nfunction isStringValue(value) {\n    return value.kind === \"StringValue\";\n}\nfunction isBooleanValue(value) {\n    return value.kind === \"BooleanValue\";\n}\nfunction isIntValue(value) {\n    return value.kind === \"IntValue\";\n}\nfunction isFloatValue(value) {\n    return value.kind === \"FloatValue\";\n}\nfunction isVariable(value) {\n    return value.kind === \"Variable\";\n}\nfunction isObjectValue(value) {\n    return value.kind === \"ObjectValue\";\n}\nfunction isListValue(value) {\n    return value.kind === \"ListValue\";\n}\nfunction isEnumValue(value) {\n    return value.kind === \"EnumValue\";\n}\nfunction isNullValue(value) {\n    return value.kind === \"NullValue\";\n}\nfunction valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    }\n    else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function (obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    }\n    else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    }\n    else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function (listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    }\n    else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    }\n    else {\n        throw (0,_globals_index_js__WEBPACK_IMPORTED_MODULE_0__.newInvariantError)(96, name.value, value.kind);\n    }\n}\nfunction storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function (directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    \"connection\",\n    \"include\",\n    \"skip\",\n    \"client\",\n    \"rest\",\n    \"export\",\n    \"nonreactive\",\n];\n// Default stable JSON.stringify implementation used by getStoreKeyName. Can be\n// updated/replaced with something better by calling\n// getStoreKeyName.setStringify(newStringifyFunction).\nvar storeKeyNameStringify = _common_canonicalStringify_js__WEBPACK_IMPORTED_MODULE_2__.canonicalStringify;\nvar getStoreKeyName = Object.assign(function (fieldName, args, directives) {\n    if (args &&\n        directives &&\n        directives[\"connection\"] &&\n        directives[\"connection\"][\"key\"]) {\n        if (directives[\"connection\"][\"filter\"] &&\n            directives[\"connection\"][\"filter\"].length > 0) {\n            var filterKeys = directives[\"connection\"][\"filter\"] ?\n                directives[\"connection\"][\"filter\"]\n                : [];\n            filterKeys.sort();\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function (key) {\n                filteredArgs_1[key] = args[key];\n            });\n            return \"\".concat(directives[\"connection\"][\"key\"], \"(\").concat(storeKeyNameStringify(filteredArgs_1), \")\");\n        }\n        else {\n            return directives[\"connection\"][\"key\"];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        // We can't use `JSON.stringify` here since it's non-deterministic,\n        // and can lead to different store key names being created even though\n        // the `args` object used during creation has the same properties/values.\n        var stringifiedArgs = storeKeyNameStringify(args);\n        completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function (key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)\n                return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\".concat(key, \"(\").concat(storeKeyNameStringify(directives[key]), \")\");\n            }\n            else {\n                completeFieldName += \"@\".concat(key);\n            }\n        });\n    }\n    return completeFieldName;\n}, {\n    setStringify: function (s) {\n        var previous = storeKeyNameStringify;\n        storeKeyNameStringify = s;\n        return previous;\n    },\n});\nfunction argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nfunction resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nfunction getTypenameFromResult(result, selectionSet, fragmentMap) {\n    var fragments;\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n        var selection = _a[_i];\n        if (isField(selection)) {\n            if (selection.name.value === \"__typename\") {\n                return result[resultKeyNameFromField(selection)];\n            }\n        }\n        else if (fragments) {\n            fragments.push(selection);\n        }\n        else {\n            fragments = [selection];\n        }\n    }\n    if (typeof result.__typename === \"string\") {\n        return result.__typename;\n    }\n    if (fragments) {\n        for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {\n            var selection = fragments_1[_b];\n            var typename = getTypenameFromResult(result, (0,_fragments_js__WEBPACK_IMPORTED_MODULE_3__.getFragmentFromSelection)(selection, fragmentMap).selectionSet, fragmentMap);\n            if (typeof typename === \"string\") {\n                return typename;\n            }\n        }\n    }\n}\nfunction isField(selection) {\n    return selection.kind === \"Field\";\n}\nfunction isInlineFragment(selection) {\n    return selection.kind === \"InlineFragment\";\n}\n//# sourceMappingURL=storeUtils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvZ3JhcGhxbC9zdG9yZVV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNEO0FBQ0c7QUFDVztBQUM5RDtBQUNQLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsWUFBWSxtRUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvRUFBaUI7QUFDL0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2RUFBa0I7QUFDdkM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5QkFBeUI7QUFDM0U7QUFDQSx5REFBeUQsdUVBQXdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBhcG9sbG9cXGNsaWVudFxcdXRpbGl0aWVzXFxncmFwaHFsXFxzdG9yZVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5ld0ludmFyaWFudEVycm9yIH0gZnJvbSBcIi4uL2dsb2JhbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzTm9uTnVsbE9iamVjdCB9IGZyb20gXCIuLi9jb21tb24vb2JqZWN0cy5qc1wiO1xuaW1wb3J0IHsgZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBjYW5vbmljYWxTdHJpbmdpZnkgfSBmcm9tIFwiLi4vY29tbW9uL2Nhbm9uaWNhbFN0cmluZ2lmeS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZWZlcmVuY2UoaWQpIHtcbiAgICByZXR1cm4geyBfX3JlZjogU3RyaW5nKGlkKSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlKG9iaikge1xuICAgIHJldHVybiBCb29sZWFuKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmouX19yZWYgPT09IFwic3RyaW5nXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRG9jdW1lbnROb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc05vbk51bGxPYmplY3QodmFsdWUpICYmXG4gICAgICAgIHZhbHVlLmtpbmQgPT09IFwiRG9jdW1lbnRcIiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlLmRlZmluaXRpb25zKSk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09IFwiU3RyaW5nVmFsdWVcIjtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09IFwiQm9vbGVhblZhbHVlXCI7XG59XG5mdW5jdGlvbiBpc0ludFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09IFwiSW50VmFsdWVcIjtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSBcIkZsb2F0VmFsdWVcIjtcbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gXCJWYXJpYWJsZVwiO1xufVxuZnVuY3Rpb24gaXNPYmplY3RWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSBcIk9iamVjdFZhbHVlXCI7XG59XG5mdW5jdGlvbiBpc0xpc3RWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSBcIkxpc3RWYWx1ZVwiO1xufVxuZnVuY3Rpb24gaXNFbnVtVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gXCJFbnVtVmFsdWVcIjtcbn1cbmZ1bmN0aW9uIGlzTnVsbFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09IFwiTnVsbFZhbHVlXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGFyZ09iaiwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcykge1xuICAgIGlmIChpc0ludFZhbHVlKHZhbHVlKSB8fCBpc0Zsb2F0VmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IE51bWJlcih2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQm9vbGVhblZhbHVlKHZhbHVlKSB8fCBpc1N0cmluZ1ZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3RWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG5lc3RlZEFyZ09ial8xID0ge307XG4gICAgICAgIHZhbHVlLmZpZWxkcy5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihuZXN0ZWRBcmdPYmpfMSwgb2JqLm5hbWUsIG9iai52YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IG5lc3RlZEFyZ09ial8xO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZhcmlhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YXIgdmFyaWFibGVWYWx1ZSA9ICh2YXJpYWJsZXMgfHwge30pW3ZhbHVlLm5hbWUudmFsdWVdO1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YXJpYWJsZVZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0xpc3RWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gdmFsdWUudmFsdWVzLm1hcChmdW5jdGlvbiAobGlzdFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkQXJnQXJyYXlPYmogPSB7fTtcbiAgICAgICAgICAgIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihuZXN0ZWRBcmdBcnJheU9iaiwgbmFtZSwgbGlzdFZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5lc3RlZEFyZ0FycmF5T2JqW25hbWUudmFsdWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFbnVtVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc051bGxWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ld0ludmFyaWFudEVycm9yKDk2LCBuYW1lLnZhbHVlLCB2YWx1ZS5raW5kKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3RvcmVLZXlOYW1lRnJvbUZpZWxkKGZpZWxkLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgZGlyZWN0aXZlc09iaiA9IG51bGw7XG4gICAgaWYgKGZpZWxkLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgZGlyZWN0aXZlc09iaiA9IHt9O1xuICAgICAgICBmaWVsZC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgZGlyZWN0aXZlc09ialtkaXJlY3RpdmUubmFtZS52YWx1ZV0gPSB7fTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oZGlyZWN0aXZlc09ialtkaXJlY3RpdmUubmFtZS52YWx1ZV0sIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGFyZ09iaiA9IG51bGw7XG4gICAgaWYgKGZpZWxkLmFyZ3VtZW50cyAmJiBmaWVsZC5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGFyZ09iaiA9IHt9O1xuICAgICAgICBmaWVsZC5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oYXJnT2JqLCBuYW1lLCB2YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdG9yZUtleU5hbWUoZmllbGQubmFtZS52YWx1ZSwgYXJnT2JqLCBkaXJlY3RpdmVzT2JqKTtcbn1cbnZhciBLTk9XTl9ESVJFQ1RJVkVTID0gW1xuICAgIFwiY29ubmVjdGlvblwiLFxuICAgIFwiaW5jbHVkZVwiLFxuICAgIFwic2tpcFwiLFxuICAgIFwiY2xpZW50XCIsXG4gICAgXCJyZXN0XCIsXG4gICAgXCJleHBvcnRcIixcbiAgICBcIm5vbnJlYWN0aXZlXCIsXG5dO1xuLy8gRGVmYXVsdCBzdGFibGUgSlNPTi5zdHJpbmdpZnkgaW1wbGVtZW50YXRpb24gdXNlZCBieSBnZXRTdG9yZUtleU5hbWUuIENhbiBiZVxuLy8gdXBkYXRlZC9yZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBiZXR0ZXIgYnkgY2FsbGluZ1xuLy8gZ2V0U3RvcmVLZXlOYW1lLnNldFN0cmluZ2lmeShuZXdTdHJpbmdpZnlGdW5jdGlvbikuXG52YXIgc3RvcmVLZXlOYW1lU3RyaW5naWZ5ID0gY2Fub25pY2FsU3RyaW5naWZ5O1xuZXhwb3J0IHZhciBnZXRTdG9yZUtleU5hbWUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChmaWVsZE5hbWUsIGFyZ3MsIGRpcmVjdGl2ZXMpIHtcbiAgICBpZiAoYXJncyAmJlxuICAgICAgICBkaXJlY3RpdmVzICYmXG4gICAgICAgIGRpcmVjdGl2ZXNbXCJjb25uZWN0aW9uXCJdICYmXG4gICAgICAgIGRpcmVjdGl2ZXNbXCJjb25uZWN0aW9uXCJdW1wia2V5XCJdKSB7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzW1wiY29ubmVjdGlvblwiXVtcImZpbHRlclwiXSAmJlxuICAgICAgICAgICAgZGlyZWN0aXZlc1tcImNvbm5lY3Rpb25cIl1bXCJmaWx0ZXJcIl0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcktleXMgPSBkaXJlY3RpdmVzW1wiY29ubmVjdGlvblwiXVtcImZpbHRlclwiXSA/XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlc1tcImNvbm5lY3Rpb25cIl1bXCJmaWx0ZXJcIl1cbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgZmlsdGVyS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRBcmdzXzEgPSB7fTtcbiAgICAgICAgICAgIGZpbHRlcktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRBcmdzXzFba2V5XSA9IGFyZ3Nba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGRpcmVjdGl2ZXNbXCJjb25uZWN0aW9uXCJdW1wia2V5XCJdLCBcIihcIikuY29uY2F0KHN0b3JlS2V5TmFtZVN0cmluZ2lmeShmaWx0ZXJlZEFyZ3NfMSksIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJlY3RpdmVzW1wiY29ubmVjdGlvblwiXVtcImtleVwiXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29tcGxldGVGaWVsZE5hbWUgPSBmaWVsZE5hbWU7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIGBKU09OLnN0cmluZ2lmeWAgaGVyZSBzaW5jZSBpdCdzIG5vbi1kZXRlcm1pbmlzdGljLFxuICAgICAgICAvLyBhbmQgY2FuIGxlYWQgdG8gZGlmZmVyZW50IHN0b3JlIGtleSBuYW1lcyBiZWluZyBjcmVhdGVkIGV2ZW4gdGhvdWdoXG4gICAgICAgIC8vIHRoZSBgYXJnc2Agb2JqZWN0IHVzZWQgZHVyaW5nIGNyZWF0aW9uIGhhcyB0aGUgc2FtZSBwcm9wZXJ0aWVzL3ZhbHVlcy5cbiAgICAgICAgdmFyIHN0cmluZ2lmaWVkQXJncyA9IHN0b3JlS2V5TmFtZVN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCIoXCIuY29uY2F0KHN0cmluZ2lmaWVkQXJncywgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aXZlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChLTk9XTl9ESVJFQ1RJVkVTLmluZGV4T2Yoa2V5KSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZXNba2V5XSAmJiBPYmplY3Qua2V5cyhkaXJlY3RpdmVzW2tleV0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlRmllbGROYW1lICs9IFwiQFwiLmNvbmNhdChrZXksIFwiKFwiKS5jb25jYXQoc3RvcmVLZXlOYW1lU3RyaW5naWZ5KGRpcmVjdGl2ZXNba2V5XSksIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlRmllbGROYW1lICs9IFwiQFwiLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBsZXRlRmllbGROYW1lO1xufSwge1xuICAgIHNldFN0cmluZ2lmeTogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gc3RvcmVLZXlOYW1lU3RyaW5naWZ5O1xuICAgICAgICBzdG9yZUtleU5hbWVTdHJpbmdpZnkgPSBzO1xuICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGFyZ3VtZW50c09iamVjdEZyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSB7XG4gICAgaWYgKGZpZWxkLmFyZ3VtZW50cyAmJiBmaWVsZC5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcmdPYmpfMSA9IHt9O1xuICAgICAgICBmaWVsZC5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24oYXJnT2JqXzEsIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFyZ09ial8xO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKSB7XG4gICAgcmV0dXJuIGZpZWxkLmFsaWFzID8gZmllbGQuYWxpYXMudmFsdWUgOiBmaWVsZC5uYW1lLnZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVuYW1lRnJvbVJlc3VsdChyZXN1bHQsIHNlbGVjdGlvblNldCwgZnJhZ21lbnRNYXApIHtcbiAgICB2YXIgZnJhZ21lbnRzO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzZWxlY3Rpb25TZXQuc2VsZWN0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hW19pXTtcbiAgICAgICAgaWYgKGlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5uYW1lLnZhbHVlID09PSBcIl9fdHlwZW5hbWVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbcmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcmFnbWVudHMgPSBbc2VsZWN0aW9uXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdC5fX3R5cGVuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuX190eXBlbmFtZTtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50cykge1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIGZyYWdtZW50c18xID0gZnJhZ21lbnRzOyBfYiA8IGZyYWdtZW50c18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGZyYWdtZW50c18xW19iXTtcbiAgICAgICAgICAgIHZhciB0eXBlbmFtZSA9IGdldFR5cGVuYW1lRnJvbVJlc3VsdChyZXN1bHQsIGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbihzZWxlY3Rpb24sIGZyYWdtZW50TWFwKS5zZWxlY3Rpb25TZXQsIGZyYWdtZW50TWFwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZW5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGaWVsZChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uLmtpbmQgPT09IFwiRmllbGRcIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0lubGluZUZyYWdtZW50KHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzZWxlY3Rpb24ua2luZCA9PT0gXCJJbmxpbmVGcmFnbWVudFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RvcmVVdGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/graphql/storeUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/iteration.js":
/*!************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/iteration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iterateObserversSafely: () => (/* binding */ iterateObserversSafely)\n/* harmony export */ });\nfunction iterateObserversSafely(observers, method, argument) {\n    // In case observers is modified during iteration, we need to commit to the\n    // original elements, which also provides an opportunity to filter them down\n    // to just the observers with the given method.\n    var observersWithMethod = [];\n    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });\n    observersWithMethod.forEach(function (obs) { return obs[method](argument); });\n}\n//# sourceMappingURL=iteration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvaXRlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNEQUFzRDtBQUM3RixpREFBaUQsK0JBQStCO0FBQ2hGO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGFwb2xsb1xcY2xpZW50XFx1dGlsaXRpZXNcXG9ic2VydmFibGVzXFxpdGVyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkob2JzZXJ2ZXJzLCBtZXRob2QsIGFyZ3VtZW50KSB7XG4gICAgLy8gSW4gY2FzZSBvYnNlcnZlcnMgaXMgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbiwgd2UgbmVlZCB0byBjb21taXQgdG8gdGhlXG4gICAgLy8gb3JpZ2luYWwgZWxlbWVudHMsIHdoaWNoIGFsc28gcHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gZmlsdGVyIHRoZW0gZG93blxuICAgIC8vIHRvIGp1c3QgdGhlIG9ic2VydmVycyB3aXRoIHRoZSBnaXZlbiBtZXRob2QuXG4gICAgdmFyIG9ic2VydmVyc1dpdGhNZXRob2QgPSBbXTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnNbbWV0aG9kXSAmJiBvYnNlcnZlcnNXaXRoTWV0aG9kLnB1c2gob2JzKTsgfSk7XG4gICAgb2JzZXJ2ZXJzV2l0aE1ldGhvZC5mb3JFYWNoKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9ic1ttZXRob2RdKGFyZ3VtZW50KTsgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/iteration.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/subclassing.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/observables/subclassing.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixObservableSubclass: () => (/* binding */ fixObservableSubclass)\n/* harmony export */ });\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observable.js */ \"(app-pages-browser)/./node_modules/zen-observable-ts/module.js\");\n/* harmony import */ var _common_canUse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/canUse.js */ \"(app-pages-browser)/./node_modules/@apollo/client/utilities/common/canUse.js\");\n\n\n// Generic implementations of Observable.prototype methods like map and\n// filter need to know how to create a new Observable from an Observable\n// subclass (like Concast or ObservableQuery). Those methods assume\n// (perhaps unwisely?) that they can call the subtype's constructor with a\n// Subscriber function, even though the subclass constructor might expect\n// different parameters. Defining this static Symbol.species property on\n// the subclass is a hint to generic Observable code to use the default\n// constructor instead of trying to do `new Subclass(observer => ...)`.\nfunction fixObservableSubclass(subclass) {\n    function set(key) {\n        // Object.defineProperty is necessary because the Symbol.species\n        // property is a getter by default in modern JS environments, so we\n        // can't assign to it with a normal assignment expression.\n        Object.defineProperty(subclass, key, { value: _Observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable });\n    }\n    if (_common_canUse_js__WEBPACK_IMPORTED_MODULE_1__.canUseSymbol && Symbol.species) {\n        set(Symbol.species);\n    }\n    // The \"@@species\" string is used as a fake Symbol.species value in some\n    // polyfill systems (including the SymbolSpecies variable used by\n    // zen-observable), so we should set it as well, to be safe.\n    set(\"@@species\");\n    return subclass;\n}\n//# sourceMappingURL=subclassing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvb2JzZXJ2YWJsZXMvc3ViY2xhc3NpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ007QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTyxzREFBVSxFQUFFO0FBQ2xFO0FBQ0EsUUFBUSwyREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGFwb2xsb1xcY2xpZW50XFx1dGlsaXRpZXNcXG9ic2VydmFibGVzXFxzdWJjbGFzc2luZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcIi4vT2JzZXJ2YWJsZS5qc1wiO1xuaW1wb3J0IHsgY2FuVXNlU3ltYm9sIH0gZnJvbSBcIi4uL2NvbW1vbi9jYW5Vc2UuanNcIjtcbi8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25zIG9mIE9ic2VydmFibGUucHJvdG90eXBlIG1ldGhvZHMgbGlrZSBtYXAgYW5kXG4vLyBmaWx0ZXIgbmVlZCB0byBrbm93IGhvdyB0byBjcmVhdGUgYSBuZXcgT2JzZXJ2YWJsZSBmcm9tIGFuIE9ic2VydmFibGVcbi8vIHN1YmNsYXNzIChsaWtlIENvbmNhc3Qgb3IgT2JzZXJ2YWJsZVF1ZXJ5KS4gVGhvc2UgbWV0aG9kcyBhc3N1bWVcbi8vIChwZXJoYXBzIHVud2lzZWx5PykgdGhhdCB0aGV5IGNhbiBjYWxsIHRoZSBzdWJ0eXBlJ3MgY29uc3RydWN0b3Igd2l0aCBhXG4vLyBTdWJzY3JpYmVyIGZ1bmN0aW9uLCBldmVuIHRob3VnaCB0aGUgc3ViY2xhc3MgY29uc3RydWN0b3IgbWlnaHQgZXhwZWN0XG4vLyBkaWZmZXJlbnQgcGFyYW1ldGVycy4gRGVmaW5pbmcgdGhpcyBzdGF0aWMgU3ltYm9sLnNwZWNpZXMgcHJvcGVydHkgb25cbi8vIHRoZSBzdWJjbGFzcyBpcyBhIGhpbnQgdG8gZ2VuZXJpYyBPYnNlcnZhYmxlIGNvZGUgdG8gdXNlIHRoZSBkZWZhdWx0XG4vLyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRyeWluZyB0byBkbyBgbmV3IFN1YmNsYXNzKG9ic2VydmVyID0+IC4uLilgLlxuZXhwb3J0IGZ1bmN0aW9uIGZpeE9ic2VydmFibGVTdWJjbGFzcyhzdWJjbGFzcykge1xuICAgIGZ1bmN0aW9uIHNldChrZXkpIHtcbiAgICAgICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBTeW1ib2wuc3BlY2llc1xuICAgICAgICAvLyBwcm9wZXJ0eSBpcyBhIGdldHRlciBieSBkZWZhdWx0IGluIG1vZGVybiBKUyBlbnZpcm9ubWVudHMsIHNvIHdlXG4gICAgICAgIC8vIGNhbid0IGFzc2lnbiB0byBpdCB3aXRoIGEgbm9ybWFsIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YmNsYXNzLCBrZXksIHsgdmFsdWU6IE9ic2VydmFibGUgfSk7XG4gICAgfVxuICAgIGlmIChjYW5Vc2VTeW1ib2wgJiYgU3ltYm9sLnNwZWNpZXMpIHtcbiAgICAgICAgc2V0KFN5bWJvbC5zcGVjaWVzKTtcbiAgICB9XG4gICAgLy8gVGhlIFwiQEBzcGVjaWVzXCIgc3RyaW5nIGlzIHVzZWQgYXMgYSBmYWtlIFN5bWJvbC5zcGVjaWVzIHZhbHVlIGluIHNvbWVcbiAgICAvLyBwb2x5ZmlsbCBzeXN0ZW1zIChpbmNsdWRpbmcgdGhlIFN5bWJvbFNwZWNpZXMgdmFyaWFibGUgdXNlZCBieVxuICAgIC8vIHplbi1vYnNlcnZhYmxlKSwgc28gd2Ugc2hvdWxkIHNldCBpdCBhcyB3ZWxsLCB0byBiZSBzYWZlLlxuICAgIHNldChcIkBAc3BlY2llc1wiKTtcbiAgICByZXR1cm4gc3ViY2xhc3M7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjbGFzc2luZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/observables/subclassing.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@apollo/client/utilities/promises/preventUnhandledRejection.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/promises/preventUnhandledRejection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   preventUnhandledRejection: () => (/* binding */ preventUnhandledRejection)\n/* harmony export */ });\nfunction preventUnhandledRejection(promise) {\n    promise.catch(function () { });\n    return promise;\n}\n//# sourceMappingURL=preventUnhandledRejection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC91dGlsaXRpZXMvcHJvbWlzZXMvcHJldmVudFVuaGFuZGxlZFJlamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBhcG9sbG9cXGNsaWVudFxcdXRpbGl0aWVzXFxwcm9taXNlc1xccHJldmVudFVuaGFuZGxlZFJlamVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcHJldmVudFVuaGFuZGxlZFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJldmVudFVuaGFuZGxlZFJlamVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@apollo/client/utilities/promises/preventUnhandledRejection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/context/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@wry/context/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Slot: () => (/* reexport safe */ _slot_js__WEBPACK_IMPORTED_MODULE_0__.Slot),\n/* harmony export */   asyncFromGen: () => (/* binding */ asyncFromGen),\n/* harmony export */   bind: () => (/* binding */ bind),\n/* harmony export */   noContext: () => (/* binding */ noContext),\n/* harmony export */   setTimeout: () => (/* binding */ setTimeoutWithContext),\n/* harmony export */   wrapYieldingFiberMethods: () => (/* binding */ wrapYieldingFiberMethods)\n/* harmony export */ });\n/* harmony import */ var _slot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slot.js */ \"(app-pages-browser)/./node_modules/@wry/context/lib/slot.js\");\n\n\nconst { bind, noContext } = _slot_js__WEBPACK_IMPORTED_MODULE_0__.Slot;\n// Like global.setTimeout, except the callback runs with captured context.\n\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nfunction asyncFromGen(genFn) {\n    return function () {\n        const gen = genFn.apply(this, arguments);\n        const boundNext = bind(gen.next);\n        const boundThrow = bind(gen.throw);\n        return new Promise((resolve, reject) => {\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                }\n                catch (error) {\n                    return reject(error);\n                }\n                const next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                }\n                else {\n                    next(result.value);\n                }\n            }\n            const invokeNext = (value) => invoke(boundNext, value);\n            const invokeThrow = (error) => invoke(boundThrow, error);\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers = [];\nfunction wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        const wrap = (obj, method) => {\n            const fn = obj[method];\n            obj[method] = function () {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NvbnRleHQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDakI7QUFDVCxRQUFRLGtCQUFrQixFQUFFLDBDQUFJO0FBQ3ZDO0FBQytDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAd3J5XFxjb250ZXh0XFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsb3QgfSBmcm9tIFwiLi9zbG90LmpzXCI7XG5leHBvcnQgeyBTbG90IH07XG5leHBvcnQgY29uc3QgeyBiaW5kLCBub0NvbnRleHQgfSA9IFNsb3Q7XG4vLyBMaWtlIGdsb2JhbC5zZXRUaW1lb3V0LCBleGNlcHQgdGhlIGNhbGxiYWNrIHJ1bnMgd2l0aCBjYXB0dXJlZCBjb250ZXh0LlxuZXhwb3J0IHsgc2V0VGltZW91dFdpdGhDb250ZXh0IGFzIHNldFRpbWVvdXQgfTtcbmZ1bmN0aW9uIHNldFRpbWVvdXRXaXRoQ29udGV4dChjYWxsYmFjaywgZGVsYXkpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kKGNhbGxiYWNrKSwgZGVsYXkpO1xufVxuLy8gVHVybiBhbnkgZ2VuZXJhdG9yIGZ1bmN0aW9uIGludG8gYW4gYXN5bmMgZnVuY3Rpb24gKHVzaW5nIHlpZWxkIGluc3RlYWRcbi8vIG9mIGF3YWl0KSwgd2l0aCBjb250ZXh0IGF1dG9tYXRpY2FsbHkgcHJlc2VydmVkIGFjcm9zcyB5aWVsZHMuXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNGcm9tR2VuKGdlbkZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZ2VuID0gZ2VuRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc3QgYm91bmROZXh0ID0gYmluZChnZW4ubmV4dCk7XG4gICAgICAgIGNvbnN0IGJvdW5kVGhyb3cgPSBiaW5kKGdlbi50aHJvdyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBtZXRob2QuY2FsbChnZW4sIGFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcmVzdWx0LmRvbmUgPyByZXNvbHZlIDogaW52b2tlTmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShyZXN1bHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKG5leHQsIHJlc3VsdC5kb25lID8gcmVqZWN0IDogaW52b2tlVGhyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGludm9rZU5leHQgPSAodmFsdWUpID0+IGludm9rZShib3VuZE5leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGludm9rZVRocm93ID0gKGVycm9yKSA9PiBpbnZva2UoYm91bmRUaHJvdywgZXJyb3IpO1xuICAgICAgICAgICAgaW52b2tlTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuLy8gSWYgeW91IHVzZSB0aGUgZmliZXJzIG5wbSBwYWNrYWdlIHRvIGltcGxlbWVudCBjb3JvdXRpbmVzIGluIE5vZGUuanMsXG4vLyB5b3Ugc2hvdWxkIGNhbGwgdGhpcyBmdW5jdGlvbiBhdCBsZWFzdCBvbmNlIHRvIGVuc3VyZSBjb250ZXh0IG1hbmFnZW1lbnRcbi8vIHJlbWFpbnMgY29oZXJlbnQgYWNyb3NzIGFueSB5aWVsZHMuXG5jb25zdCB3cmFwcGVkRmliZXJzID0gW107XG5leHBvcnQgZnVuY3Rpb24gd3JhcFlpZWxkaW5nRmliZXJNZXRob2RzKEZpYmVyKSB7XG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGltcGxlbWVudGF0aW9uIG9mIEZpYmVyIHBlciBwcm9jZXNzLCBzbyB0aGlzIGFycmF5XG4gICAgLy8gc2hvdWxkIG5ldmVyIGdyb3cgbG9uZ2VyIHRoYW4gb25lIGVsZW1lbnQuXG4gICAgaWYgKHdyYXBwZWRGaWJlcnMuaW5kZXhPZihGaWJlcikgPCAwKSB7XG4gICAgICAgIGNvbnN0IHdyYXAgPSAob2JqLCBtZXRob2QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gb2JqW21ldGhvZF07XG4gICAgICAgICAgICBvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9Db250ZXh0KGZuLCBhcmd1bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlc2UgbWV0aG9kcyBjYW4geWllbGQsIGFjY29yZGluZyB0b1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGF2ZXJkZXQvbm9kZS1maWJlcnMvYmxvYi9kZGViZWQ5YjhhZTM4ODNlNTdmODIyZTIxMDhlNjk0M2U1YzhkMmE4L2ZpYmVycy5qcyNMOTctTDEwMFxuICAgICAgICB3cmFwKEZpYmVyLCBcInlpZWxkXCIpO1xuICAgICAgICB3cmFwKEZpYmVyLnByb3RvdHlwZSwgXCJydW5cIik7XG4gICAgICAgIHdyYXAoRmliZXIucHJvdG90eXBlLCBcInRocm93SW50b1wiKTtcbiAgICAgICAgd3JhcHBlZEZpYmVycy5wdXNoKEZpYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpYmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/context/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/context/lib/slot.js":
/*!***********************************************!*\
  !*** ./node_modules/@wry/context/lib/slot.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Slot: () => (/* binding */ Slot)\n/* harmony export */ });\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE = {};\nlet idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot {\n    constructor() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\n            \"slot\",\n            idCounter++,\n            Date.now(),\n            Math.random().toString(36).slice(2),\n        ].join(\":\");\n    }\n    hasValue() {\n        for (let context = currentContext; context; context = context.parent) {\n            // We use the Slot object iself as a key to its value, which means the\n            // value cannot be obtained without a reference to the Slot object.\n            if (this.id in context.slots) {\n                const value = context.slots[this.id];\n                if (value === MISSING_VALUE)\n                    break;\n                if (context !== currentContext) {\n                    // Cache the value in currentContext.slots so the next lookup will\n                    // be faster. This caching is safe because the tree of contexts and\n                    // the values of the slots are logically immutable.\n                    currentContext.slots[this.id] = value;\n                }\n                return true;\n            }\n        }\n        if (currentContext) {\n            // If a value was not found for this Slot, it's never going to be found\n            // no matter how many times we look it up, so we might as well cache\n            // the absence of the value, too.\n            currentContext.slots[this.id] = MISSING_VALUE;\n        }\n        return false;\n    }\n    getValue() {\n        if (this.hasValue()) {\n            return currentContext.slots[this.id];\n        }\n    }\n    withValue(value, callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        const slots = {\n            __proto__: null,\n            [this.id]: value,\n        };\n        const parent = currentContext;\n        currentContext = { parent, slots };\n        try {\n            // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n            return callback.apply(thisArg, args);\n        }\n        finally {\n            currentContext = parent;\n        }\n    }\n    // Capture the current context and wrap a callback function so that it\n    // reestablishes the captured context when called.\n    static bind(callback) {\n        const context = currentContext;\n        return function () {\n            const saved = currentContext;\n            try {\n                currentContext = context;\n                return callback.apply(this, arguments);\n            }\n            finally {\n                currentContext = saved;\n            }\n        };\n    }\n    // Immediately run a callback function without any captured context.\n    static noContext(callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        if (currentContext) {\n            const saved = currentContext;\n            try {\n                currentContext = null;\n                // Function.prototype.apply allows the arguments array argument to be\n                // omitted or undefined, so args! is fine here.\n                return callback.apply(thisArg, args);\n            }\n            finally {\n                currentContext = saved;\n            }\n        }\n        else {\n            return callback.apply(thisArg, args);\n        }\n    }\n};\nfunction maybe(fn) {\n    try {\n        return fn();\n    }\n    catch (ignored) { }\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = \n// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(() => globalThis) ||\n    // Fall back to global, which works in Node.js and may be converted by some\n    // bundlers to the appropriate identifier (window, self, ...) depending on the\n    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n    maybe(() => global) ||\n    // Otherwise, use a dummy host that's local to this module. We used to fall\n    // back to using the Array constructor as a namespace, but that was flagged in\n    // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n    Object.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost = host;\nconst Slot = globalHost[globalKey] ||\n    // Earlier versions of this package stored the globalKey property on the Array\n    // constructor, so we check there as well, to prevent Slot class duplication.\n    Array[globalKey] ||\n    (function (Slot) {\n        try {\n            Object.defineProperty(globalHost, globalKey, {\n                value: Slot,\n                enumerable: false,\n                writable: false,\n                // When it was possible for globalHost to be the Array constructor (a\n                // legacy Slot dedup strategy), it was important for the property to be\n                // configurable:true so it could be deleted. That does not seem to be as\n                // important when globalHost is the global object, but I don't want to\n                // cause similar problems again, and configurable:true seems safest.\n                // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n                configurable: true\n            });\n        }\n        finally {\n            return Slot;\n        }\n    })(makeSlotClass());\n//# sourceMappingURL=slot.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L2NvbnRleHQvbGliL3Nsb3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiRDpcXEVtcGxveWVlRGlyZWN0b3J5QXBwXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAd3J5XFxjb250ZXh0XFxsaWJcXHNsb3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBjdXJyZW50Q29udGV4dCB2YXJpYWJsZSB3aWxsIG9ubHkgYmUgdXNlZCBpZiB0aGUgbWFrZVNsb3RDbGFzc1xuLy8gZnVuY3Rpb24gaXMgY2FsbGVkLCB3aGljaCBoYXBwZW5zIG9ubHkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgY29weSBvZiB0aGVcbi8vIEB3cnkvY29udGV4dCBwYWNrYWdlIHRvIGJlIGltcG9ydGVkLlxubGV0IGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcbi8vIFRoaXMgdW5pcXVlIGludGVybmFsIG9iamVjdCBpcyB1c2VkIHRvIGRlbm90ZSB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlXG4vLyBmb3IgYSBnaXZlbiBTbG90LCBhbmQgaXMgbmV2ZXIgZXhwb3NlZCB0byBvdXRzaWRlIGNvZGUuXG5jb25zdCBNSVNTSU5HX1ZBTFVFID0ge307XG5sZXQgaWRDb3VudGVyID0gMTtcbi8vIEFsdGhvdWdoIHdlIGNhbid0IGRvIGFueXRoaW5nIGFib3V0IHRoZSBjb3N0IG9mIGR1cGxpY2F0ZWQgY29kZSBmcm9tXG4vLyBhY2NpZGVudGFsbHkgYnVuZGxpbmcgbXVsdGlwbGUgY29waWVzIG9mIHRoZSBAd3J5L2NvbnRleHQgcGFja2FnZSwgd2UgY2FuXG4vLyBhdm9pZCBjcmVhdGluZyB0aGUgU2xvdCBjbGFzcyBtb3JlIHRoYW4gb25jZSB1c2luZyBtYWtlU2xvdENsYXNzLlxuY29uc3QgbWFrZVNsb3RDbGFzcyA9ICgpID0+IGNsYXNzIFNsb3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBJZiB5b3UgaGF2ZSBhIFNsb3Qgb2JqZWN0LCB5b3UgY2FuIGZpbmQgb3V0IGl0cyBzbG90LmlkLCBidXQgeW91IGNhbm5vdFxuICAgICAgICAvLyBndWVzcyB0aGUgc2xvdC5pZCBvZiBhIFNsb3QgeW91IGRvbid0IGhhdmUgYWNjZXNzIHRvLCB0aGFua3MgdG8gdGhlXG4gICAgICAgIC8vIHJhbmRvbWl6ZWQgc3VmZml4LlxuICAgICAgICB0aGlzLmlkID0gW1xuICAgICAgICAgICAgXCJzbG90XCIsXG4gICAgICAgICAgICBpZENvdW50ZXIrKyxcbiAgICAgICAgICAgIERhdGUubm93KCksXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcbiAgICAgICAgXS5qb2luKFwiOlwiKTtcbiAgICB9XG4gICAgaGFzVmFsdWUoKSB7XG4gICAgICAgIGZvciAobGV0IGNvbnRleHQgPSBjdXJyZW50Q29udGV4dDsgY29udGV4dDsgY29udGV4dCA9IGNvbnRleHQucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhlIFNsb3Qgb2JqZWN0IGlzZWxmIGFzIGEga2V5IHRvIGl0cyB2YWx1ZSwgd2hpY2ggbWVhbnMgdGhlXG4gICAgICAgICAgICAvLyB2YWx1ZSBjYW5ub3QgYmUgb2J0YWluZWQgd2l0aG91dCBhIHJlZmVyZW5jZSB0byB0aGUgU2xvdCBvYmplY3QuXG4gICAgICAgICAgICBpZiAodGhpcy5pZCBpbiBjb250ZXh0LnNsb3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0LnNsb3RzW3RoaXMuaWRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTUlTU0lOR19WQUxVRSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgIT09IGN1cnJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSB2YWx1ZSBpbiBjdXJyZW50Q29udGV4dC5zbG90cyBzbyB0aGUgbmV4dCBsb29rdXAgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBmYXN0ZXIuIFRoaXMgY2FjaGluZyBpcyBzYWZlIGJlY2F1c2UgdGhlIHRyZWUgb2YgY29udGV4dHMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgb2YgdGhlIHNsb3RzIGFyZSBsb2dpY2FsbHkgaW1tdXRhYmxlLlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIElmIGEgdmFsdWUgd2FzIG5vdCBmb3VuZCBmb3IgdGhpcyBTbG90LCBpdCdzIG5ldmVyIGdvaW5nIHRvIGJlIGZvdW5kXG4gICAgICAgICAgICAvLyBubyBtYXR0ZXIgaG93IG1hbnkgdGltZXMgd2UgbG9vayBpdCB1cCwgc28gd2UgbWlnaHQgYXMgd2VsbCBjYWNoZVxuICAgICAgICAgICAgLy8gdGhlIGFic2VuY2Ugb2YgdGhlIHZhbHVlLCB0b28uXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dC5zbG90c1t0aGlzLmlkXSA9IE1JU1NJTkdfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0LnNsb3RzW3RoaXMuaWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhWYWx1ZSh2YWx1ZSwgY2FsbGJhY2ssIFxuICAgIC8vIEdpdmVuIHRoZSBwcmV2YWxlbmNlIG9mIGFycm93IGZ1bmN0aW9ucywgc3BlY2lmeWluZyBhcmd1bWVudHMgaXMgbGlrZWx5XG4gICAgLy8gdG8gYmUgbXVjaCBtb3JlIGNvbW1vbiB0aGFuIHNwZWNpZnlpbmcgYHRoaXNgLCBoZW5jZSB0aGlzIG9yZGVyaW5nOlxuICAgIGFyZ3MsIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3Qgc2xvdHMgPSB7XG4gICAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICAgICBbdGhpcy5pZF06IHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgY3VycmVudENvbnRleHQgPSB7IHBhcmVudCwgc2xvdHMgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSBhbGxvd3MgdGhlIGFyZ3VtZW50cyBhcnJheSBhcmd1bWVudCB0byBiZVxuICAgICAgICAgICAgLy8gb21pdHRlZCBvciB1bmRlZmluZWQsIHNvIGFyZ3MhIGlzIGZpbmUgaGVyZS5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhcHR1cmUgdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgd3JhcCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHNvIHRoYXQgaXRcbiAgICAvLyByZWVzdGFibGlzaGVzIHRoZSBjYXB0dXJlZCBjb250ZXh0IHdoZW4gY2FsbGVkLlxuICAgIHN0YXRpYyBiaW5kKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEltbWVkaWF0ZWx5IHJ1biBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhvdXQgYW55IGNhcHR1cmVkIGNvbnRleHQuXG4gICAgc3RhdGljIG5vQ29udGV4dChjYWxsYmFjaywgXG4gICAgLy8gR2l2ZW4gdGhlIHByZXZhbGVuY2Ugb2YgYXJyb3cgZnVuY3Rpb25zLCBzcGVjaWZ5aW5nIGFyZ3VtZW50cyBpcyBsaWtlbHlcbiAgICAvLyB0byBiZSBtdWNoIG1vcmUgY29tbW9uIHRoYW4gc3BlY2lmeWluZyBgdGhpc2AsIGhlbmNlIHRoaXMgb3JkZXJpbmc6XG4gICAgYXJncywgdGhpc0FyZykge1xuICAgICAgICBpZiAoY3VycmVudENvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkgYWxsb3dzIHRoZSBhcmd1bWVudHMgYXJyYXkgYXJndW1lbnQgdG8gYmVcbiAgICAgICAgICAgICAgICAvLyBvbWl0dGVkIG9yIHVuZGVmaW5lZCwgc28gYXJncyEgaXMgZmluZSBoZXJlLlxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gc2F2ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gbWF5YmUoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGlnbm9yZWQpIHsgfVxufVxuLy8gV2Ugc3RvcmUgYSBzaW5nbGUgZ2xvYmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBTbG90IGNsYXNzIGFzIGEgcGVybWFuZW50XG4vLyBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsVGhpcyBvYmplY3QuIFRoaXMgb2JmdXNjYXRpb24gZG9lc1xuLy8gbm90aGluZyB0byBwcmV2ZW50IGFjY2VzcyB0byB0aGUgU2xvdCBjbGFzcywgYnV0IGF0IGxlYXN0IGl0IGVuc3VyZXMgdGhlXG4vLyBpbXBsZW1lbnRhdGlvbiAoaS5lLiBjdXJyZW50Q29udGV4dCkgY2Fubm90IGJlIHRhbXBlcmVkIHdpdGgsIGFuZCBhbGwgY29waWVzXG4vLyBvZiB0aGUgQHdyeS9jb250ZXh0IHBhY2thZ2UgKGhvcGVmdWxseSBqdXN0IG9uZSkgd2lsbCBzaGFyZSB0aGUgc2FtZSBTbG90XG4vLyBpbXBsZW1lbnRhdGlvbi4gU2luY2UgdGhlIGZpcnN0IGNvcHkgb2YgdGhlIEB3cnkvY29udGV4dCBwYWNrYWdlIHRvIGJlXG4vLyBpbXBvcnRlZCB3aW5zLCB0aGlzIHRlY2huaXF1ZSBpbXBvc2VzIGEgc3RlZXAgY29zdCBmb3IgYW55IGZ1dHVyZSBicmVha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgU2xvdCBjbGFzcy5cbmNvbnN0IGdsb2JhbEtleSA9IFwiQHdyeS9jb250ZXh0OlNsb3RcIjtcbmNvbnN0IGhvc3QgPSBcbi8vIFByZWZlciBnbG9iYWxUaGlzIHdoZW4gYXZhaWxhYmxlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbW4vd3J5d2FyZS9pc3N1ZXMvMzQ3XG5tYXliZSgoKSA9PiBnbG9iYWxUaGlzKSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byBnbG9iYWwsIHdoaWNoIHdvcmtzIGluIE5vZGUuanMgYW5kIG1heSBiZSBjb252ZXJ0ZWQgYnkgc29tZVxuICAgIC8vIGJ1bmRsZXJzIHRvIHRoZSBhcHByb3ByaWF0ZSBpZGVudGlmaWVyICh3aW5kb3csIHNlbGYsIC4uLikgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIGJ1bmRsaW5nIHRhcmdldC4gaHR0cHM6Ly9naXRodWIuY29tL2VuZG9qcy9lbmRvL2lzc3Vlcy81NzYjaXNzdWVjb21tZW50LTExNzg1MTUyMjRcbiAgICBtYXliZSgoKSA9PiBnbG9iYWwpIHx8XG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgYSBkdW1teSBob3N0IHRoYXQncyBsb2NhbCB0byB0aGlzIG1vZHVsZS4gV2UgdXNlZCB0byBmYWxsXG4gICAgLy8gYmFjayB0byB1c2luZyB0aGUgQXJyYXkgY29uc3RydWN0b3IgYXMgYSBuYW1lc3BhY2UsIGJ1dCB0aGF0IHdhcyBmbGFnZ2VkIGluXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbW4vd3J5d2FyZS9pc3N1ZXMvMzQ3LCBhbmQgY2FuIGJlIGF2b2lkZWQuXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFdoaWNoZXZlciBnbG9iYWxIb3N0IHdlJ3JlIHVzaW5nLCBtYWtlIFR5cGVTY3JpcHQgaGFwcHkgYWJvdXQgdGhlIGFkZGl0aW9uYWxcbi8vIGdsb2JhbEtleSBwcm9wZXJ0eS5cbmNvbnN0IGdsb2JhbEhvc3QgPSBob3N0O1xuZXhwb3J0IGNvbnN0IFNsb3QgPSBnbG9iYWxIb3N0W2dsb2JhbEtleV0gfHxcbiAgICAvLyBFYXJsaWVyIHZlcnNpb25zIG9mIHRoaXMgcGFja2FnZSBzdG9yZWQgdGhlIGdsb2JhbEtleSBwcm9wZXJ0eSBvbiB0aGUgQXJyYXlcbiAgICAvLyBjb25zdHJ1Y3Rvciwgc28gd2UgY2hlY2sgdGhlcmUgYXMgd2VsbCwgdG8gcHJldmVudCBTbG90IGNsYXNzIGR1cGxpY2F0aW9uLlxuICAgIEFycmF5W2dsb2JhbEtleV0gfHxcbiAgICAoZnVuY3Rpb24gKFNsb3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxIb3N0LCBnbG9iYWxLZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogU2xvdCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpdCB3YXMgcG9zc2libGUgZm9yIGdsb2JhbEhvc3QgdG8gYmUgdGhlIEFycmF5IGNvbnN0cnVjdG9yIChhXG4gICAgICAgICAgICAgICAgLy8gbGVnYWN5IFNsb3QgZGVkdXAgc3RyYXRlZ3kpLCBpdCB3YXMgaW1wb3J0YW50IGZvciB0aGUgcHJvcGVydHkgdG8gYmVcbiAgICAgICAgICAgICAgICAvLyBjb25maWd1cmFibGU6dHJ1ZSBzbyBpdCBjb3VsZCBiZSBkZWxldGVkLiBUaGF0IGRvZXMgbm90IHNlZW0gdG8gYmUgYXNcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnRhbnQgd2hlbiBnbG9iYWxIb3N0IGlzIHRoZSBnbG9iYWwgb2JqZWN0LCBidXQgSSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAgICAgLy8gY2F1c2Ugc2ltaWxhciBwcm9ibGVtcyBhZ2FpbiwgYW5kIGNvbmZpZ3VyYWJsZTp0cnVlIHNlZW1zIHNhZmVzdC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW5kb2pzL2VuZG8vaXNzdWVzLzU3NiNpc3N1ZWNvbW1lbnQtMTE3ODI3NDAwOFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZXR1cm4gU2xvdDtcbiAgICAgICAgfVxuICAgIH0pKG1ha2VTbG90Q2xhc3MoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbG90LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/context/lib/slot.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wry/trie/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@wry/trie/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Trie: () => (/* binding */ Trie)\n/* harmony export */ });\n// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nclass Trie {\n    constructor(weakness = true, makeData = defaultMakeData) {\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n    lookup() {\n        return this.lookupArray(arguments);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, key => node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\")\n            ? node.data\n            : node.data = this.makeData(slice.call(array));\n    }\n    peek() {\n        return this.peekArray(arguments);\n    }\n    peekArray(array) {\n        let node = this;\n        for (let i = 0, len = array.length; node && i < len; ++i) {\n            const map = node.mapFor(array[i], false);\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    remove() {\n        return this.removeArray(arguments);\n    }\n    removeArray(array) {\n        let data;\n        if (array.length) {\n            const head = array[0];\n            const map = this.mapFor(head, false);\n            const child = map && map.get(head);\n            if (child) {\n                data = child.removeArray(slice.call(array, 1));\n                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n                    map.delete(head);\n                }\n            }\n        }\n        else {\n            data = this.data;\n            delete this.data;\n        }\n        return data;\n    }\n    getChildTrie(key) {\n        const map = this.mapFor(key, true);\n        let child = map.get(key);\n        if (!child)\n            map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n    mapFor(key, create) {\n        return this.weakness && isObjRef(key)\n            ? this.weak || (create ? this.weak = new WeakMap : void 0)\n            : this.strong || (create ? this.strong = new Map : void 0);\n    }\n}\nfunction isObjRef(value) {\n    switch (typeof value) {\n        case \"object\":\n            if (value === null)\n                break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad3J5L3RyaWUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCLFFBQVEsaUJBQWlCO0FBQ2xCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXEB3cnlcXHRyaWVcXGxpYlxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBbdHJpZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJpZSkgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBob2xkc1xuLy8gb2JqZWN0IGtleXMgd2Vha2x5LCB5ZXQgY2FuIGFsc28gaG9sZCBub24tb2JqZWN0IGtleXMsIHVubGlrZSB0aGVcbi8vIG5hdGl2ZSBgV2Vha01hcGAuXG4vLyBJZiBubyBtYWtlRGF0YSBmdW5jdGlvbiBpcyBzdXBwbGllZCwgdGhlIGxvb2tlZC11cCBkYXRhIHdpbGwgYmUgYW4gZW1wdHksXG4vLyBudWxsLXByb3RvdHlwZSBPYmplY3QuXG5jb25zdCBkZWZhdWx0TWFrZURhdGEgPSAoKSA9PiBPYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVXNlZnVsIGZvciBwcm9jZXNzaW5nIGFyZ3VtZW50cyBvYmplY3RzIGFzIHdlbGwgYXMgYXJyYXlzLlxuY29uc3QgeyBmb3JFYWNoLCBzbGljZSB9ID0gQXJyYXkucHJvdG90eXBlO1xuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmV4cG9ydCBjbGFzcyBUcmllIHtcbiAgICBjb25zdHJ1Y3Rvcih3ZWFrbmVzcyA9IHRydWUsIG1ha2VEYXRhID0gZGVmYXVsdE1ha2VEYXRhKSB7XG4gICAgICAgIHRoaXMud2Vha25lc3MgPSB3ZWFrbmVzcztcbiAgICAgICAgdGhpcy5tYWtlRGF0YSA9IG1ha2VEYXRhO1xuICAgIH1cbiAgICBsb29rdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cEFycmF5KGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGxvb2t1cEFycmF5KGFycmF5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcztcbiAgICAgICAgZm9yRWFjaC5jYWxsKGFycmF5LCBrZXkgPT4gbm9kZSA9IG5vZGUuZ2V0Q2hpbGRUcmllKGtleSkpO1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcImRhdGFcIilcbiAgICAgICAgICAgID8gbm9kZS5kYXRhXG4gICAgICAgICAgICA6IG5vZGUuZGF0YSA9IHRoaXMubWFrZURhdGEoc2xpY2UuY2FsbChhcnJheSkpO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrQXJyYXkoYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcGVla0FycmF5KGFycmF5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgbm9kZSAmJiBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5vZGUubWFwRm9yKGFycmF5W2ldLCBmYWxzZSk7XG4gICAgICAgICAgICBub2RlID0gbWFwICYmIG1hcC5nZXQoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUuZGF0YTtcbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBcnJheShhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZW1vdmVBcnJheShhcnJheSkge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGFycmF5WzBdO1xuICAgICAgICAgICAgY29uc3QgbWFwID0gdGhpcy5tYXBGb3IoaGVhZCwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBtYXAgJiYgbWFwLmdldChoZWFkKTtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBjaGlsZC5yZW1vdmVBcnJheShzbGljZS5jYWxsKGFycmF5LCAxKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5kYXRhICYmICFjaGlsZC53ZWFrICYmICEoY2hpbGQuc3Ryb25nICYmIGNoaWxkLnN0cm9uZy5zaXplKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGhlYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBnZXRDaGlsZFRyaWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwRm9yKGtleSwgdHJ1ZSk7XG4gICAgICAgIGxldCBjaGlsZCA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBjaGlsZCA9IG5ldyBUcmllKHRoaXMud2Vha25lc3MsIHRoaXMubWFrZURhdGEpKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBtYXBGb3Ioa2V5LCBjcmVhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vha25lc3MgJiYgaXNPYmpSZWYoa2V5KVxuICAgICAgICAgICAgPyB0aGlzLndlYWsgfHwgKGNyZWF0ZSA/IHRoaXMud2VhayA9IG5ldyBXZWFrTWFwIDogdm9pZCAwKVxuICAgICAgICAgICAgOiB0aGlzLnN0cm9uZyB8fCAoY3JlYXRlID8gdGhpcy5zdHJvbmcgPSBuZXcgTWFwIDogdm9pZCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc09ialJlZih2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIHJldHVybiB0cnVlLi4uXG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphql/language/visitor.mjs":
/*!***************************************************!*\
  !*** ./node_modules/graphql/language/visitor.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BREAK: () => (/* binding */ BREAK),\n/* harmony export */   getEnterLeaveForKind: () => (/* binding */ getEnterLeaveForKind),\n/* harmony export */   getVisitFn: () => (/* binding */ getVisitFn),\n/* harmony export */   visit: () => (/* binding */ visit),\n/* harmony export */   visitInParallel: () => (/* binding */ visitInParallel)\n/* harmony export */ });\n/* harmony import */ var _jsutils_devAssert_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../jsutils/devAssert.mjs */ \"(app-pages-browser)/./node_modules/graphql/jsutils/devAssert.mjs\");\n/* harmony import */ var _jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../jsutils/inspect.mjs */ \"(app-pages-browser)/./node_modules/graphql/jsutils/inspect.mjs\");\n/* harmony import */ var _ast_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ast.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/ast.mjs\");\n/* harmony import */ var _kinds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kinds.mjs */ \"(app-pages-browser)/./node_modules/graphql/language/kinds.mjs\");\n\n\n\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\nconst BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */\n\nfunction visit(root, visitor, visitorKeys = _ast_mjs__WEBPACK_IMPORTED_MODULE_0__.QueryDocumentKeys) {\n  const enterLeaveMap = new Map();\n\n  for (const kind of Object.values(_kinds_mjs__WEBPACK_IMPORTED_MODULE_1__.Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  /* eslint-disable no-undef-init */\n\n  let stack = undefined;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = undefined;\n  let parent = undefined;\n  const path = [];\n  const ancestors = [];\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = { ...node };\n\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      path.push(key);\n    }\n\n    let result;\n\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n\n      (0,_ast_mjs__WEBPACK_IMPORTED_MODULE_0__.isNode)(node) || (0,_jsutils_devAssert_mjs__WEBPACK_IMPORTED_MODULE_2__.devAssert)(false, `Invalid AST Node: ${(0,_jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_3__.inspect)(node)}.`);\n      const visitFn = isLeaving\n        ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get === void 0\n          ? void 0\n          : _enterLeaveMap$get.leave\n        : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get2 === void 0\n        ? void 0\n        : _enterLeaveMap$get2.enter;\n      result =\n        visitFn === null || visitFn === void 0\n          ? void 0\n          : visitFn.call(visitor, node, key, parent, path, ancestors);\n\n      if (result === BREAK) {\n        break;\n      }\n\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n\n        if (!isLeaving) {\n          if ((0,_ast_mjs__WEBPACK_IMPORTED_MODULE_0__.isNode)(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack,\n      };\n      inArray = Array.isArray(node);\n      keys = inArray\n        ? node\n        : (_node$kind = visitorKeys[node.kind]) !== null &&\n          _node$kind !== void 0\n        ? _node$kind\n        : [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    // New root\n    return edits[edits.length - 1][1];\n  }\n\n  return root;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nfunction visitInParallel(visitors) {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = Object.create(null);\n\n  for (const kind of Object.values(_kinds_mjs__WEBPACK_IMPORTED_MODULE_1__.Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(undefined);\n    const leaveList = new Array(visitors.length).fill(undefined);\n\n    for (let i = 0; i < visitors.length; ++i) {\n      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);\n      hasVisitor || (hasVisitor = enter != null || leave != null);\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n\n    if (!hasVisitor) {\n      continue;\n    }\n\n    const mergedEnterLeave = {\n      enter(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _enterList$i;\n\n            const result =\n              (_enterList$i = enterList[i]) === null || _enterList$i === void 0\n                ? void 0\n                : _enterList$i.apply(visitors[i], args);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      },\n\n      leave(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _leaveList$i;\n\n            const result =\n              (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0\n                ? void 0\n                : _leaveList$i.apply(visitors[i], args);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      },\n    };\n    mergedVisitor[kind] = mergedEnterLeave;\n  }\n\n  return mergedVisitor;\n}\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */\n\nfunction getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n\n  if (typeof kindVisitor === 'object') {\n    // { Kind: { enter() {}, leave() {} } }\n    return kindVisitor;\n  } else if (typeof kindVisitor === 'function') {\n    // { Kind() {} }\n    return {\n      enter: kindVisitor,\n      leave: undefined,\n    };\n  } // { enter() {}, leave() {} }\n\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave,\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n *\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\n */\n\n/* c8 ignore next 8 */\n\nfunction getVisitFn(visitor, kind, isLeaving) {\n  const { enter, leave } = getEnterLeaveForKind(visitor, kind);\n  return isLeaving ? leave : enter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNKO0FBQ0s7QUFDbkI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sOEJBQThCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFTyw0Q0FBNEMsdURBQWlCO0FBQ3BFOztBQUVBLG1DQUFtQyw0Q0FBSTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE1BQU0sZ0RBQU0sVUFBVSxpRUFBUyw2QkFBNkIsNkRBQU8sT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLGNBQWMsZ0RBQU07QUFDcEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUMsNENBQUk7QUFDdkM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekMsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBLFNBQVMsUUFBUSxVQUFVO0FBQzNCO0FBQ0EsSUFBSTtBQUNKLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSyxVQUFVOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1AsVUFBVSxlQUFlO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZ3JhcGhxbFxcbGFuZ3VhZ2VcXHZpc2l0b3IubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRldkFzc2VydCB9IGZyb20gJy4uL2pzdXRpbHMvZGV2QXNzZXJ0Lm1qcyc7XG5pbXBvcnQgeyBpbnNwZWN0IH0gZnJvbSAnLi4vanN1dGlscy9pbnNwZWN0Lm1qcyc7XG5pbXBvcnQgeyBpc05vZGUsIFF1ZXJ5RG9jdW1lbnRLZXlzIH0gZnJvbSAnLi9hc3QubWpzJztcbmltcG9ydCB7IEtpbmQgfSBmcm9tICcuL2tpbmRzLm1qcyc7XG4vKipcbiAqIEEgdmlzaXRvciBpcyBwcm92aWRlZCB0byB2aXNpdCwgaXQgY29udGFpbnMgdGhlIGNvbGxlY3Rpb24gb2ZcbiAqIHJlbGV2YW50IGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZSB2aXNpdG9yJ3MgdHJhdmVyc2FsLlxuICovXG5cbmV4cG9ydCBjb25zdCBCUkVBSyA9IE9iamVjdC5mcmVlemUoe30pO1xuLyoqXG4gKiB2aXNpdCgpIHdpbGwgd2FsayB0aHJvdWdoIGFuIEFTVCB1c2luZyBhIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCwgY2FsbGluZ1xuICogdGhlIHZpc2l0b3IncyBlbnRlciBmdW5jdGlvbiBhdCBlYWNoIG5vZGUgaW4gdGhlIHRyYXZlcnNhbCwgYW5kIGNhbGxpbmcgdGhlXG4gKiBsZWF2ZSBmdW5jdGlvbiBhZnRlciB2aXNpdGluZyB0aGF0IG5vZGUgYW5kIGFsbCBvZiBpdHMgY2hpbGQgbm9kZXMuXG4gKlxuICogQnkgcmV0dXJuaW5nIGRpZmZlcmVudCB2YWx1ZXMgZnJvbSB0aGUgZW50ZXIgYW5kIGxlYXZlIGZ1bmN0aW9ucywgdGhlXG4gKiBiZWhhdmlvciBvZiB0aGUgdmlzaXRvciBjYW4gYmUgYWx0ZXJlZCwgaW5jbHVkaW5nIHNraXBwaW5nIG92ZXIgYSBzdWItdHJlZSBvZlxuICogdGhlIEFTVCAoYnkgcmV0dXJuaW5nIGZhbHNlKSwgZWRpdGluZyB0aGUgQVNUIGJ5IHJldHVybmluZyBhIHZhbHVlIG9yIG51bGxcbiAqIHRvIHJlbW92ZSB0aGUgdmFsdWUsIG9yIHRvIHN0b3AgdGhlIHdob2xlIHRyYXZlcnNhbCBieSByZXR1cm5pbmcgQlJFQUsuXG4gKlxuICogV2hlbiB1c2luZyB2aXNpdCgpIHRvIGVkaXQgYW4gQVNULCB0aGUgb3JpZ2luYWwgQVNUIHdpbGwgbm90IGJlIG1vZGlmaWVkLCBhbmRcbiAqIGEgbmV3IHZlcnNpb24gb2YgdGhlIEFTVCB3aXRoIHRoZSBjaGFuZ2VzIGFwcGxpZWQgd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoZVxuICogdmlzaXQgZnVuY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGVkaXRlZEFTVCA9IHZpc2l0KGFzdCwge1xuICogICBlbnRlcihub2RlLCBrZXksIHBhcmVudCwgcGF0aCwgYW5jZXN0b3JzKSB7XG4gKiAgICAgLy8gQHJldHVyblxuICogICAgIC8vICAgdW5kZWZpbmVkOiBubyBhY3Rpb25cbiAqICAgICAvLyAgIGZhbHNlOiBza2lwIHZpc2l0aW5nIHRoaXMgbm9kZVxuICogICAgIC8vICAgdmlzaXRvci5CUkVBSzogc3RvcCB2aXNpdGluZyBhbHRvZ2V0aGVyXG4gKiAgICAgLy8gICBudWxsOiBkZWxldGUgdGhpcyBub2RlXG4gKiAgICAgLy8gICBhbnkgdmFsdWU6IHJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIHJldHVybmVkIHZhbHVlXG4gKiAgIH0sXG4gKiAgIGxlYXZlKG5vZGUsIGtleSwgcGFyZW50LCBwYXRoLCBhbmNlc3RvcnMpIHtcbiAqICAgICAvLyBAcmV0dXJuXG4gKiAgICAgLy8gICB1bmRlZmluZWQ6IG5vIGFjdGlvblxuICogICAgIC8vICAgZmFsc2U6IG5vIGFjdGlvblxuICogICAgIC8vICAgdmlzaXRvci5CUkVBSzogc3RvcCB2aXNpdGluZyBhbHRvZ2V0aGVyXG4gKiAgICAgLy8gICBudWxsOiBkZWxldGUgdGhpcyBub2RlXG4gKiAgICAgLy8gICBhbnkgdmFsdWU6IHJlcGxhY2UgdGhpcyBub2RlIHdpdGggdGhlIHJldHVybmVkIHZhbHVlXG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQWx0ZXJuYXRpdmVseSB0byBwcm92aWRpbmcgZW50ZXIoKSBhbmQgbGVhdmUoKSBmdW5jdGlvbnMsIGEgdmlzaXRvciBjYW5cbiAqIGluc3RlYWQgcHJvdmlkZSBmdW5jdGlvbnMgbmFtZWQgdGhlIHNhbWUgYXMgdGhlIGtpbmRzIG9mIEFTVCBub2Rlcywgb3JcbiAqIGVudGVyL2xlYXZlIHZpc2l0b3JzIGF0IGEgbmFtZWQga2V5LCBsZWFkaW5nIHRvIHRocmVlIHBlcm11dGF0aW9ucyBvZiB0aGVcbiAqIHZpc2l0b3IgQVBJOlxuICpcbiAqIDEpIE5hbWVkIHZpc2l0b3JzIHRyaWdnZXJlZCB3aGVuIGVudGVyaW5nIGEgbm9kZSBvZiBhIHNwZWNpZmljIGtpbmQuXG4gKlxuICogYGBgdHNcbiAqIHZpc2l0KGFzdCwge1xuICogICBLaW5kKG5vZGUpIHtcbiAqICAgICAvLyBlbnRlciB0aGUgXCJLaW5kXCIgbm9kZVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogMikgTmFtZWQgdmlzaXRvcnMgdGhhdCB0cmlnZ2VyIHVwb24gZW50ZXJpbmcgYW5kIGxlYXZpbmcgYSBub2RlIG9mIGEgc3BlY2lmaWMga2luZC5cbiAqXG4gKiBgYGB0c1xuICogdmlzaXQoYXN0LCB7XG4gKiAgIEtpbmQ6IHtcbiAqICAgICBlbnRlcihub2RlKSB7XG4gKiAgICAgICAvLyBlbnRlciB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgIH1cbiAqICAgICBsZWF2ZShub2RlKSB7XG4gKiAgICAgICAvLyBsZWF2ZSB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICpcbiAqIDMpIEdlbmVyaWMgdmlzaXRvcnMgdGhhdCB0cmlnZ2VyIHVwb24gZW50ZXJpbmcgYW5kIGxlYXZpbmcgYW55IG5vZGUuXG4gKlxuICogYGBgdHNcbiAqIHZpc2l0KGFzdCwge1xuICogICBlbnRlcihub2RlKSB7XG4gKiAgICAgLy8gZW50ZXIgYW55IG5vZGVcbiAqICAgfSxcbiAqICAgbGVhdmUobm9kZSkge1xuICogICAgIC8vIGxlYXZlIGFueSBub2RlXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXQocm9vdCwgdmlzaXRvciwgdmlzaXRvcktleXMgPSBRdWVyeURvY3VtZW50S2V5cykge1xuICBjb25zdCBlbnRlckxlYXZlTWFwID0gbmV3IE1hcCgpO1xuXG4gIGZvciAoY29uc3Qga2luZCBvZiBPYmplY3QudmFsdWVzKEtpbmQpKSB7XG4gICAgZW50ZXJMZWF2ZU1hcC5zZXQoa2luZCwgZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCkpO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLWluaXQgKi9cblxuICBsZXQgc3RhY2sgPSB1bmRlZmluZWQ7XG4gIGxldCBpbkFycmF5ID0gQXJyYXkuaXNBcnJheShyb290KTtcbiAgbGV0IGtleXMgPSBbcm9vdF07XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgZWRpdHMgPSBbXTtcbiAgbGV0IG5vZGUgPSByb290O1xuICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICBsZXQgcGFyZW50ID0gdW5kZWZpbmVkO1xuICBjb25zdCBwYXRoID0gW107XG4gIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmLWluaXQgKi9cblxuICBkbyB7XG4gICAgaW5kZXgrKztcbiAgICBjb25zdCBpc0xlYXZpbmcgPSBpbmRleCA9PT0ga2V5cy5sZW5ndGg7XG4gICAgY29uc3QgaXNFZGl0ZWQgPSBpc0xlYXZpbmcgJiYgZWRpdHMubGVuZ3RoICE9PSAwO1xuXG4gICAgaWYgKGlzTGVhdmluZykge1xuICAgICAga2V5ID0gYW5jZXN0b3JzLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBhbmNlc3RvcnMucG9wKCk7XG5cbiAgICAgIGlmIChpc0VkaXRlZCkge1xuICAgICAgICBpZiAoaW5BcnJheSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNsaWNlKCk7XG4gICAgICAgICAgbGV0IGVkaXRPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBbZWRpdEtleSwgZWRpdFZhbHVlXSBvZiBlZGl0cykge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlLZXkgPSBlZGl0S2V5IC0gZWRpdE9mZnNldDtcblxuICAgICAgICAgICAgaWYgKGVkaXRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBub2RlLnNwbGljZShhcnJheUtleSwgMSk7XG4gICAgICAgICAgICAgIGVkaXRPZmZzZXQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGVbYXJyYXlLZXldID0gZWRpdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0geyAuLi5ub2RlIH07XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IFtlZGl0S2V5LCBlZGl0VmFsdWVdIG9mIGVkaXRzKSB7XG4gICAgICAgICAgICBub2RlW2VkaXRLZXldID0gZWRpdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbmRleCA9IHN0YWNrLmluZGV4O1xuICAgICAga2V5cyA9IHN0YWNrLmtleXM7XG4gICAgICBlZGl0cyA9IHN0YWNrLmVkaXRzO1xuICAgICAgaW5BcnJheSA9IHN0YWNrLmluQXJyYXk7XG4gICAgICBzdGFjayA9IHN0YWNrLnByZXY7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgIGtleSA9IGluQXJyYXkgPyBpbmRleCA6IGtleXNbaW5kZXhdO1xuICAgICAgbm9kZSA9IHBhcmVudFtrZXldO1xuXG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIHZhciBfZW50ZXJMZWF2ZU1hcCRnZXQsIF9lbnRlckxlYXZlTWFwJGdldDI7XG5cbiAgICAgIGlzTm9kZShub2RlKSB8fCBkZXZBc3NlcnQoZmFsc2UsIGBJbnZhbGlkIEFTVCBOb2RlOiAke2luc3BlY3Qobm9kZSl9LmApO1xuICAgICAgY29uc3QgdmlzaXRGbiA9IGlzTGVhdmluZ1xuICAgICAgICA/IChfZW50ZXJMZWF2ZU1hcCRnZXQgPSBlbnRlckxlYXZlTWFwLmdldChub2RlLmtpbmQpKSA9PT0gbnVsbCB8fFxuICAgICAgICAgIF9lbnRlckxlYXZlTWFwJGdldCA9PT0gdm9pZCAwXG4gICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICA6IF9lbnRlckxlYXZlTWFwJGdldC5sZWF2ZVxuICAgICAgICA6IChfZW50ZXJMZWF2ZU1hcCRnZXQyID0gZW50ZXJMZWF2ZU1hcC5nZXQobm9kZS5raW5kKSkgPT09IG51bGwgfHxcbiAgICAgICAgICBfZW50ZXJMZWF2ZU1hcCRnZXQyID09PSB2b2lkIDBcbiAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgOiBfZW50ZXJMZWF2ZU1hcCRnZXQyLmVudGVyO1xuICAgICAgcmVzdWx0ID1cbiAgICAgICAgdmlzaXRGbiA9PT0gbnVsbCB8fCB2aXNpdEZuID09PSB2b2lkIDBcbiAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgIDogdmlzaXRGbi5jYWxsKHZpc2l0b3IsIG5vZGUsIGtleSwgcGFyZW50LCBwYXRoLCBhbmNlc3RvcnMpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkaXRzLnB1c2goW2tleSwgcmVzdWx0XSk7XG5cbiAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICBpZiAoaXNOb2RlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgaXNFZGl0ZWQpIHtcbiAgICAgIGVkaXRzLnB1c2goW2tleSwgbm9kZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0xlYXZpbmcpIHtcbiAgICAgIHBhdGgucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfbm9kZSRraW5kO1xuXG4gICAgICBzdGFjayA9IHtcbiAgICAgICAgaW5BcnJheSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGtleXMsXG4gICAgICAgIGVkaXRzLFxuICAgICAgICBwcmV2OiBzdGFjayxcbiAgICAgIH07XG4gICAgICBpbkFycmF5ID0gQXJyYXkuaXNBcnJheShub2RlKTtcbiAgICAgIGtleXMgPSBpbkFycmF5XG4gICAgICAgID8gbm9kZVxuICAgICAgICA6IChfbm9kZSRraW5kID0gdmlzaXRvcktleXNbbm9kZS5raW5kXSkgIT09IG51bGwgJiZcbiAgICAgICAgICBfbm9kZSRraW5kICE9PSB2b2lkIDBcbiAgICAgICAgPyBfbm9kZSRraW5kXG4gICAgICAgIDogW107XG4gICAgICBpbmRleCA9IC0xO1xuICAgICAgZWRpdHMgPSBbXTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBub2RlO1xuICAgIH1cbiAgfSB3aGlsZSAoc3RhY2sgIT09IHVuZGVmaW5lZCk7XG5cbiAgaWYgKGVkaXRzLmxlbmd0aCAhPT0gMCkge1xuICAgIC8vIE5ldyByb290XG4gICAgcmV0dXJuIGVkaXRzW2VkaXRzLmxlbmd0aCAtIDFdWzFdO1xuICB9XG5cbiAgcmV0dXJuIHJvb3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmlzaXRvciBpbnN0YW5jZSB3aGljaCBkZWxlZ2F0ZXMgdG8gbWFueSB2aXNpdG9ycyB0byBydW4gaW5cbiAqIHBhcmFsbGVsLiBFYWNoIHZpc2l0b3Igd2lsbCBiZSB2aXNpdGVkIGZvciBlYWNoIG5vZGUgYmVmb3JlIG1vdmluZyBvbi5cbiAqXG4gKiBJZiBhIHByaW9yIHZpc2l0b3IgZWRpdHMgYSBub2RlLCBubyBmb2xsb3dpbmcgdmlzaXRvcnMgd2lsbCBzZWUgdGhhdCBub2RlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdEluUGFyYWxsZWwodmlzaXRvcnMpIHtcbiAgY29uc3Qgc2tpcHBpbmcgPSBuZXcgQXJyYXkodmlzaXRvcnMubGVuZ3RoKS5maWxsKG51bGwpO1xuICBjb25zdCBtZXJnZWRWaXNpdG9yID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKGNvbnN0IGtpbmQgb2YgT2JqZWN0LnZhbHVlcyhLaW5kKSkge1xuICAgIGxldCBoYXNWaXNpdG9yID0gZmFsc2U7XG4gICAgY29uc3QgZW50ZXJMaXN0ID0gbmV3IEFycmF5KHZpc2l0b3JzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuICAgIGNvbnN0IGxlYXZlTGlzdCA9IG5ldyBBcnJheSh2aXNpdG9ycy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHsgZW50ZXIsIGxlYXZlIH0gPSBnZXRFbnRlckxlYXZlRm9yS2luZCh2aXNpdG9yc1tpXSwga2luZCk7XG4gICAgICBoYXNWaXNpdG9yIHx8IChoYXNWaXNpdG9yID0gZW50ZXIgIT0gbnVsbCB8fCBsZWF2ZSAhPSBudWxsKTtcbiAgICAgIGVudGVyTGlzdFtpXSA9IGVudGVyO1xuICAgICAgbGVhdmVMaXN0W2ldID0gbGVhdmU7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNWaXNpdG9yKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXJnZWRFbnRlckxlYXZlID0ge1xuICAgICAgZW50ZXIoLi4uYXJncykge1xuICAgICAgICBjb25zdCBub2RlID0gYXJnc1swXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNraXBwaW5nW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2VudGVyTGlzdCRpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPVxuICAgICAgICAgICAgICAoX2VudGVyTGlzdCRpID0gZW50ZXJMaXN0W2ldKSA9PT0gbnVsbCB8fCBfZW50ZXJMaXN0JGkgPT09IHZvaWQgMFxuICAgICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgICAgOiBfZW50ZXJMaXN0JGkuYXBwbHkodmlzaXRvcnNbaV0sIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBCUkVBSztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxlYXZlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChza2lwcGluZ1tpXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9sZWF2ZUxpc3QkaTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID1cbiAgICAgICAgICAgICAgKF9sZWF2ZUxpc3QkaSA9IGxlYXZlTGlzdFtpXSkgPT09IG51bGwgfHwgX2xlYXZlTGlzdCRpID09PSB2b2lkIDBcbiAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgIDogX2xlYXZlTGlzdCRpLmFwcGx5KHZpc2l0b3JzW2ldLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBCUkVBSztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc2tpcHBpbmdbaV0gPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHNraXBwaW5nW2ldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgICBtZXJnZWRWaXNpdG9yW2tpbmRdID0gbWVyZ2VkRW50ZXJMZWF2ZTtcbiAgfVxuXG4gIHJldHVybiBtZXJnZWRWaXNpdG9yO1xufVxuLyoqXG4gKiBHaXZlbiBhIHZpc2l0b3IgaW5zdGFuY2UgYW5kIGEgbm9kZSBraW5kLCByZXR1cm4gRW50ZXJMZWF2ZVZpc2l0b3IgZm9yIHRoYXQga2luZC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCkge1xuICBjb25zdCBraW5kVmlzaXRvciA9IHZpc2l0b3Jba2luZF07XG5cbiAgaWYgKHR5cGVvZiBraW5kVmlzaXRvciA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyB7IEtpbmQ6IHsgZW50ZXIoKSB7fSwgbGVhdmUoKSB7fSB9IH1cbiAgICByZXR1cm4ga2luZFZpc2l0b3I7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtpbmRWaXNpdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8geyBLaW5kKCkge30gfVxuICAgIHJldHVybiB7XG4gICAgICBlbnRlcjoga2luZFZpc2l0b3IsXG4gICAgICBsZWF2ZTogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gLy8geyBlbnRlcigpIHt9LCBsZWF2ZSgpIHt9IH1cblxuICByZXR1cm4ge1xuICAgIGVudGVyOiB2aXNpdG9yLmVudGVyLFxuICAgIGxlYXZlOiB2aXNpdG9yLmxlYXZlLFxuICB9O1xufVxuLyoqXG4gKiBHaXZlbiBhIHZpc2l0b3IgaW5zdGFuY2UsIGlmIGl0IGlzIGxlYXZpbmcgb3Igbm90LCBhbmQgYSBub2RlIGtpbmQsIHJldHVyblxuICogdGhlIGZ1bmN0aW9uIHRoZSB2aXNpdG9yIHJ1bnRpbWUgc2hvdWxkIGNhbGwuXG4gKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgZ2V0RW50ZXJMZWF2ZUZvcktpbmRgIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MTdcbiAqL1xuXG4vKiBjOCBpZ25vcmUgbmV4dCA4ICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpdEZuKHZpc2l0b3IsIGtpbmQsIGlzTGVhdmluZykge1xuICBjb25zdCB7IGVudGVyLCBsZWF2ZSB9ID0gZ2V0RW50ZXJMZWF2ZUZvcktpbmQodmlzaXRvciwga2luZCk7XG4gIHJldHVybiBpc0xlYXZpbmcgPyBsZWF2ZSA6IGVudGVyO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphql/language/visitor.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/app-dir/link.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    /**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */ default: function() {\n        return LinkComponent;\n    },\n    useLinkStatus: function() {\n        return useLinkStatus;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _formaturl = __webpack_require__(/*! ../../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _usemergedref = __webpack_require__(/*! ../use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\nconst _utils = __webpack_require__(/*! ../../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _warnonce = __webpack_require__(/*! ../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _links = __webpack_require__(/*! ../components/links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst _islocalurl = __webpack_require__(/*! ../../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _approuterinstance = __webpack_require__(/*! ../components/app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _erroronce = __webpack_require__(/*! ../../shared/lib/utils/error-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\");\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute('target');\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A';\n    if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {\n        // ignore click for browserâ€™s default behavior\n        return;\n    }\n    if (!(0, _islocalurl.isLocalURL)(href)) {\n        if (replace) {\n            // browser default behavior does not replace the history state\n            // so we need to do it manually\n            e.preventDefault();\n            location.replace(href);\n        }\n        // ignore click for browserâ€™s default behavior\n        return;\n    }\n    e.preventDefault();\n    if (onNavigate) {\n        let isDefaultPrevented = false;\n        onNavigate({\n            preventDefault: ()=>{\n                isDefaultPrevented = true;\n            }\n        });\n        if (isDefaultPrevented) {\n            return;\n        }\n    }\n    _react.default.startTransition(()=>{\n        (0, _approuterinstance.dispatchNavigateAction)(as || href, replace ? 'replace' : 'push', scroll != null ? scroll : true, linkInstanceRef.current);\n    });\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === 'string') {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\nfunction LinkComponent(props) {\n    _s();\n    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);\n    let children;\n    const linkInstanceRef = (0, _react.useRef)(null);\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n   * The possible states for prefetch are:\n   * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n   * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n   * - false: we will not prefetch if in the viewport at all\n   * - 'unstable_dynamicOnHover': this starts in \"auto\" mode, but switches to \"full\" when the link is hovered\n   */ const appPrefetchKind = prefetchProp === null || prefetchProp === 'auto' ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return Object.defineProperty(new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                value: \"E319\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            unstable_dynamicOnHover: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true,\n            onNavigate: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {\n                if (props[key] && valType !== 'function') {\n                    throw createPropError({\n                        key,\n                        expected: '`function`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'prefetch') {\n                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {\n                    throw createPropError({\n                        key,\n                        expected: '`boolean | \"auto\"`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n    }\n    if (true) {\n        if (props.locale) {\n            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');\n        }\n        if (!asProp) {\n            let href;\n            if (typeof hrefProp === 'string') {\n                href = hrefProp;\n            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));\n                if (hasDynamicSegment) {\n                    throw Object.defineProperty(new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E267\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo({\n        \"LinkComponent.useMemo\": ()=>{\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n    }[\"LinkComponent.useMemo\"], [\n        hrefProp,\n        asProp\n    ]);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw Object.defineProperty(new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E320\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                throw Object.defineProperty(new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0)), \"__NEXT_ERROR_CODE\", {\n                    value: \"E266\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === 'a') {\n                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E209\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;\n    // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n    // mount. In the future we will also use this to keep track of all the\n    // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n    // a revalidation or refresh.\n    const observeLinkVisibilityOnMount = _react.default.useCallback({\n        \"LinkComponent.useCallback[observeLinkVisibilityOnMount]\": (element)=>{\n            if (router !== null) {\n                linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, appPrefetchKind, prefetchEnabled, setOptimisticLinkStatus);\n            }\n            return ({\n                \"LinkComponent.useCallback[observeLinkVisibilityOnMount]\": ()=>{\n                    if (linkInstanceRef.current) {\n                        (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);\n                        linkInstanceRef.current = null;\n                    }\n                    (0, _links.unmountPrefetchableInstance)(element);\n                }\n            })[\"LinkComponent.useCallback[observeLinkVisibilityOnMount]\"];\n        }\n    }[\"LinkComponent.useCallback[observeLinkVisibilityOnMount]\"], [\n        prefetchEnabled,\n        href,\n        router,\n        appPrefetchKind,\n        setOptimisticLinkStatus\n    ]);\n    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);\n    const childProps = {\n        ref: mergedRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw Object.defineProperty(new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E312\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            if (!legacyBehavior && typeof onClick === 'function') {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled || \"development\" === 'development') {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled) {\n                return;\n            }\n            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;\n            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the basePath.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {\n        childProps.href = (0, _addbasepath.addBasePath)(as);\n    }\n    let link;\n    if (legacyBehavior) {\n        if (true) {\n            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\\n\\n' + 'npx @next/codemod@latest new-link .\\n\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');\n        }\n        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);\n    } else {\n        link = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            ...restProps,\n            ...childProps,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {\n        value: linkStatus,\n        children: link\n    });\n}\n_s(LinkComponent, \"MNV6IdWv8Lu3MKc7Fm4v59uGRY0=\");\n_c = LinkComponent;\nconst LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);\nconst useLinkStatus = ()=>{\n    return (0, _react.useContext)(LinkStatusContext);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c;\n$RefreshReg$(_c, \"LinkComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1kaXIvbGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQWlUQTs7Ozs7Ozs7O0NBU0MsR0FDRCxPQXNhQztlQXRhdUJBOztJQTRhWEMsYUFBYTtlQUFiQTs7Ozs7NkVBcnVCMkQ7dUNBRTlDOzJEQUNPO2dEQUNKOzBDQUNBO21DQUNDO3lDQUNGO3NDQUNIO21DQVNsQjt3Q0FDb0I7K0NBQ1k7dUNBQ2I7QUEwTTFCLFNBQVNDLGdCQUFnQkMsS0FBdUI7SUFDOUMsTUFBTUMsY0FBY0QsTUFBTUUsYUFBYTtJQUN2QyxNQUFNQyxTQUFTRixZQUFZRyxZQUFZLENBQUM7SUFDeEMsT0FDR0QsVUFBVUEsV0FBVyxXQUN0QkgsTUFBTUssT0FBTyxJQUNiTCxNQUFNTSxPQUFPLElBQ2JOLE1BQU1PLFFBQVEsSUFDZFAsTUFBTVEsTUFBTSxJQUFJLDZCQUE2QjtJQUM1Q1IsTUFBTVMsV0FBVyxJQUFJVCxNQUFNUyxXQUFXLENBQUNDLEtBQUssS0FBSztBQUV0RDtBQUVBLFNBQVNDLFlBQ1BDLENBQW1CLEVBQ25CQyxJQUFZLEVBQ1pDLEVBQVUsRUFDVkMsZUFBcUQsRUFDckRDLE9BQWlCLEVBQ2pCQyxNQUFnQixFQUNoQkMsVUFBbUM7SUFFbkMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR1AsRUFBRVYsYUFBYTtJQUVwQyxrREFBa0Q7SUFDbEQsTUFBTWtCLG1CQUFtQkQsU0FBU0UsV0FBVyxPQUFPO0lBRXBELElBQ0dELG9CQUFvQnJCLGdCQUFnQmEsTUFDckNBLEVBQUVWLGFBQWEsQ0FBQ29CLFlBQVksQ0FBQyxhQUM3QjtRQUNBLDhDQUE4QztRQUM5QztJQUNGO0lBRUEsSUFBSSxDQUFDQyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFBQSxFQUFXVixPQUFPO1FBQ3JCLElBQUlHLFNBQVM7WUFDWCw4REFBOEQ7WUFDOUQsK0JBQStCO1lBQy9CSixFQUFFWSxjQUFjO1lBQ2hCQyxTQUFTVCxPQUFPLENBQUNIO1FBQ25CO1FBRUEsOENBQThDO1FBQzlDO0lBQ0Y7SUFFQUQsRUFBRVksY0FBYztJQUVoQixJQUFJTixZQUFZO1FBQ2QsSUFBSVEscUJBQXFCO1FBRXpCUixXQUFXO1lBQ1RNLGdCQUFnQjtnQkFDZEUscUJBQXFCO1lBQ3ZCO1FBQ0Y7UUFFQSxJQUFJQSxvQkFBb0I7WUFDdEI7UUFDRjtJQUNGO0lBRUFDLE9BQUFBLE9BQUssQ0FBQ0MsZUFBZSxDQUFDO1FBQ3BCQyxDQUFBQSxHQUFBQSxtQkFBQUEsc0JBQUFBLEVBQ0VmLE1BQU1ELE1BQ05HLFVBQVUsWUFBWSxRQUN0QkMsVUFBQUEsT0FBQUEsU0FBVSxNQUNWRixnQkFBZ0JlLE9BQU87SUFFM0I7QUFDRjtBQUVBLFNBQVNDLGtCQUFrQkMsY0FBa0M7SUFDM0QsSUFBSSxPQUFPQSxtQkFBbUIsVUFBVTtRQUN0QyxPQUFPQTtJQUNUO0lBRUEsT0FBT0MsQ0FBQUEsR0FBQUEsV0FBQUEsU0FBQUEsRUFBVUQ7QUFDbkI7QUFZZSx1QkFDYkUsS0FHQzs7SUFFRCxNQUFNLENBQUNDLFlBQVlDLHdCQUF3QixHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFhLEVBQUNDLE9BQUFBLGdCQUFnQjtJQUU1RSxJQUFJQztJQUVKLE1BQU14QixrQkFBa0J5QixDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUVwRCxNQUFNLEVBQ0ozQixNQUFNNEIsUUFBUSxFQUNkM0IsSUFBSTRCLE1BQU0sRUFDVkgsVUFBVUksWUFBWSxFQUN0QkMsVUFBVUMsZUFBZSxJQUFJLEVBQzdCQyxRQUFRLEVBQ1I5QixPQUFPLEVBQ1ArQixPQUFPLEVBQ1A5QixNQUFNLEVBQ04rQixPQUFPLEVBQ1BDLGNBQWNDLGdCQUFnQixFQUM5QkMsY0FBY0MsZ0JBQWdCLEVBQzlCQyxpQkFBaUIsS0FBSyxFQUN0Qm5DLFVBQVUsRUFDVm9DLEtBQUtDLFlBQVksRUFDakJDLHVCQUF1QixFQUN2QixHQUFHQyxXQUNKLEdBQUd2QjtJQUVKSyxXQUFXSTtJQUVYLElBQ0VVLGtCQUNDLFFBQU9kLGFBQWEsWUFBWSxPQUFPQSxhQUFhLFNBQU8sRUFDNUQ7UUFDQUEsV0FBQUEsV0FBQUEsR0FBVyxxQkFBQ21CLEtBQUFBO3NCQUFHbkI7O0lBQ2pCO0lBRUEsTUFBTW9CLFNBQVNoQyxPQUFBQSxPQUFLLENBQUNpQyxVQUFVLENBQUNDLCtCQUFBQSxnQkFBZ0I7SUFFaEQsTUFBTUMsa0JBQWtCakIsaUJBQWlCO0lBQ3pDOzs7Ozs7R0FNQyxHQUNELE1BQU1rQixrQkFDSmxCLGlCQUFpQixRQUFRQSxpQkFBaUIsU0FDdENtQixvQkFBQUEsWUFBWSxDQUFDQyxJQUFJLEdBQ2pCRCxvQkFBQUEsWUFBWSxDQUFDRSxJQUFJO0lBRXZCLElBQUlDLElBQW9CLEVBQW1CO1FBQ3pDLFNBQVNHLGdCQUFnQkMsSUFJeEI7WUFDQyxPQUFPLHFCQUtOLENBTE0sSUFBSUMsTUFDUixpQ0FBK0JELEtBQUtFLEdBQUcsR0FBQyxpQkFBZUYsS0FBS0csUUFBUSxHQUFDLDRCQUE0QkgsS0FBS0ksTUFBTSxHQUFDLGVBQzNHLE1BQTZCLEdBQzFCLHFFQUNBLEVBQUMsR0FKRjt1QkFBQTs0QkFBQTs4QkFBQTtZQUtQO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdEMsTUFBTUUscUJBQXNEO1lBQzFEaEUsTUFBTTtRQUNSO1FBQ0EsTUFBTWlFLGdCQUFxQ0MsT0FBT0MsSUFBSSxDQUNwREg7UUFFRkMsY0FBY0csT0FBTyxDQUFDLENBQUNSO1lBQ3JCLElBQUlBLFFBQVEsUUFBUTtnQkFDbEIsSUFDRXZDLEtBQUssQ0FBQ3VDLElBQUksSUFBSSxRQUNiLE9BQU92QyxLQUFLLENBQUN1QyxJQUFJLEtBQUssWUFBWSxPQUFPdkMsS0FBSyxDQUFDdUMsSUFBSSxLQUFLLFVBQ3pEO29CQUNBLE1BQU1ILGdCQUFnQjt3QkFDcEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFRekMsS0FBSyxDQUFDdUMsSUFBSSxLQUFLLE9BQU8sU0FBUyxPQUFPdkMsS0FBSyxDQUFDdUMsSUFBSTtvQkFDMUQ7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLHNDQUFzQztnQkFDdEMsNkRBQTZEO2dCQUM3RCxNQUFNUyxJQUFXVDtZQUNuQjtRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLE1BQU1VLHFCQUFzRDtZQUMxRHJFLElBQUk7WUFDSkUsU0FBUztZQUNUQyxRQUFRO1lBQ1I4QixTQUFTO1lBQ1RELFVBQVU7WUFDVkYsVUFBVTtZQUNWWSx5QkFBeUI7WUFDekJSLFNBQVM7WUFDVEMsY0FBYztZQUNkRSxjQUFjO1lBQ2RFLGdCQUFnQjtZQUNoQm5DLFlBQVk7UUFDZDtRQUNBLE1BQU1rRSxnQkFBcUNMLE9BQU9DLElBQUksQ0FDcERHO1FBRUZDLGNBQWNILE9BQU8sQ0FBQyxDQUFDUjtZQUNyQixNQUFNWSxVQUFVLE9BQU9uRCxLQUFLLENBQUN1QyxJQUFJO1lBRWpDLElBQUlBLFFBQVEsTUFBTTtnQkFDaEIsSUFBSXZDLEtBQUssQ0FBQ3VDLElBQUksSUFBSVksWUFBWSxZQUFZQSxZQUFZLFVBQVU7b0JBQzlELE1BQU1mLGdCQUFnQjt3QkFDcEJHO3dCQUNBQyxVQUFVO3dCQUNWQyxRQUFRVTtvQkFDVjtnQkFDRjtZQUNGLE9BQU8sSUFDTFosUUFBUSxhQUNSQSxRQUFRLGtCQUNSQSxRQUFRLGtCQUNSQSxRQUFRLGNBQ1I7Z0JBQ0EsSUFBSXZDLEtBQUssQ0FBQ3VDLElBQUksSUFBSVksWUFBWSxZQUFZO29CQUN4QyxNQUFNZixnQkFBZ0I7d0JBQ3BCRzt3QkFDQUMsVUFBVTt3QkFDVkMsUUFBUVU7b0JBQ1Y7Z0JBQ0Y7WUFDRixPQUFPLElBQ0xaLFFBQVEsYUFDUkEsUUFBUSxZQUNSQSxRQUFRLGFBQ1JBLFFBQVEsY0FDUkEsUUFBUSxvQkFDUkEsUUFBUSwyQkFDUjtnQkFDQSxJQUFJdkMsS0FBSyxDQUFDdUMsSUFBSSxJQUFJLFFBQVFZLFlBQVksV0FBVztvQkFDL0MsTUFBTWYsZ0JBQWdCO3dCQUNwQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFVO29CQUNWO2dCQUNGO1lBQ0YsT0FBTyxJQUFJWixRQUFRLFlBQVk7Z0JBQzdCLElBQ0V2QyxLQUFLLENBQUN1QyxJQUFJLElBQUksUUFDZFksWUFBWSxhQUNabkQsS0FBSyxDQUFDdUMsSUFBSSxLQUFLLFFBQ2Y7b0JBQ0EsTUFBTUgsZ0JBQWdCO3dCQUNwQkc7d0JBQ0FDLFVBQVU7d0JBQ1ZDLFFBQVFVO29CQUNWO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxzQ0FBc0M7Z0JBQ3RDLDZEQUE2RDtnQkFDN0QsTUFBTUgsSUFBV1Q7WUFDbkI7UUFDRjtJQUNGO0lBRUEsSUFBSU4sSUFBb0IsRUFBbUI7UUFDekMsSUFBSWpDLE1BQU1vRCxNQUFNLEVBQUU7WUFDaEJDLENBQUFBLEdBQUFBLFVBQUFBLFFBQUFBLEVBQ0U7UUFFSjtRQUNBLElBQUksQ0FBQzdDLFFBQVE7WUFDWCxJQUFJN0I7WUFDSixJQUFJLE9BQU80QixhQUFhLFVBQVU7Z0JBQ2hDNUIsT0FBTzRCO1lBQ1QsT0FBTyxJQUNMLE9BQU9BLGFBQWEsWUFDcEIsT0FBT0EsU0FBUytDLFFBQVEsS0FBSyxVQUM3QjtnQkFDQTNFLE9BQU80QixTQUFTK0MsUUFBUTtZQUMxQjtZQUVBLElBQUkzRSxNQUFNO2dCQUNSLE1BQU00RSxvQkFBb0I1RSxLQUN2QjZFLEtBQUssQ0FBQyxLQUNOQyxJQUFJLENBQUMsQ0FBQ0MsVUFBWUEsUUFBUUMsVUFBVSxDQUFDLFFBQVFELFFBQVFFLFFBQVEsQ0FBQztnQkFFakUsSUFBSUwsbUJBQW1CO29CQUNyQixNQUFNLHFCQUVMLENBRkssSUFBSWpCLE1BQ1AsbUJBQWlCM0QsT0FBSyw2SUFEbkI7K0JBQUE7b0NBQUE7c0NBQUE7b0JBRU47Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxNQUFNLEVBQUVBLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdhLE9BQUFBLE9BQUssQ0FBQ29FLE9BQU87aUNBQUM7WUFDakMsTUFBTUMsZUFBZWpFLGtCQUFrQlU7WUFDdkMsT0FBTztnQkFDTDVCLE1BQU1tRjtnQkFDTmxGLElBQUk0QixTQUFTWCxrQkFBa0JXLFVBQVVzRDtZQUMzQztRQUNGO2dDQUFHO1FBQUN2RDtRQUFVQztLQUFPO0lBRXJCLG9GQUFvRjtJQUNwRixJQUFJdUQ7SUFDSixJQUFJNUMsZ0JBQWdCO1FBQ2xCLElBQUljLElBQW9CLEVBQW9CO1lBQzFDLElBQUluQixTQUFTO2dCQUNYa0QsUUFBUUMsSUFBSSxDQUNULG9EQUFvRDFELFdBQVM7WUFFbEU7WUFDQSxJQUFJUyxrQkFBa0I7Z0JBQ3BCZ0QsUUFBUUMsSUFBSSxDQUNULHlEQUF5RDFELFdBQVM7WUFFdkU7WUFDQSxJQUFJO2dCQUNGd0QsUUFBUXRFLE9BQUFBLE9BQUssQ0FBQ3lFLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDOUQ7WUFDOUIsRUFBRSxPQUFPK0QsS0FBSztnQkFDWixJQUFJLENBQUMvRCxVQUFVO29CQUNiLE1BQU0scUJBRUwsQ0FGSyxJQUFJaUMsTUFDUCx1REFBdUQvQixXQUFTLGtGQUQ3RDsrQkFBQTtvQ0FBQTtzQ0FBQTtvQkFFTjtnQkFDRjtnQkFDQSxNQUFNLHFCQUtMLENBTEssSUFBSStCLE1BQ1AsNkRBQTZEL0IsV0FBUyw4RkFDcEUsTUFBNkIsR0FDMUIsc0VBQ0EsRUFBQyxHQUpIOzJCQUFBO2dDQUFBO2tDQUFBO2dCQUtOO1lBQ0Y7UUFDRixPQUFPLEVBRU47SUFDSCxPQUFPO1FBQ0wsSUFBSTBCLElBQW9CLEVBQW9CO1lBQzFDLElBQUksYUFBQzVCLE9BQUFBLEtBQUFBLElBQUFBLFNBQWtCZ0UsSUFBQUEsTUFBUyxLQUFLO2dCQUNuQyxNQUFNLHFCQUVMLENBRkssSUFBSS9CLE1BQ1Isb0tBREk7MkJBQUE7Z0NBQUE7a0NBQUE7Z0JBRU47WUFDRjtRQUNGO0lBQ0Y7SUFFQSxNQUFNZ0MsV0FBZ0JuRCxpQkFDbEI0QyxTQUFTLE9BQU9BLFVBQVUsWUFBWUEsTUFBTTNDLEdBQUcsR0FDL0NDO0lBRUosNEVBQTRFO0lBQzVFLHNFQUFzRTtJQUN0RSw0RUFBNEU7SUFDNUUsNkJBQTZCO0lBQzdCLE1BQU1rRCwrQkFBK0I5RSxPQUFBQSxPQUFLLENBQUMrRSxXQUFXO21FQUNwRCxDQUFDQztZQUNDLElBQUloRCxXQUFXLE1BQU07Z0JBQ25CNUMsZ0JBQWdCZSxPQUFPLEdBQUc4RSxDQUFBQSxHQUFBQSxPQUFBQSxpQkFBQUEsRUFDeEJELFNBQ0E5RixNQUNBOEMsUUFDQUksaUJBQ0FELGlCQUNBMUI7WUFFSjtZQUVBOzJFQUFPO29CQUNMLElBQUlyQixnQkFBZ0JlLE9BQU8sRUFBRTt3QkFDM0IrRSxDQUFBQSxHQUFBQSxPQUFBQSwrQkFBQUEsRUFBZ0M5RixnQkFBZ0JlLE9BQU87d0JBQ3ZEZixnQkFBZ0JlLE9BQU8sR0FBRztvQkFDNUI7b0JBQ0FnRixDQUFBQSxHQUFBQSxPQUFBQSwyQkFBQUEsRUFBNEJIO2dCQUM5Qjs7UUFDRjtrRUFDQTtRQUFDN0M7UUFBaUJqRDtRQUFNOEM7UUFBUUk7UUFBaUIzQjtLQUF3QjtJQUczRSxNQUFNMkUsWUFBWUMsQ0FBQUEsR0FBQUEsY0FBQUEsWUFBQUEsRUFBYVAsOEJBQThCRDtJQUU3RCxNQUFNUyxhQU1GO1FBQ0YzRCxLQUFLeUQ7UUFDTC9ELFNBQVFwQyxDQUFDO1lBQ1AsSUFBSXVELElBQW9CLEVBQW1CO2dCQUN6QyxJQUFJLENBQUN2RCxHQUFHO29CQUNOLE1BQU0scUJBRUwsQ0FGSyxJQUFJNEQsTUFDUCxtRkFERzsrQkFBQTtvQ0FBQTtzQ0FBQTtvQkFFTjtnQkFDRjtZQUNGO1lBRUEsSUFBSSxDQUFDbkIsa0JBQWtCLE9BQU9MLFlBQVksWUFBWTtnQkFDcERBLFFBQVFwQztZQUNWO1lBRUEsSUFDRXlDLGtCQUNBNEMsTUFBTS9ELEtBQUssSUFDWCxPQUFPK0QsTUFBTS9ELEtBQUssQ0FBQ2MsT0FBTyxLQUFLLFlBQy9CO2dCQUNBaUQsTUFBTS9ELEtBQUssQ0FBQ2MsT0FBTyxDQUFDcEM7WUFDdEI7WUFFQSxJQUFJLENBQUMrQyxRQUFRO2dCQUNYO1lBQ0Y7WUFFQSxJQUFJL0MsRUFBRXNHLGdCQUFnQixFQUFFO2dCQUN0QjtZQUNGO1lBRUF2RyxZQUFZQyxHQUFHQyxNQUFNQyxJQUFJQyxpQkFBaUJDLFNBQVNDLFFBQVFDO1FBQzdEO1FBQ0ErQixjQUFhckMsQ0FBQztZQUNaLElBQUksQ0FBQ3lDLGtCQUFrQixPQUFPSCxxQkFBcUIsWUFBWTtnQkFDN0RBLGlCQUFpQnRDO1lBQ25CO1lBRUEsSUFDRXlDLGtCQUNBNEMsTUFBTS9ELEtBQUssSUFDWCxPQUFPK0QsTUFBTS9ELEtBQUssQ0FBQ2UsWUFBWSxLQUFLLFlBQ3BDO2dCQUNBZ0QsTUFBTS9ELEtBQUssQ0FBQ2UsWUFBWSxDQUFDckM7WUFDM0I7WUFFQSxJQUFJLENBQUMrQyxRQUFRO2dCQUNYO1lBQ0Y7WUFFQSxJQUFJLENBQUNHLG1CQUFtQkssUUFBUUMsR0FBRyxDQUFDQyxNQUFhLEVBQUwsYUFBb0I7Z0JBQzlEO1lBQ0Y7WUFFQSxNQUFNOEMsMkJBQTJCM0QsNEJBQTRCO1lBQzdENEQsQ0FBQUEsR0FBQUEsT0FBQUEsa0JBQUFBLEVBQ0V4RyxFQUFFVixhQUFhLEVBQ2ZpSDtRQUVKO1FBQ0FoRSxjQUFjZ0IsTUFBc0MsR0FDaERtRCxDQUFTQSxHQUNULFNBQVNuRSxhQUFhdkMsQ0FBQztZQUNyQixJQUFJLENBQUN5QyxrQkFBa0IsT0FBT0QscUJBQXFCLFlBQVk7Z0JBQzdEQSxpQkFBaUJ4QztZQUNuQjtZQUVBLElBQ0V5QyxrQkFDQTRDLE1BQU0vRCxLQUFLLElBQ1gsT0FBTytELE1BQU0vRCxLQUFLLENBQUNpQixZQUFZLEtBQUssWUFDcEM7Z0JBQ0E4QyxNQUFNL0QsS0FBSyxDQUFDaUIsWUFBWSxDQUFDdkM7WUFDM0I7WUFFQSxJQUFJLENBQUMrQyxRQUFRO2dCQUNYO1lBQ0Y7WUFFQSxJQUFJLENBQUNHLGlCQUFpQjtnQkFDcEI7WUFDRjtZQUVBLE1BQU1xRCwyQkFBMkIzRCw0QkFBNEI7WUFDN0Q0RCxDQUFBQSxHQUFBQSxPQUFBQSxrQkFBQUEsRUFDRXhHLEVBQUVWLGFBQWEsRUFDZmlIO1FBRUo7SUFDTjtJQUVBLDZGQUE2RjtJQUM3Rix3RkFBd0Y7SUFDeEYsMkVBQTJFO0lBQzNFLElBQUlJLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQWN6RyxLQUFLO1FBQ3JCbUcsV0FBV3BHLElBQUksR0FBR0M7SUFDcEIsT0FBTyxJQUNMLENBQUN1QyxrQkFDRFAsWUFDQ21ELE1BQU1NLElBQUksS0FBSyxPQUFPLENBQUUsV0FBVU4sTUFBTS9ELEtBQUFBLEdBQ3pDO1FBQ0ErRSxXQUFXcEcsSUFBSSxHQUFHMkcsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWTFHO0lBQ2hDO0lBRUEsSUFBSTJHO0lBRUosSUFBSXBFLGdCQUFnQjtRQUNsQixJQUFJYyxJQUFvQixFQUFvQjtZQUMxQ3VELENBQUFBLEdBQUFBLFdBQUFBLFNBQUFBLEVBQ0Usb0VBQ0Usb0VBQ0EsNENBQ0E7UUFFTjtRQUNBRCxPQUFBQSxXQUFBQSxHQUFPOUYsT0FBQUEsT0FBSyxDQUFDZ0csWUFBWSxDQUFDMUIsT0FBT2dCO0lBQ25DLE9BQU87UUFDTFEsT0FBQUEsV0FBQUEsR0FDRSxxQkFBQy9ELEtBQUFBO1lBQUcsR0FBR0QsU0FBUztZQUFHLEdBQUd3RCxVQUFVO3NCQUM3QjFFOztJQUdQO0lBRUEscUJBQ0UscUJBQUNxRixrQkFBa0JDLFFBQVE7UUFBQ0MsT0FBTzNGO2tCQUNoQ3NGOztBQUdQO0dBdGF3QjVIOztBQXdheEIsTUFBTStILG9CQUFBQSxXQUFBQSxHQUFvQkcsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBQUEsRUFFeEJ6RixPQUFBQSxnQkFBZ0I7QUFFWCxNQUFNeEMsZ0JBQWdCO0lBQzNCLE9BQU84RCxDQUFBQSxHQUFBQSxPQUFBQSxVQUFBQSxFQUFXZ0U7QUFDcEIiLCJzb3VyY2VzIjpbIkQ6XFxzcmNcXGNsaWVudFxcYXBwLWRpclxcbGluay50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VPcHRpbWlzdGljLCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgZm9ybWF0VXJsIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IEFwcFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4uL2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYgfSBmcm9tICcuLi91c2UtbWVyZ2VkLXJlZidcbmltcG9ydCB7IGlzQWJzb2x1dGVVcmwgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzJ1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB0eXBlIHsgUEVORElOR19MSU5LX1NUQVRVUyB9IGZyb20gJy4uL2NvbXBvbmVudHMvbGlua3MnXG5pbXBvcnQge1xuICBJRExFX0xJTktfU1RBVFVTLFxuICBtb3VudExpbmtJbnN0YW5jZSxcbiAgb25OYXZpZ2F0aW9uSW50ZW50LFxuICB1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uLFxuICB1bm1vdW50UHJlZmV0Y2hhYmxlSW5zdGFuY2UsXG4gIHR5cGUgTGlua0luc3RhbmNlLFxufSBmcm9tICcuLi9jb21wb25lbnRzL2xpbmtzJ1xuaW1wb3J0IHsgaXNMb2NhbFVSTCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybCdcbmltcG9ydCB7IGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24gfSBmcm9tICcuLi9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBlcnJvck9uY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL2Vycm9yLW9uY2UnXG5cbnR5cGUgVXJsID0gc3RyaW5nIHwgVXJsT2JqZWN0XG50eXBlIFJlcXVpcmVkS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gbmV2ZXIgOiBLXG59W2tleW9mIFRdXG50eXBlIE9wdGlvbmFsS2V5czxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzoge30gZXh0ZW5kcyBQaWNrPFQsIEs+ID8gSyA6IG5ldmVyXG59W2tleW9mIFRdXG5cbnR5cGUgT25OYXZpZ2F0ZUV2ZW50SGFuZGxlciA9IChldmVudDogeyBwcmV2ZW50RGVmYXVsdDogKCkgPT4gdm9pZCB9KSA9PiB2b2lkXG5cbnR5cGUgSW50ZXJuYWxMaW5rUHJvcHMgPSB7XG4gIC8qKlxuICAgKiAqKlJlcXVpcmVkKiouIFRoZSBwYXRoIG9yIFVSTCB0byBuYXZpZ2F0ZSB0by4gSXQgY2FuIGFsc28gYmUgYW4gb2JqZWN0IChzaW1pbGFyIHRvIGBVUkxgKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIC8vIE5hdmlnYXRlIHRvIC9kYXNoYm9hcmQ6XG4gICAqIDxMaW5rIGhyZWY9XCIvZGFzaGJvYXJkXCI+RGFzaGJvYXJkPC9MaW5rPlxuICAgKlxuICAgKiAvLyBOYXZpZ2F0ZSB0byAvYWJvdXQ/bmFtZT10ZXN0OlxuICAgKiA8TGluayBocmVmPXt7IHBhdGhuYW1lOiAnL2Fib3V0JywgcXVlcnk6IHsgbmFtZTogJ3Rlc3QnIH0gfX0+XG4gICAqICAgQWJvdXRcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBGb3IgZXh0ZXJuYWwgVVJMcywgdXNlIGEgZnVsbHkgcXVhbGlmaWVkIFVSTCBzdWNoIGFzIGBodHRwczovLy4uLmAuXG4gICAqIC0gSW4gdGhlIEFwcCBSb3V0ZXIsIGR5bmFtaWMgcm91dGVzIG11c3Qgbm90IGluY2x1ZGUgYnJhY2tldGVkIHNlZ21lbnRzIGluIGBocmVmYC5cbiAgICovXG4gIGhyZWY6IFVybFxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB2MTAuMC4wOiBgaHJlZmAgcHJvcHMgcG9pbnRpbmcgdG8gYSBkeW5hbWljIHJvdXRlIGFyZVxuICAgKiBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIGFuZCBubyBsb25nZXIgcmVxdWlyZSB0aGUgYGFzYCBwcm9wLlxuICAgKi9cbiAgYXM/OiBVcmxcblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgY3VycmVudCBgaGlzdG9yeWAgc3RhdGUgaW5zdGVhZCBvZiBhZGRpbmcgYSBuZXcgVVJMIGludG8gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvYWJvdXRcIiByZXBsYWNlPlxuICAgKiAgIEFib3V0IChyZXBsYWNlcyB0aGUgaGlzdG9yeSBzdGF0ZSlcbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHJlcGxhY2U/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2Nyb2xsIGJlaGF2aW9yLiBJZiBgdHJ1ZWAsIE5leHQuanMgYXR0ZW1wdHMgdG8gbWFpbnRhaW5cbiAgICogdGhlIHNjcm9sbCBwb3NpdGlvbiBpZiB0aGUgbmV3bHkgbmF2aWdhdGVkIHBhZ2UgaXMgc3RpbGwgdmlzaWJsZS4gSWYgbm90LCBpdCBzY3JvbGxzIHRvIHRoZSB0b3AuXG4gICAqXG4gICAqIElmIGBmYWxzZWAsIE5leHQuanMgd2lsbCBub3QgbW9kaWZ5IHRoZSBzY3JvbGwgYmVoYXZpb3IgYXQgYWxsLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIiBzY3JvbGw9e2ZhbHNlfT5cbiAgICogICBObyBhdXRvIHNjcm9sbFxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgc2Nyb2xsPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgcGFnZSB3aXRob3V0IHJlcnVubmluZyBkYXRhIGZldGNoaW5nIG1ldGhvZHNcbiAgICogbGlrZSBgZ2V0U3RhdGljUHJvcHNgLCBgZ2V0U2VydmVyU2lkZVByb3BzYCwgb3IgYGdldEluaXRpYWxQcm9wc2AuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIGBzaGFsbG93YCBvbmx5IGFwcGxpZXMgdG8gdGhlIFBhZ2VzIFJvdXRlci4gRm9yIHRoZSBBcHAgUm91dGVyLCBzZWUgdGhlXG4gICAqIFtmb2xsb3dpbmcgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9saW5raW5nLWFuZC1uYXZpZ2F0aW5nI3VzaW5nLXRoZS1uYXRpdmUtaGlzdG9yeS1hcGkpLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIDxMaW5rIGhyZWY9XCIvYmxvZ1wiIHNoYWxsb3c+XG4gICAqICAgU2hhbGxvdyBuYXZpZ2F0aW9uXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBzaGFsbG93PzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYExpbmtgIHRvIHBhc3MgaXRzIGBocmVmYCB0byB0aGUgY2hpbGQgY29tcG9uZW50LiBVc2VmdWwgaWYgdGhlIGNoaWxkIGlzIGEgY3VzdG9tXG4gICAqIGNvbXBvbmVudCB0aGF0IHdyYXBzIGFuIGA8YT5gIHRhZywgb3IgaWYgeW91J3JlIHVzaW5nIGNlcnRhaW4gc3R5bGluZyBsaWJyYXJpZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIiBwYXNzSHJlZj5cbiAgICogICA8TXlTdHlsZWRBbmNob3I+RGFzaGJvYXJkPC9NeVN0eWxlZEFuY2hvcj5cbiAgICogPC9MaW5rPlxuICAgKiBgYGBcbiAgICovXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCB0aGUgcGFnZSBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogQW55IGA8TGluayAvPmAgdGhhdCBpcyBpbiB0aGUgdmlld3BvcnQgKGluaXRpYWxseSBvciB0aHJvdWdoIHNjcm9sbCkgd2lsbCBiZSBwcmVmZXRjaGVkLlxuICAgKiBQcmVmZXRjaCBjYW4gYmUgZGlzYWJsZWQgYnkgcGFzc2luZyBgcHJlZmV0Y2g9e2ZhbHNlfWAuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFByZWZldGNoaW5nIGlzIG9ubHkgZW5hYmxlZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiAtIEluIHRoZSAqKkFwcCBSb3V0ZXIqKjpcbiAgICogICAtIGBcImF1dG9cImAsIGBudWxsYCwgYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBQcmVmZXRjaCBiZWhhdmlvciBkZXBlbmRzIG9uIHN0YXRpYyB2cyBkeW5hbWljIHJvdXRlczpcbiAgICogICAgIC0gU3RhdGljIHJvdXRlczogZnVsbHkgcHJlZmV0Y2hlZFxuICAgKiAgICAgLSBEeW5hbWljIHJvdXRlczogcGFydGlhbCBwcmVmZXRjaCB0byB0aGUgbmVhcmVzdCBzZWdtZW50IHdpdGggYSBgbG9hZGluZy5qc2BcbiAgICogICAtIGB0cnVlYDogQWx3YXlzIHByZWZldGNoIHRoZSBmdWxsIHJvdXRlIGFuZCBkYXRhLlxuICAgKiAgIC0gYGZhbHNlYDogRGlzYWJsZSBwcmVmZXRjaGluZyBvbiBib3RoIHZpZXdwb3J0IGFuZCBob3Zlci5cbiAgICogLSBJbiB0aGUgKipQYWdlcyBSb3V0ZXIqKjpcbiAgICogICAtIGB0cnVlYCAoZGVmYXVsdCk6IFByZWZldGNoZXMgdGhlIHJvdXRlIGFuZCBkYXRhIGluIHRoZSBiYWNrZ3JvdW5kIG9uIHZpZXdwb3J0IG9yIGhvdmVyLlxuICAgKiAgIC0gYGZhbHNlYDogUHJlZmV0Y2ggb25seSBvbiBob3Zlciwgbm90IG9uIHZpZXdwb3J0LlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYCAoUGFnZXMgUm91dGVyKSBvciBgbnVsbGAgKEFwcCBSb3V0ZXIpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiA8TGluayBocmVmPVwiL2Rhc2hib2FyZFwiIHByZWZldGNoPXtmYWxzZX0+XG4gICAqICAgRGFzaGJvYXJkXG4gICAqIDwvTGluaz5cbiAgICogYGBgXG4gICAqL1xuICBwcmVmZXRjaD86IGJvb2xlYW4gfCAnYXV0bycgfCBudWxsXG5cbiAgLyoqXG4gICAqICh1bnN0YWJsZSkgU3dpdGNoIHRvIGEgZHluYW1pYyBwcmVmZXRjaCBvbiBob3Zlci4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXNcbiAgICogdXBkYXRpbmcgdGhlIHByZWZldGNoIHByb3AgdG8gYHRydWVgIGluIGEgbW91c2UgZXZlbnQuXG4gICAqL1xuICB1bnN0YWJsZV9keW5hbWljT25Ib3Zlcj86IGJvb2xlYW5cblxuICAvKipcbiAgICogVGhlIGFjdGl2ZSBsb2NhbGUgaXMgYXV0b21hdGljYWxseSBwcmVwZW5kZWQgaW4gdGhlIFBhZ2VzIFJvdXRlci4gYGxvY2FsZWAgYWxsb3dzIGZvciBwcm92aWRpbmdcbiAgICogYSBkaWZmZXJlbnQgbG9jYWxlLCBvciBjYW4gYmUgc2V0IHRvIGBmYWxzZWAgdG8gb3B0IG91dCBvZiBhdXRvbWF0aWMgbG9jYWxlIGJlaGF2aW9yLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBOb3RlOiBsb2NhbGUgb25seSBhcHBsaWVzIGluIHRoZSBQYWdlcyBSb3V0ZXIgYW5kIGlzIGlnbm9yZWQgaW4gdGhlIEFwcCBSb3V0ZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiAvLyBVc2UgdGhlICdmcicgbG9jYWxlOlxuICAgKiA8TGluayBocmVmPVwiL2Fib3V0XCIgbG9jYWxlPVwiZnJcIj5cbiAgICogICBBYm91dCAoRnJlbmNoKVxuICAgKiA8L0xpbms+XG4gICAqXG4gICAqIC8vIERpc2FibGUgbG9jYWxlIHByZWZpeDpcbiAgICogPExpbmsgaHJlZj1cIi9hYm91dFwiIGxvY2FsZT17ZmFsc2V9PlxuICAgKiAgIEFib3V0IChubyBsb2NhbGUgcHJlZml4KVxuICAgKiA8L0xpbms+XG4gICAqIGBgYFxuICAgKi9cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2VcblxuICAvKipcbiAgICogRW5hYmxlIGxlZ2FjeSBsaW5rIGJlaGF2aW9yLCByZXF1aXJpbmcgYW4gYDxhPmAgdGFnIHRvIHdyYXAgdGhlIGNoaWxkIGNvbnRlbnRcbiAgICogaWYgdGhlIGNoaWxkIGlzIGEgc3RyaW5nIG9yIG51bWJlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjE2XG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9jb21taXQvNDg5ZTY1ZWQ5ODU0NGU2OWIwYWZkN2UwY2ZjM2Y5ZjZjMmI4MDNiN1xuICAgKi9cbiAgbGVnYWN5QmVoYXZpb3I/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIG1vdXNlIHBvaW50ZXIgaXMgbW92ZWQgb250byB0aGUgYDxMaW5rPmAuXG4gICAqL1xuICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cblxuICAvKipcbiAgICogT3B0aW9uYWwgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgYDxMaW5rPmAgaXMgdG91Y2hlZC5cbiAgICovXG4gIG9uVG91Y2hTdGFydD86IFJlYWN0LlRvdWNoRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBgPExpbms+YCBpcyBjbGlja2VkLlxuICAgKi9cbiAgb25DbGljaz86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBgPExpbms+YCBpcyBuYXZpZ2F0ZWQuXG4gICAqL1xuICBvbk5hdmlnYXRlPzogT25OYXZpZ2F0ZUV2ZW50SGFuZGxlclxufVxuXG4vLyBUT0RPLUFQUDogSW5jbHVkZSB0aGUgZnVsbCBzZXQgb2YgQW5jaG9yIHByb3BzXG4vLyBhZGRpbmcgdGhpcyB0byB0aGUgcHVibGljbHkgZXhwb3J0ZWQgdHlwZSBjdXJyZW50bHkgYnJlYWtzIGV4aXN0aW5nIGFwcHNcblxuLy8gYFJvdXRlSW5mZXJUeXBlYCBpcyBhIHN0dWIgaGVyZSB0byBhdm9pZCBicmVha2luZyBgdHlwZWRSb3V0ZXNgIHdoZW4gdGhlIHR5cGVcbi8vIGlzbid0IGdlbmVyYXRlZCB5ZXQuIEl0IHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0aGUgd2VicGFjayBwbHVnaW4gcnVucy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCB0eXBlIExpbmtQcm9wczxSb3V0ZUluZmVyVHlwZSA9IGFueT4gPSBJbnRlcm5hbExpbmtQcm9wc1xudHlwZSBMaW5rUHJvcHNSZXF1aXJlZCA9IFJlcXVpcmVkS2V5czxMaW5rUHJvcHM+XG50eXBlIExpbmtQcm9wc09wdGlvbmFsID0gT3B0aW9uYWxLZXlzPE9taXQ8SW50ZXJuYWxMaW5rUHJvcHMsICdsb2NhbGUnPj5cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0JylcbiAgcmV0dXJuIChcbiAgICAodGFyZ2V0ICYmIHRhcmdldCAhPT0gJ19zZWxmJykgfHxcbiAgICBldmVudC5tZXRhS2V5IHx8XG4gICAgZXZlbnQuY3RybEtleSB8fFxuICAgIGV2ZW50LnNoaWZ0S2V5IHx8XG4gICAgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgKGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyKVxuICApXG59XG5cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKFxuICBlOiBSZWFjdC5Nb3VzZUV2ZW50LFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIGxpbmtJbnN0YW5jZVJlZjogUmVhY3QuUmVmT2JqZWN0PExpbmtJbnN0YW5jZSB8IG51bGw+LFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhbixcbiAgb25OYXZpZ2F0ZT86IE9uTmF2aWdhdGVFdmVudEhhbmRsZXJcbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICAvLyBhbmNob3JzIGluc2lkZSBhbiBzdmcgaGF2ZSBhIGxvd2VyY2FzZSBub2RlTmFtZVxuICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0EnXG5cbiAgaWYgKFxuICAgIChpc0FuY2hvck5vZGVOYW1lICYmIGlzTW9kaWZpZWRFdmVudChlKSkgfHxcbiAgICBlLmN1cnJlbnRUYXJnZXQuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpXG4gICkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIC8vIGJyb3dzZXIgZGVmYXVsdCBiZWhhdmlvciBkb2VzIG5vdCByZXBsYWNlIHRoZSBoaXN0b3J5IHN0YXRlXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRvIGl0IG1hbnVhbGx5XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZilcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIGlmIChvbk5hdmlnYXRlKSB7XG4gICAgbGV0IGlzRGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlXG5cbiAgICBvbk5hdmlnYXRlKHtcbiAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZCA9IHRydWVcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGlmIChpc0RlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbihcbiAgICAgIGFzIHx8IGhyZWYsXG4gICAgICByZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnLFxuICAgICAgc2Nyb2xsID8/IHRydWUsXG4gICAgICBsaW5rSW5zdGFuY2VSZWYuY3VycmVudFxuICAgIClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nT3JVcmwodXJsT2JqT3JTdHJpbmc6IFVybE9iamVjdCB8IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgdXJsT2JqT3JTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHVybE9iak9yU3RyaW5nXG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybE9iak9yU3RyaW5nKVxufVxuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgZXh0ZW5kcyB0aGUgSFRNTCBgPGE+YCBlbGVtZW50IHRvIHByb3ZpZGVcbiAqIFtwcmVmZXRjaGluZ10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9saW5raW5nLWFuZC1uYXZpZ2F0aW5nIzItcHJlZmV0Y2hpbmcpXG4gKiBhbmQgY2xpZW50LXNpZGUgbmF2aWdhdGlvbi4gVGhpcyBpcyB0aGUgcHJpbWFyeSB3YXkgdG8gbmF2aWdhdGUgYmV0d2VlbiByb3V0ZXMgaW4gTmV4dC5qcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogLSBQcmVmZXRjaGluZyBpcyBvbmx5IGVuYWJsZWQgaW4gcHJvZHVjdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvbGlua1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMaW5rQ29tcG9uZW50KFxuICBwcm9wczogTGlua1Byb3BzICYge1xuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbiAgICByZWY6IFJlYWN0LlJlZjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgfVxuKSB7XG4gIGNvbnN0IFtsaW5rU3RhdHVzLCBzZXRPcHRpbWlzdGljTGlua1N0YXR1c10gPSB1c2VPcHRpbWlzdGljKElETEVfTElOS19TVEFUVVMpXG5cbiAgbGV0IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcblxuICBjb25zdCBsaW5rSW5zdGFuY2VSZWYgPSB1c2VSZWY8TGlua0luc3RhbmNlIHwgbnVsbD4obnVsbClcblxuICBjb25zdCB7XG4gICAgaHJlZjogaHJlZlByb3AsXG4gICAgYXM6IGFzUHJvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wLFxuICAgIHByZWZldGNoOiBwcmVmZXRjaFByb3AgPSBudWxsLFxuICAgIHBhc3NIcmVmLFxuICAgIHJlcGxhY2UsXG4gICAgc2hhbGxvdyxcbiAgICBzY3JvbGwsXG4gICAgb25DbGljayxcbiAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlclByb3AsXG4gICAgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnRQcm9wLFxuICAgIGxlZ2FjeUJlaGF2aW9yID0gZmFsc2UsXG4gICAgb25OYXZpZ2F0ZSxcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB1bnN0YWJsZV9keW5hbWljT25Ib3ZlcixcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSA9IHByb3BzXG5cbiAgY2hpbGRyZW4gPSBjaGlsZHJlblByb3BcblxuICBpZiAoXG4gICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGRyZW4gPT09ICdudW1iZXInKVxuICApIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICBjb25zdCByb3V0ZXIgPSBSZWFjdC51c2VDb250ZXh0KEFwcFJvdXRlckNvbnRleHQpXG5cbiAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZVxuICAvKipcbiAgICogVGhlIHBvc3NpYmxlIHN0YXRlcyBmb3IgcHJlZmV0Y2ggYXJlOlxuICAgKiAtIG51bGw6IHRoaXMgaXMgdGhlIGRlZmF1bHQgXCJhdXRvXCIgbW9kZSwgd2hlcmUgd2Ugd2lsbCBwcmVmZXRjaCBwYXJ0aWFsbHkgaWYgdGhlIGxpbmsgaXMgaW4gdGhlIHZpZXdwb3J0XG4gICAqIC0gdHJ1ZTogd2Ugd2lsbCBwcmVmZXRjaCBpZiB0aGUgbGluayBpcyB2aXNpYmxlIGFuZCBwcmVmZXRjaCB0aGUgZnVsbCBwYWdlLCBub3QganVzdCBwYXJ0aWFsbHlcbiAgICogLSBmYWxzZTogd2Ugd2lsbCBub3QgcHJlZmV0Y2ggaWYgaW4gdGhlIHZpZXdwb3J0IGF0IGFsbFxuICAgKiAtICd1bnN0YWJsZV9keW5hbWljT25Ib3Zlcic6IHRoaXMgc3RhcnRzIGluIFwiYXV0b1wiIG1vZGUsIGJ1dCBzd2l0Y2hlcyB0byBcImZ1bGxcIiB3aGVuIHRoZSBsaW5rIGlzIGhvdmVyZWRcbiAgICovXG4gIGNvbnN0IGFwcFByZWZldGNoS2luZCA9XG4gICAgcHJlZmV0Y2hQcm9wID09PSBudWxsIHx8IHByZWZldGNoUHJvcCA9PT0gJ2F1dG8nXG4gICAgICA/IFByZWZldGNoS2luZC5BVVRPXG4gICAgICA6IFByZWZldGNoS2luZC5GVUxMXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyOiB0cnVlLFxuICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlLFxuICAgICAgb25OYXZpZ2F0ZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdvbkNsaWNrJyB8fFxuICAgICAgICBrZXkgPT09ICdvbk1vdXNlRW50ZXInIHx8XG4gICAgICAgIGtleSA9PT0gJ29uVG91Y2hTdGFydCcgfHxcbiAgICAgICAga2V5ID09PSAnb25OYXZpZ2F0ZSdcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGZ1bmN0aW9uYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAnbGVnYWN5QmVoYXZpb3InIHx8XG4gICAgICAgIGtleSA9PT0gJ3Vuc3RhYmxlX2R5bmFtaWNPbkhvdmVyJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICE9IG51bGwgJiYgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3ByZWZldGNoJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSAhPSBudWxsICYmXG4gICAgICAgICAgdmFsVHlwZSAhPT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgcHJvcHNba2V5XSAhPT0gJ2F1dG8nXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuIHwgXCJhdXRvXCJgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IF86IG5ldmVyID0ga2V5XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHByb3BzLmxvY2FsZSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdUaGUgYGxvY2FsZWAgcHJvcCBpcyBub3Qgc3VwcG9ydGVkIGluIGBuZXh0L2xpbmtgIHdoaWxlIHVzaW5nIHRoZSBgYXBwYCByb3V0ZXIuIFJlYWQgbW9yZSBhYm91dCBhcHAgcm91dGVyIGludGVybmFsaXphdGlvbjogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcm91dGluZy9pbnRlcm5hdGlvbmFsaXphdGlvbidcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFhc1Byb3ApIHtcbiAgICAgIGxldCBocmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgIGlmICh0eXBlb2YgaHJlZlByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhyZWYgPSBocmVmUHJvcFxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZW9mIGhyZWZQcm9wID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgaHJlZlByb3AucGF0aG5hbWUgPT09ICdzdHJpbmcnXG4gICAgICApIHtcbiAgICAgICAgaHJlZiA9IGhyZWZQcm9wLnBhdGhuYW1lXG4gICAgICB9XG5cbiAgICAgIGlmIChocmVmKSB7XG4gICAgICAgIGNvbnN0IGhhc0R5bmFtaWNTZWdtZW50ID0gaHJlZlxuICAgICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgICAgLnNvbWUoKHNlZ21lbnQpID0+IHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSlcblxuICAgICAgICBpZiAoaGFzRHluYW1pY1NlZ21lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRHluYW1pYyBocmVmIFxcYCR7aHJlZn1cXGAgZm91bmQgaW4gPExpbms+IHdoaWxlIHVzaW5nIHRoZSBcXGAvYXBwXFxgIHJvdXRlciwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2FwcC1kaXItZHluYW1pYy1ocmVmYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgaHJlZiwgYXMgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IGZvcm1hdFN0cmluZ09yVXJsKGhyZWZQcm9wKVxuICAgIHJldHVybiB7XG4gICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICBhczogYXNQcm9wID8gZm9ybWF0U3RyaW5nT3JVcmwoYXNQcm9wKSA6IHJlc29sdmVkSHJlZixcbiAgICB9XG4gIH0sIFtocmVmUHJvcCwgYXNQcm9wXSlcblxuICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgbGV0IGNoaWxkOiBhbnlcbiAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAob25DbGljaykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFwib25DbGlja1wiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25DbGljayBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGlua2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKG9uTW91c2VFbnRlclByb3ApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBObyBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmUgY2hpbGQgaXMgcmVxdWlyZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1uby1jaGlsZHJlbmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBNdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlbmAgK1xuICAgICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgICA6ICcnKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAoKGNoaWxkcmVuIGFzIGFueSk/LnR5cGUgPT09ICdhJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgPExpbms+IHdpdGggPGE+IGNoaWxkLiBQbGVhc2UgcmVtb3ZlIDxhPiBvciB1c2UgPExpbmsgbGVnYWN5QmVoYXZpb3I+LlxcbkxlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtbmV3LWxpbmstd2l0aC1leHRyYS1hbmNob3InXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGlsZFJlZjogYW55ID0gbGVnYWN5QmVoYXZpb3JcbiAgICA/IGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmXG4gICAgOiBmb3J3YXJkZWRSZWZcblxuICAvLyBVc2UgYSBjYWxsYmFjayByZWYgdG8gYXR0YWNoIGFuIEludGVyc2VjdGlvbk9ic2VydmVyIHRvIHRoZSBhbmNob3IgdGFnIG9uXG4gIC8vIG1vdW50LiBJbiB0aGUgZnV0dXJlIHdlIHdpbGwgYWxzbyB1c2UgdGhpcyB0byBrZWVwIHRyYWNrIG9mIGFsbCB0aGVcbiAgLy8gY3VycmVudGx5IG1vdW50ZWQgPExpbms+IGluc3RhbmNlcywgZS5nLiBzbyB3ZSBjYW4gcmUtcHJlZmV0Y2ggdGhlbSBhZnRlclxuICAvLyBhIHJldmFsaWRhdGlvbiBvciByZWZyZXNoLlxuICBjb25zdCBvYnNlcnZlTGlua1Zpc2liaWxpdHlPbk1vdW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsZW1lbnQ6IEhUTUxBbmNob3JFbGVtZW50IHwgU1ZHQUVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChyb3V0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgbGlua0luc3RhbmNlUmVmLmN1cnJlbnQgPSBtb3VudExpbmtJbnN0YW5jZShcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgcm91dGVyLFxuICAgICAgICAgIGFwcFByZWZldGNoS2luZCxcbiAgICAgICAgICBwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgICAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXNcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobGlua0luc3RhbmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB1bm1vdW50TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uKGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50KVxuICAgICAgICAgIGxpbmtJbnN0YW5jZVJlZi5jdXJyZW50ID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZShlbGVtZW50KVxuICAgICAgfVxuICAgIH0sXG4gICAgW3ByZWZldGNoRW5hYmxlZCwgaHJlZiwgcm91dGVyLCBhcHBQcmVmZXRjaEtpbmQsIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzXVxuICApXG5cbiAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VkUmVmKG9ic2VydmVMaW5rVmlzaWJpbGl0eU9uTW91bnQsIGNoaWxkUmVmKVxuXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvblRvdWNoU3RhcnQ/OiBSZWFjdC5Ub3VjaEV2ZW50SGFuZGxlcjxIVE1MQW5jaG9yRWxlbWVudD5cbiAgICBvbk1vdXNlRW50ZXI6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyPEhUTUxBbmNob3JFbGVtZW50PlxuICAgIGhyZWY/OiBzdHJpbmdcbiAgICByZWY/OiBhbnlcbiAgfSA9IHtcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICBvbkNsaWNrKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkNsaWNrKGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsaW5rQ2xpY2tlZChlLCBocmVmLCBhcywgbGlua0luc3RhbmNlUmVmLCByZXBsYWNlLCBzY3JvbGwsIG9uTmF2aWdhdGUpXG4gICAgfSxcbiAgICBvbk1vdXNlRW50ZXIoZSkge1xuICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgbGVnYWN5QmVoYXZpb3IgJiZcbiAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaCA9IHVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyID09PSB0cnVlXG4gICAgICBvbk5hdmlnYXRpb25JbnRlbnQoXG4gICAgICAgIGUuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50LFxuICAgICAgICB1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2hcbiAgICAgIClcbiAgICB9LFxuICAgIG9uVG91Y2hTdGFydDogcHJvY2Vzcy5lbnYuX19ORVhUX0xJTktfTk9fVE9VQ0hfU1RBUlRcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Ub3VjaFN0YXJ0UHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0UHJvcChlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yICYmXG4gICAgICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB1cGdyYWRlVG9EeW5hbWljUHJlZmV0Y2ggPSB1bnN0YWJsZV9keW5hbWljT25Ib3ZlciA9PT0gdHJ1ZVxuICAgICAgICAgIG9uTmF2aWdhdGlvbkludGVudChcbiAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudCB8IFNWR0FFbGVtZW50LFxuICAgICAgICAgICAgdXBncmFkZVRvRHluYW1pY1ByZWZldGNoXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICB9XG5cbiAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlci5cbiAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgYmFzZVBhdGguXG4gIGlmIChpc0Fic29sdXRlVXJsKGFzKSkge1xuICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzXG4gIH0gZWxzZSBpZiAoXG4gICAgIWxlZ2FjeUJlaGF2aW9yIHx8XG4gICAgcGFzc0hyZWYgfHxcbiAgICAoY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSlcbiAgKSB7XG4gICAgY2hpbGRQcm9wcy5ocmVmID0gYWRkQmFzZVBhdGgoYXMpXG4gIH1cblxuICBsZXQgbGluazogUmVhY3QuUmVhY3ROb2RlXG5cbiAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBlcnJvck9uY2UoXG4gICAgICAgICdgbGVnYWN5QmVoYXZpb3JgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSAnICtcbiAgICAgICAgICAncmVsZWFzZS4gQSBjb2RlbW9kIGlzIGF2YWlsYWJsZSB0byB1cGdyYWRlIHlvdXIgY29tcG9uZW50czpcXG5cXG4nICtcbiAgICAgICAgICAnbnB4IEBuZXh0L2NvZGVtb2RAbGF0ZXN0IG5ldy1saW5rIC5cXG5cXG4nICtcbiAgICAgICAgICAnTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vdXBncmFkaW5nL2NvZGVtb2RzI3JlbW92ZS1hLXRhZ3MtZnJvbS1saW5rLWNvbXBvbmVudHMnXG4gICAgICApXG4gICAgfVxuICAgIGxpbmsgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG4gIH0gZWxzZSB7XG4gICAgbGluayA9IChcbiAgICAgIDxhIHsuLi5yZXN0UHJvcHN9IHsuLi5jaGlsZFByb3BzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9hPlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPExpbmtTdGF0dXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtsaW5rU3RhdHVzfT5cbiAgICAgIHtsaW5rfVxuICAgIDwvTGlua1N0YXR1c0NvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cblxuY29uc3QgTGlua1N0YXR1c0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFxuICB0eXBlb2YgUEVORElOR19MSU5LX1NUQVRVUyB8IHR5cGVvZiBJRExFX0xJTktfU1RBVFVTXG4+KElETEVfTElOS19TVEFUVVMpXG5cbmV4cG9ydCBjb25zdCB1c2VMaW5rU3RhdHVzID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChMaW5rU3RhdHVzQ29udGV4dClcbn1cbiJdLCJuYW1lcyI6WyJMaW5rQ29tcG9uZW50IiwidXNlTGlua1N0YXR1cyIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiZXZlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJsaW5rQ2xpY2tlZCIsImUiLCJocmVmIiwiYXMiLCJsaW5rSW5zdGFuY2VSZWYiLCJyZXBsYWNlIiwic2Nyb2xsIiwib25OYXZpZ2F0ZSIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInRvVXBwZXJDYXNlIiwiaGFzQXR0cmlidXRlIiwiaXNMb2NhbFVSTCIsInByZXZlbnREZWZhdWx0IiwibG9jYXRpb24iLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJSZWFjdCIsInN0YXJ0VHJhbnNpdGlvbiIsImRpc3BhdGNoTmF2aWdhdGVBY3Rpb24iLCJjdXJyZW50IiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsImZvcm1hdFVybCIsInByb3BzIiwibGlua1N0YXR1cyIsInNldE9wdGltaXN0aWNMaW5rU3RhdHVzIiwidXNlT3B0aW1pc3RpYyIsIklETEVfTElOS19TVEFUVVMiLCJjaGlsZHJlbiIsInVzZVJlZiIsImhyZWZQcm9wIiwiYXNQcm9wIiwiY2hpbGRyZW5Qcm9wIiwicHJlZmV0Y2giLCJwcmVmZXRjaFByb3AiLCJwYXNzSHJlZiIsInNoYWxsb3ciLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUVudGVyUHJvcCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydFByb3AiLCJsZWdhY3lCZWhhdmlvciIsInJlZiIsImZvcndhcmRlZFJlZiIsInVuc3RhYmxlX2R5bmFtaWNPbkhvdmVyIiwicmVzdFByb3BzIiwiYSIsInJvdXRlciIsInVzZUNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwicHJlZmV0Y2hFbmFibGVkIiwiYXBwUHJlZmV0Y2hLaW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIkZVTEwiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjcmVhdGVQcm9wRXJyb3IiLCJhcmdzIiwiRXJyb3IiLCJrZXkiLCJleHBlY3RlZCIsImFjdHVhbCIsIndpbmRvdyIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImxvY2FsZSIsIndhcm5PbmNlIiwicGF0aG5hbWUiLCJoYXNEeW5hbWljU2VnbWVudCIsInNwbGl0Iiwic29tZSIsInNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwiY2hpbGQiLCJjb25zb2xlIiwid2FybiIsIkNoaWxkcmVuIiwib25seSIsImVyciIsInR5cGUiLCJjaGlsZFJlZiIsIm9ic2VydmVMaW5rVmlzaWJpbGl0eU9uTW91bnQiLCJ1c2VDYWxsYmFjayIsImVsZW1lbnQiLCJtb3VudExpbmtJbnN0YW5jZSIsInVubW91bnRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24iLCJ1bm1vdW50UHJlZmV0Y2hhYmxlSW5zdGFuY2UiLCJtZXJnZWRSZWYiLCJ1c2VNZXJnZWRSZWYiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInVwZ3JhZGVUb0R5bmFtaWNQcmVmZXRjaCIsIm9uTmF2aWdhdGlvbkludGVudCIsIl9fTkVYVF9MSU5LX05PX1RPVUNIX1NUQVJUIiwidW5kZWZpbmVkIiwiaXNBYnNvbHV0ZVVybCIsImFkZEJhc2VQYXRoIiwibGluayIsImVycm9yT25jZSIsImNsb25lRWxlbWVudCIsIkxpbmtTdGF0dXNDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImNyZWF0ZUNvbnRleHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(null);\n    const cleanupB = (0, _react.useRef)(null);\n    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n    // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n    // (because it hasn't been updated for React 19)\n    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n    return (0, _react.useCallback)((current)=>{\n        if (current === null) {\n            const cleanupFnA = cleanupA.current;\n            if (cleanupFnA) {\n                cleanupA.current = null;\n                cleanupFnA();\n            }\n            const cleanupFnB = cleanupB.current;\n            if (cleanupFnB) {\n                cleanupB.current = null;\n                cleanupFnB();\n            }\n        } else {\n            if (refA) {\n                cleanupA.current = applyRef(refA, current);\n            }\n            if (refB) {\n                cleanupB.current = applyRef(refB, current);\n            }\n        }\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDhCO0FBU3ZDLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUM3QyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUE0QjtJQUU3QyxtRkFBbUY7SUFDbkYseUVBQXlFO0lBQ3pFLGlHQUFpRztJQUNqRyw4RkFBOEY7SUFDOUYsZ0RBQWdEO0lBQ2hELG1HQUFtRztJQUNuRyx3RkFBd0Y7SUFDeEYsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBQUEsRUFDTCxDQUFDQztRQUNDLElBQUlBLFlBQVksTUFBTTtZQUNwQixNQUFNQyxhQUFhTCxTQUFTSSxPQUFPO1lBQ25DLElBQUlDLFlBQVk7Z0JBQ2RMLFNBQVNJLE9BQU8sR0FBRztnQkFDbkJDO1lBQ0Y7WUFDQSxNQUFNQyxhQUFhSixTQUFTRSxPQUFPO1lBQ25DLElBQUlFLFlBQVk7Z0JBQ2RKLFNBQVNFLE9BQU8sR0FBRztnQkFDbkJFO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSVIsTUFBTTtnQkFDUkUsU0FBU0ksT0FBTyxHQUFHRyxTQUFTVCxNQUFNTTtZQUNwQztZQUNBLElBQUlMLE1BQU07Z0JBQ1JHLFNBQVNFLE9BQU8sR0FBR0csU0FBU1IsTUFBTUs7WUFDcEM7UUFDRjtJQUNGLEdBQ0E7UUFBQ047UUFBTUM7S0FBSztBQUVoQjtBQUVBLFNBQVNRLFNBQ1BULElBQWdDLEVBQ2hDTSxPQUFpQjtJQUVqQixJQUFJLE9BQU9OLFNBQVMsWUFBWTtRQUM5QixNQUFNVSxVQUFVVixLQUFLTTtRQUNyQixJQUFJLE9BQU9JLFlBQVksWUFBWTtZQUNqQyxPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPLElBQU1WLEtBQUs7UUFDcEI7SUFDRixPQUFPO1FBQ0xBLEtBQUtNLE9BQU8sR0FBR0E7UUFDZixPQUFPO1lBQ0xOLEtBQUtNLE9BQU8sR0FBRztRQUNqQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxzcmNcXGNsaWVudFxcdXNlLW1lcmdlZC1yZWYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdHlwZSBSZWYgfSBmcm9tICdyZWFjdCdcblxuLy8gVGhpcyBpcyBhIGNvbXBhdGliaWxpdHkgaG9vayB0byBzdXBwb3J0IFJlYWN0IDE4IGFuZCAxOSByZWZzLlxuLy8gSW4gMTksIGEgY2xlYW51cCBmdW5jdGlvbiBmcm9tIHJlZnMgbWF5IGJlIHJldHVybmVkLlxuLy8gSW4gMTgsIHJldHVybmluZyBhIGNsZWFudXAgZnVuY3Rpb24gY3JlYXRlcyBhIHdhcm5pbmcuXG4vLyBTaW5jZSB3ZSB0YWtlIHVzZXJzcGFjZSByZWZzLCB3ZSBkb24ndCBrbm93IGFoZWFkIG9mIHRpbWUgaWYgYSBjbGVhbnVwIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG4vLyBUaGlzIGltcGxlbWVudHMgY2xlYW51cCBmdW5jdGlvbnMgd2l0aCB0aGUgb2xkIGJlaGF2aW9yIGluIDE4LlxuLy8gV2Uga25vdyByZWZzIGFyZSBhbHdheXMgY2FsbGVkIGFsdGVybmF0aW5nIHdpdGggYG51bGxgIGFuZCB0aGVuIGBUYC5cbi8vIFNvIGEgY2FsbCB3aXRoIGBudWxsYCBtZWFucyB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByZXZpb3VzIGNsZWFudXAgZnVuY3Rpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZjxURWxlbWVudD4oXG4gIHJlZkE6IFJlZjxURWxlbWVudD4sXG4gIHJlZkI6IFJlZjxURWxlbWVudD5cbik6IFJlZjxURWxlbWVudD4ge1xuICBjb25zdCBjbGVhbnVwQSA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxuICBjb25zdCBjbGVhbnVwQiA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxuXG4gIC8vIE5PVEU6IEluIHRoZW9yeSwgd2UgY291bGQgc2tpcCB0aGUgd3JhcHBpbmcgaWYgb25seSBvbmUgb2YgdGhlIHJlZnMgaXMgbm9uLW51bGwuXG4gIC8vICh0aGlzIGhhcHBlbnMgb2Z0ZW4gaWYgdGhlIHVzZXIgZG9lc24ndCBwYXNzIGEgcmVmIHRvIExpbmsvRm9ybS9JbWFnZSlcbiAgLy8gQnV0IHRoaXMgY2FuIGNhdXNlIHVzIHRvIGxlYWsgYSBjbGVhbnVwLXJlZiBpbnRvIHVzZXIgY29kZSAoZS5nLiB2aWEgYDxMaW5rIGxlZ2FjeUJlaGF2aW9yPmApLFxuICAvLyBhbmQgdGhlIHVzZXIgbWlnaHQgcGFzcyB0aGF0IHJlZiBpbnRvIHJlZi1tZXJnaW5nIGxpYnJhcnkgdGhhdCBkb2Vzbid0IHN1cHBvcnQgY2xlYW51cCByZWZzXG4gIC8vIChiZWNhdXNlIGl0IGhhc24ndCBiZWVuIHVwZGF0ZWQgZm9yIFJlYWN0IDE5KVxuICAvLyB3aGljaCBjYW4gdGhlbiBjYXVzZSB0aGluZ3MgdG8gYmxvdyB1cCwgYmVjYXVzZSBhIGNsZWFudXAtcmV0dXJuaW5nIHJlZiBnZXRzIGNhbGxlZCB3aXRoIGBudWxsYC5cbiAgLy8gU28gaW4gcHJhY3RpY2UsIGl0J3Mgc2FmZXIgdG8gYmUgZGVmZW5zaXZlIGFuZCBhbHdheXMgd3JhcCB0aGUgcmVmLCBldmVuIG9uIFJlYWN0IDE5LlxuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKGN1cnJlbnQ6IFRFbGVtZW50IHwgbnVsbCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2xlYW51cEZuQSA9IGNsZWFudXBBLmN1cnJlbnRcbiAgICAgICAgaWYgKGNsZWFudXBGbkEpIHtcbiAgICAgICAgICBjbGVhbnVwQS5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgIGNsZWFudXBGbkEoKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsZWFudXBGbkIgPSBjbGVhbnVwQi5jdXJyZW50XG4gICAgICAgIGlmIChjbGVhbnVwRm5CKSB7XG4gICAgICAgICAgY2xlYW51cEIuY3VycmVudCA9IG51bGxcbiAgICAgICAgICBjbGVhbnVwRm5CKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlZkEpIHtcbiAgICAgICAgICBjbGVhbnVwQS5jdXJyZW50ID0gYXBwbHlSZWYocmVmQSwgY3VycmVudClcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmQikge1xuICAgICAgICAgIGNsZWFudXBCLmN1cnJlbnQgPSBhcHBseVJlZihyZWZCLCBjdXJyZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbcmVmQSwgcmVmQl1cbiAgKVxufVxuXG5mdW5jdGlvbiBhcHBseVJlZjxURWxlbWVudD4oXG4gIHJlZkE6IE5vbk51bGxhYmxlPFJlZjxURWxlbWVudD4+LFxuICBjdXJyZW50OiBURWxlbWVudFxuKSB7XG4gIGlmICh0eXBlb2YgcmVmQSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNsZWFudXAgPSByZWZBKGN1cnJlbnQpXG4gICAgaWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2xlYW51cFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCkgPT4gcmVmQShudWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWZBLmN1cnJlbnQgPSBjdXJyZW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZkEuY3VycmVudCA9IG51bGxcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VNZXJnZWRSZWYiLCJyZWZBIiwicmVmQiIsImNsZWFudXBBIiwidXNlUmVmIiwiY2xlYW51cEIiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJjbGVhbnVwRm5BIiwiY2xlYW51cEZuQiIsImFwcGx5UmVmIiwiY2xlYW51cCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes'\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsU0FBUztlQUFUQTs7SUE2REFDLG9CQUFvQjtlQUFwQkE7O0lBZkhDLGFBQWE7ZUFBYkE7Ozs7bUZBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBUSxNQUFHUixXQUFTLE1BQUtBLFFBQUFBLENBQU87UUFDakUsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2ZKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUMzQjtJQUNGO0lBRUEsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdENBLFFBQVFNLE9BQU9DLGFBQVlDLHNCQUFzQixDQUFDUjtJQUNwRDtJQUVBLElBQUlTLFNBQVNmLE9BQU9lLE1BQU0sSUFBS1QsU0FBVSxNQUFHQSxTQUFZO0lBRXhELElBQUlILFlBQVksQ0FBQ0EsU0FBU2EsUUFBUSxDQUFDLE1BQU1iLFlBQVk7SUFFckQsSUFDRUgsT0FBT2lCLE9BQU8sSUFDWixFQUFDZCxZQUFZSixpQkFBaUJtQixJQUFJLENBQUNmLFNBQUFBLENBQVEsSUFBTUksU0FBUyxPQUM1RDtRQUNBQSxPQUFPLE9BQVFBLENBQUFBLFFBQVEsR0FBQztRQUN4QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDeEQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDaEJBLE9BQU87SUFDVDtJQUVBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJVSxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFFaERYLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ08sU0FBU0EsT0FBT04sT0FBTyxDQUFDLEtBQUs7SUFFN0IsT0FBUSxLQUFFTixXQUFXSSxPQUFPSCxXQUFXVyxTQUFTVjtBQUNsRDtBQUVPLE1BQU1QLGdCQUFnQjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLFNBQVNELHFCQUFxQnNCLEdBQWM7SUFDakQsSUFBSUMsSUFBb0IsRUFBb0I7UUFDMUMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0ksT0FBT0MsSUFBSSxDQUFDTCxLQUFLTSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQzVCLGNBQWM2QixRQUFRLENBQUNELE1BQU07b0JBQ2hDRSxRQUFRQyxJQUFJLENBQ1QsdURBQW9ESDtnQkFFekQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPOUIsVUFBVXVCO0FBQ25CIiwic291cmNlcyI6WyJEOlxcc3JjXFxzaGFyZWRcXGxpYlxccm91dGVyXFx1dGlsc1xcZm9ybWF0LXVybC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGb3JtYXQgZnVuY3Rpb24gbW9kaWZpZWQgZnJvbSBub2RlanNcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS9cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmo6IFVybE9iamVjdCkge1xuICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqXG4gIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJ1xuICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJydcbiAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJ1xuICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJydcbiAgbGV0IGhvc3Q6IHN0cmluZyB8IGZhbHNlID0gZmFsc2VcblxuICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnXG5cbiAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB1cmxPYmouaG9zdFxuICB9IGVsc2UgaWYgKGhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKVxuICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB1cmxPYmoucG9ydFxuICAgIH1cbiAgfVxuXG4gIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgcXVlcnkgPSBTdHJpbmcocXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhxdWVyeSBhcyBQYXJzZWRVcmxRdWVyeSkpXG4gIH1cblxuICBsZXQgc2VhcmNoID0gdXJsT2JqLnNlYXJjaCB8fCAocXVlcnkgJiYgYD8ke3F1ZXJ5fWApIHx8ICcnXG5cbiAgaWYgKHByb3RvY29sICYmICFwcm90b2NvbC5lbmRzV2l0aCgnOicpKSBwcm90b2NvbCArPSAnOidcblxuICBpZiAoXG4gICAgdXJsT2JqLnNsYXNoZXMgfHxcbiAgICAoKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSlcbiAgKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJylcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnXG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoWzBdICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaFxuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpXG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpXG5cbiAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gXG59XG5cbmV4cG9ydCBjb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAnYXV0aCcsXG4gICdoYXNoJyxcbiAgJ2hvc3QnLFxuICAnaG9zdG5hbWUnLFxuICAnaHJlZicsXG4gICdwYXRoJyxcbiAgJ3BhdGhuYW1lJyxcbiAgJ3BvcnQnLFxuICAncHJvdG9jb2wnLFxuICAncXVlcnknLFxuICAnc2VhcmNoJyxcbiAgJ3NsYXNoZXMnLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsOiBVcmxPYmplY3QpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXVybE9iamVjdEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmwpXG59XG4iXSwibmFtZXMiOlsiZm9ybWF0VXJsIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJ1cmxPYmplY3RLZXlzIiwic2xhc2hlZFByb3RvY29scyIsInVybE9iaiIsImF1dGgiLCJob3N0bmFtZSIsInByb3RvY29sIiwicGF0aG5hbWUiLCJoYXNoIiwicXVlcnkiLCJob3N0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImluZGV4T2YiLCJwb3J0IiwiU3RyaW5nIiwicXVlcnlzdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7bUNBTmlDO3lDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQUFBLEVBQWNELE1BQU0sT0FBTztJQUNoQyxJQUFJO1FBQ0YsNERBQTREO1FBQzVELE1BQU1FLGlCQUFpQkMsQ0FBQUEsR0FBQUEsT0FBQUEsaUJBQUFBO1FBQ3ZCLE1BQU1DLFdBQVcsSUFBSUMsSUFBSUwsS0FBS0U7UUFDOUIsT0FBT0UsU0FBU0UsTUFBTSxLQUFLSixrQkFBa0JLLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlILFNBQVNJLFFBQVE7SUFDNUUsRUFBRSxPQUFPQyxHQUFHO1FBQ1YsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxzcmNcXHNoYXJlZFxcbGliXFxyb3V0ZXJcXHV0aWxzXFxpcy1sb2NhbC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNBYnNvbHV0ZVVybCwgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGgnXG5cbi8qKlxuICogRGV0ZWN0cyB3aGV0aGVyIGEgZ2l2ZW4gdXJsIGlzIHJvdXRhYmxlIGJ5IHRoZSBOZXh0LmpzIHJvdXRlciAoYnJvd3NlciBvbmx5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gcHJldmVudCBhIGh5ZHJhdGlvbiBtaXNtYXRjaCBvbiBocmVmIGZvciB1cmwgd2l0aCBhbmNob3IgcmVmc1xuICBpZiAoIWlzQWJzb2x1dGVVcmwodXJsKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iXSwibmFtZXMiOlsiaXNMb2NhbFVSTCIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJoYXNCYXNlUGF0aCIsInBhdGhuYW1lIiwiXyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    for (const [key, value] of searchParams.entries()){\n        const existing = query[key];\n        if (typeof existing === 'undefined') {\n            query[key] = value;\n        } else if (Array.isArray(existing)) {\n            existing.push(value);\n        } else {\n            query[key] = [\n                existing,\n                value\n            ];\n        }\n    }\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === 'string') {\n        return param;\n    }\n    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n        return String(param);\n    } else {\n        return '';\n    }\n}\nfunction urlQueryToSearchParams(query) {\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(query)){\n        if (Array.isArray(value)) {\n            for (const item of value){\n                searchParams.append(key, stringifyUrlQueryParam(item));\n            }\n        } else {\n            searchParams.set(key, stringifyUrlQueryParam(value));\n        }\n    }\n    return searchParams;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    for (const searchParams of searchParamsList){\n        for (const key of searchParams.keys()){\n            target.delete(key);\n        }\n        for (const [key, value] of searchParams.entries()){\n            target.append(key, value);\n        }\n    }\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBZ0RnQkEsTUFBTTtlQUFOQTs7SUE5Q0FDLHNCQUFzQjtlQUF0QkE7O0lBZ0NBQyxzQkFBc0I7ZUFBdEJBOzs7QUFoQ1QsU0FBU0QsdUJBQ2RFLFlBQTZCO0lBRTdCLE1BQU1DLFFBQXdCLENBQUM7SUFDL0IsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUgsYUFBYUksT0FBTyxHQUFJO1FBQ2pELE1BQU1DLFdBQVdKLEtBQUssQ0FBQ0MsSUFBSTtRQUMzQixJQUFJLE9BQU9HLGFBQWEsYUFBYTtZQUNuQ0osS0FBSyxDQUFDQyxJQUFJLEdBQUdDO1FBQ2YsT0FBTyxJQUFJRyxNQUFNQyxPQUFPLENBQUNGLFdBQVc7WUFDbENBLFNBQVNHLElBQUksQ0FBQ0w7UUFDaEIsT0FBTztZQUNMRixLQUFLLENBQUNDLElBQUksR0FBRztnQkFBQ0c7Z0JBQVVGO2FBQU07UUFDaEM7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQSxTQUFTUSx1QkFBdUJDLEtBQWM7SUFDNUMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDN0IsT0FBT0E7SUFDVDtJQUVBLElBQ0csT0FBT0EsVUFBVSxZQUFZLENBQUNDLE1BQU1ELFVBQ3JDLE9BQU9BLFVBQVUsV0FDakI7UUFDQSxPQUFPRSxPQUFPRjtJQUNoQixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTWCx1QkFBdUJFLEtBQXFCO0lBQzFELE1BQU1ELGVBQWUsSUFBSWE7SUFDekIsS0FBSyxNQUFNLENBQUNYLEtBQUtDLE1BQU0sSUFBSVcsT0FBT1YsT0FBTyxDQUFDSCxPQUFRO1FBQ2hELElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osUUFBUTtZQUN4QixLQUFLLE1BQU1ZLFFBQVFaLE1BQU87Z0JBQ3hCSCxhQUFhZ0IsTUFBTSxDQUFDZCxLQUFLTyx1QkFBdUJNO1lBQ2xEO1FBQ0YsT0FBTztZQUNMZixhQUFhaUIsR0FBRyxDQUFDZixLQUFLTyx1QkFBdUJOO1FBQy9DO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBRU8sU0FBU0gsT0FDZHFCLE1BQXVCO0lBQ3ZCLGlDQUFHQyxtQkFBSDtRQUFHQSxnQkFBQUEsQ0FBSCwyQkFBc0M7O0lBRXRDLEtBQUssTUFBTW5CLGdCQUFnQm1CLGlCQUFrQjtRQUMzQyxLQUFLLE1BQU1qQixPQUFPRixhQUFhb0IsSUFBSSxHQUFJO1lBQ3JDRixPQUFPRyxNQUFNLENBQUNuQjtRQUNoQjtRQUVBLEtBQUssTUFBTSxDQUFDQSxLQUFLQyxNQUFNLElBQUlILGFBQWFJLE9BQU8sR0FBSTtZQUNqRGMsT0FBT0YsTUFBTSxDQUFDZCxLQUFLQztRQUNyQjtJQUNGO0lBRUEsT0FBT2U7QUFDVCIsInNvdXJjZXMiOlsiRDpcXHNyY1xcc2hhcmVkXFxsaWJcXHJvdXRlclxcdXRpbHNcXHF1ZXJ5c3RyaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBQYXJzZWRVcmxRdWVyeSB7XG4gIGNvbnN0IHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHF1ZXJ5W2tleV1cbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcXVlcnlba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nKSkge1xuICAgICAgZXhpc3RpbmcucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlba2V5XSA9IFtleGlzdGluZywgdmFsdWVdXG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfVxuXG4gIGlmIChcbiAgICAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocGFyYW0pKSB8fFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnk6IFBhcnNlZFVybFF1ZXJ5KTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihcbiAgdGFyZ2V0OiBVUkxTZWFyY2hQYXJhbXMsXG4gIC4uLnNlYXJjaFBhcmFtc0xpc3Q6IFVSTFNlYXJjaFBhcmFtc1tdXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBmb3IgKGNvbnN0IHNlYXJjaFBhcmFtcyBvZiBzZWFyY2hQYXJhbXNMaXN0KSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2VhcmNoUGFyYW1zLmtleXMoKSkge1xuICAgICAgdGFyZ2V0LmRlbGV0ZShrZXkpXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgICAgdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRcbn1cbiJdLCJuYW1lcyI6WyJhc3NpZ24iLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5Iiwia2V5IiwidmFsdWUiLCJlbnRyaWVzIiwiZXhpc3RpbmciLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInBhcmFtIiwiaXNOYU4iLCJTdHJpbmciLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJpdGVtIiwiYXBwZW5kIiwic2V0IiwidGFyZ2V0Iiwic2VhcmNoUGFyYW1zTGlzdCIsImtleXMiLCJkZWxldGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? ':' + port : '');\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\" + urlParts.slice(1).join('?') : '');\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== 'undefined';\nconst ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.name = 'PageNotFoundError';\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvYWFBLFdBQVc7ZUFBWEE7O0lBb0JBQyx1QkFBdUI7ZUFBdkJBOztJQVBBQyxpQkFBaUI7ZUFBakJBOztJQVpBQyxjQUFjO2VBQWRBOztJQUNBQyxpQkFBaUI7ZUFBakJBOztJQVRBQyxFQUFFO2VBQUZBOztJQUNBQyxFQUFFO2VBQUZBOztJQWxYQUMsVUFBVTtlQUFWQTs7SUFzUUdDLFFBQVE7ZUFBUkE7O0lBK0JBQyxjQUFjO2VBQWRBOztJQVhBQyxpQkFBaUI7ZUFBakJBOztJQUtBQyxNQUFNO2VBQU5BOztJQVBIQyxhQUFhO2VBQWJBOztJQW1CR0MsU0FBUztlQUFUQTs7SUFrQk1DLG1CQUFtQjtlQUFuQkE7O0lBZE5DLHdCQUF3QjtlQUF4QkE7O0lBK0dBQyxjQUFjO2VBQWRBOzs7QUE5WlQsTUFBTVQsYUFBYTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFPO0FBc1E5RCxTQUFTQyxTQUNkUyxFQUFLO0lBRUwsSUFBSUMsT0FBTztJQUNYLElBQUlDO0lBRUosT0FBUTt5Q0FBSUMsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O1FBQ1YsSUFBSSxDQUFDRixNQUFNO1lBQ1RBLE9BQU87WUFDUEMsU0FBU0YsTUFBTUc7UUFDakI7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLE1BQU1FLHFCQUFxQjtBQUNwQixNQUFNVCxnQkFBZ0IsQ0FBQ1UsTUFBZ0JELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUUvRCxTQUFTWjtJQUNkLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRSxHQUFHQyxPQUFPQyxRQUFRO0lBQ3BELE9BQVVKLFdBQVMsT0FBSUMsV0FBV0MsUUFBTyxNQUFNQSxPQUFPLEdBQUM7QUFDekQ7QUFFTyxTQUFTZjtJQUNkLE1BQU0sRUFBRWtCLElBQUksRUFBRSxHQUFHRixPQUFPQyxRQUFRO0lBQ2hDLE1BQU1FLFNBQVNwQjtJQUNmLE9BQU9tQixLQUFLRSxTQUFTLENBQUNELE9BQU9FLE1BQU07QUFDckM7QUFFTyxTQUFTdkIsZUFBa0J3QixTQUEyQjtJQUMzRCxPQUFPLE9BQU9BLGNBQWMsV0FDeEJBLFlBQ0FBLFVBQVVDLFdBQVcsSUFBSUQsVUFBVUUsSUFBSSxJQUFJO0FBQ2pEO0FBRU8sU0FBU3RCLFVBQVV1QixHQUFtQjtJQUMzQyxPQUFPQSxJQUFJQyxRQUFRLElBQUlELElBQUlFLFdBQVc7QUFDeEM7QUFFTyxTQUFTdkIseUJBQXlCTyxHQUFXO0lBQ2xELE1BQU1pQixXQUFXakIsSUFBSWtCLEtBQUssQ0FBQztJQUMzQixNQUFNQyxhQUFhRixRQUFRLENBQUMsRUFBRTtJQUU5QixPQUNFRSxXQUNFLDREQUE0RDtJQUM1RCwwQ0FBMEM7S0FDekNDLE9BQU8sQ0FBQyxPQUFPLEtBQ2ZBLE9BQU8sQ0FBQyxVQUFVLE9BQ3BCSCxDQUFBQSxRQUFRLENBQUMsRUFBRSxHQUFJLE1BQUdBLFNBQVNJLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsT0FBUyxHQUFDO0FBRXhEO0FBRU8sZUFBZTlCLG9CQUlwQitCLEdBQWdDLEVBQUVDLEdBQU07SUFDeEMsSUFBSUMsSUFBb0IsRUFBbUI7WUFDckNGO1FBQUosS0FBSUEsaUJBQUFBLElBQUlLLFNBQUFBLEtBQVMsZ0JBQWJMLGVBQWVNLGVBQWUsRUFBRTtZQUNsQyxNQUFNQyxVQUFXLE1BQUczQyxlQUNsQm9DLE9BQ0E7WUFDRixNQUFNLHFCQUFrQixDQUFsQixJQUFJUSxNQUFNRCxVQUFWO3VCQUFBOzRCQUFBOzhCQUFBO1lBQWlCO1FBQ3pCO0lBQ0Y7SUFDQSxpREFBaUQ7SUFDakQsTUFBTWhCLE1BQU1VLElBQUlWLEdBQUcsSUFBS1UsSUFBSUEsR0FBRyxJQUFJQSxJQUFJQSxHQUFHLENBQUNWLEdBQUc7SUFFOUMsSUFBSSxDQUFDUyxJQUFJTSxlQUFlLEVBQUU7UUFDeEIsSUFBSUwsSUFBSUEsR0FBRyxJQUFJQSxJQUFJYixTQUFTLEVBQUU7WUFDNUIsK0JBQStCO1lBQy9CLE9BQU87Z0JBQ0xxQixXQUFXLE1BQU14QyxvQkFBb0JnQyxJQUFJYixTQUFTLEVBQUVhLElBQUlBLEdBQUc7WUFDN0Q7UUFDRjtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBRUEsTUFBTVMsUUFBUSxNQUFNVixJQUFJTSxlQUFlLENBQUNMO0lBRXhDLElBQUlWLE9BQU92QixVQUFVdUIsTUFBTTtRQUN6QixPQUFPbUI7SUFDVDtJQUVBLElBQUksQ0FBQ0EsT0FBTztRQUNWLE1BQU1ILFVBQVcsTUFBRzNDLGVBQ2xCb0MsT0FDQSxpRUFBOERVLFFBQU07UUFDdEUsTUFBTSxxQkFBa0IsQ0FBbEIsSUFBSUYsTUFBTUQsVUFBVjttQkFBQTt3QkFBQTswQkFBQTtRQUFpQjtJQUN6QjtJQUVBLElBQUlMLElBQW9CLEVBQW1CO1FBQ3pDLElBQUlTLE9BQU9DLElBQUksQ0FBQ0YsT0FBT3ZCLE1BQU0sS0FBSyxLQUFLLENBQUNjLElBQUlBLEdBQUcsRUFBRTtZQUMvQ1ksUUFBUUMsSUFBSSxDQUNULEtBQUVsRCxlQUNEb0MsT0FDQTtRQUVOO0lBQ0Y7SUFFQSxPQUFPVTtBQUNUO0FBRU8sTUFBTWxELEtBQUssT0FBT3VELGdCQUFnQjtBQUNsQyxNQUFNdEQsS0FDWEQsTUFDQztJQUFDO0lBQVE7SUFBVztDQUFtQixDQUFXd0QsS0FBSyxDQUN0RCxDQUFDQyxTQUFXLE9BQU9GLFdBQVcsQ0FBQ0UsT0FBTyxLQUFLO0FBR3hDLE1BQU05RCxvQkFBb0JxRDtBQUFPO0FBQ2pDLE1BQU1sRCx1QkFBdUJrRDtBQUFPO0FBQ3BDLE1BQU1qRCwwQkFBMEJpRDtJQUdyQ1UsWUFBWUMsSUFBWSxDQUFFO1FBQ3hCLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQzlCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2lCLE9BQU8sR0FBSSxrQ0FBK0JZO0lBQ2pEO0FBQ0Y7QUFFTyxNQUFNOUQsMEJBQTBCbUQ7SUFDckNVLFlBQVlDLElBQVksRUFBRVosT0FBZSxDQUFFO1FBQ3pDLEtBQUs7UUFDTCxJQUFJLENBQUNBLE9BQU8sR0FBSSwwQ0FBdUNZLE9BQUssTUFBR1o7SUFDakU7QUFDRjtBQUVPLE1BQU1uRCxnQ0FBZ0NvRDtJQUUzQ1UsYUFBYztRQUNaLEtBQUs7UUFDTCxJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2IsT0FBTyxHQUFJO0lBQ2xCO0FBQ0Y7QUFXTyxTQUFTcEMsZUFBZWtELEtBQVk7SUFDekMsT0FBT0MsS0FBS0MsU0FBUyxDQUFDO1FBQUVoQixTQUFTYyxNQUFNZCxPQUFPO1FBQUVpQixPQUFPSCxNQUFNRyxLQUFLO0lBQUM7QUFDckUiLCJzb3VyY2VzIjpbIkQ6XFxzcmNcXHNoYXJlZFxcbGliXFx1dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEh0bWxQcm9wcyB9IGZyb20gJy4vaHRtbC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlLCBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgUHJldmlld0RhdGEgfSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB0eXBlIHsgQ09NUElMRVJfTkFNRVMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIGZzIGZyb20gJ2ZzJ1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQ29udGV4dCBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJbml0aWFsUHJvcHMgPSB7fSxcbiAgUHJvcHMgPSB7fSxcbj4gPSBDb21wb25lbnRUeXBlPFByb3BzPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQ29udGV4dCk6IEluaXRpYWxQcm9wcyB8IFByb21pc2U8SW5pdGlhbFByb3BzPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPlxuXG5leHBvcnQgdHlwZSBBcHBUeXBlPFAgPSB7fT4gPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIFAsXG4gIEFwcFByb3BzVHlwZTxhbnksIFA+XG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFdFQl9WSVRBTFMgPSBbJ0NMUycsICdGQ1AnLCAnRklEJywgJ0lOUCcsICdMQ1AnLCAnVFRGQiddIGFzIGNvbnN0XG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbiAgYXR0cmlidXRpb24/OiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfVxufSAmIChcbiAgfCB7XG4gICAgICBsYWJlbDogJ3dlYi12aXRhbCdcbiAgICAgIG5hbWU6ICh0eXBlb2YgV0VCX1ZJVEFMUylbbnVtYmVyXVxuICAgIH1cbiAgfCB7XG4gICAgICBsYWJlbDogJ2N1c3RvbSdcbiAgICAgIG5hbWU6XG4gICAgICAgIHwgJ05leHQuanMtaHlkcmF0aW9uJ1xuICAgICAgICB8ICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInXG4gICAgICAgIHwgJ05leHQuanMtcmVuZGVyJ1xuICAgIH1cbilcblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBEb2N1bWVudEluaXRpYWxQcm9wcyB8IFByb21pc2U8RG9jdW1lbnRJbml0aWFsUHJvcHM+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgaXNFeHBlcmltZW50YWxDb21waWxlPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogKHN0cmluZyB8IG51bWJlcilbXVxuICBlcnI/OiBFcnJvciAmIHtcbiAgICBzdGF0dXNDb2RlPzogbnVtYmVyXG4gICAgc291cmNlPzogdHlwZW9mIENPTVBJTEVSX05BTUVTLnNlcnZlciB8IHR5cGVvZiBDT01QSUxFUl9OQU1FUy5lZGdlU2VydmVyXG4gIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IHJlYWRvbmx5IERvbWFpbkxvY2FsZVtdXG4gIHNjcmlwdExvYWRlcj86IGFueVtdXG4gIGlzUHJldmlldz86IGJvb2xlYW5cbiAgbm90Rm91bmRTcmNQYWdlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBsb2NhbGVcbiAgICovXG4gIGxvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIGNvbmZpZ3VyZWQgbG9jYWxlc1xuICAgKi9cbiAgbG9jYWxlcz86IHJlYWRvbmx5IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJlZCBkZWZhdWx0IGxvY2FsZVxuICAgKi9cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8Um91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzPFBhZ2VQcm9wcyA9IGFueT4gPSB7XG4gIHBhZ2VQcm9wczogUGFnZVByb3BzXG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUm91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFBhZ2VQcm9wcyA9IHt9LFxuPiA9IEFwcEluaXRpYWxQcm9wczxQYWdlUHJvcHM+ICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBhbnk+XG4gIHJvdXRlcjogUm91dGVyXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxuICBkZWZhdWx0R2V0SW5pdGlhbFByb3BzKFxuICAgIGN0eDogRG9jdW1lbnRDb250ZXh0LFxuICAgIG9wdGlvbnM/OiB7IG5vbmNlPzogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxEb2N1bWVudEluaXRpYWxQcm9wcz5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IEl0ZXJhYmxlPFJlYWN0LlJlYWN0Tm9kZT4gfCBKU1guRWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiBIdG1sUHJvcHNcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiBQYXJ0aWFsPHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9PlxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczogUGFydGlhbDx7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH0+XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBkcmFmdE1vZGU/OiBib29sZWFuXG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IFByZXZpZXdEYXRhXG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8RGF0YSA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPERhdGE+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8RGF0YT5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFNldCBkcmFmdCBtb2RlXG4gICAqL1xuICBzZXREcmFmdE1vZGU6IChvcHRpb25zOiB7IGVuYWJsZTogYm9vbGVhbiB9KSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBwYXRoIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIHdvcmsgdW5kZXIuIEJ5IGRlZmF1bHQsXG4gICAgICAgKiB0aGUgcGF0aCBpcyBjb25zaWRlcmVkIHRoZSBcImRlZmF1bHQgcGF0aFwiLCBpLmUuLCBhbnkgcGFnZXMgdW5kZXIgXCIvXCIuXG4gICAgICAgKi9cbiAgICAgIHBhdGg/OiBzdHJpbmdcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIENsZWFyIHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIGNsZWFyUHJldmlld0RhdGE6IChvcHRpb25zPzogeyBwYXRoPzogc3RyaW5nIH0pID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBSZXZhbGlkYXRlIGEgc3BlY2lmaWMgcGFnZSBhbmQgcmVnZW5lcmF0ZSBpdCB1c2luZyBPbi1EZW1hbmQgSW5jcmVtZW50YWxcbiAgICogU3RhdGljIFJlZ2VuZXJhdGlvbi5cbiAgICogVGhlIHBhdGggc2hvdWxkIGJlIGFuIGFjdHVhbCBwYXRoLCBub3QgYSByZXdyaXR0ZW4gcGF0aC4gRS5nLiBmb3JcbiAgICogXCIvYmxvZy9bc2x1Z11cIiB0aGlzIHNob3VsZCBiZSBcIi9ibG9nL3Bvc3QtMVwiLlxuICAgKiBAbGluayBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL2luY3JlbWVudGFsLXN0YXRpYy1yZWdlbmVyYXRpb24jb24tZGVtYW5kLXJldmFsaWRhdGlvbi13aXRoLXJldmFsaWRhdGVwYXRoXG4gICAqL1xuICByZXZhbGlkYXRlOiAoXG4gICAgdXJsUGF0aDogc3RyaW5nLFxuICAgIG9wdHM/OiB7XG4gICAgICB1bnN0YWJsZV9vbmx5R2VuZXJhdGVkPzogYm9vbGVhblxuICAgIH1cbiAgKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB1bmtub3duIHwgUHJvbWlzZTx1bmtub3duPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi9cbmV4cG9ydCBjb25zdCBpc0Fic29sdXRlVXJsID0gKHVybDogc3RyaW5nKSA9PiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsOiBzdHJpbmcpIHtcbiAgY29uc3QgdXJsUGFydHMgPSB1cmwuc3BsaXQoJz8nKVxuICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF1cblxuICByZXR1cm4gKFxuICAgIHVybE5vUXVlcnlcbiAgICAgIC8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuICAgICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgICAucmVwbGFjZSgvXFwvXFwvKy9nLCAnLycpICtcbiAgICAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJylcbiAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge30sXG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIChbJ21hcmsnLCAnbWVhc3VyZScsICdnZXRFbnRyaWVzQnlOYW1lJ10gYXMgY29uc3QpLmV2ZXJ5KFxuICAgIChtZXRob2QpID0+IHR5cGVvZiBwZXJmb3JtYW5jZVttZXRob2RdID09PSAnZnVuY3Rpb24nXG4gIClcblxuZXhwb3J0IGNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmV4cG9ydCBjbGFzcyBOb3JtYWxpemVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgUGFnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHBhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJ1xuICAgIHRoaXMubmFtZSA9ICdQYWdlTm90Rm91bmRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgbW9kdWxlIGZvciBwYWdlOiAke3BhZ2V9YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNaXNzaW5nU3RhdGljUGFnZSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFnZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZXNzYWdlID0gYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiAke3BhZ2V9ICR7bWVzc2FnZX1gXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmdcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY29kZSA9ICdFTk9FTlQnXG4gICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZWBcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlRnMge1xuICBleGlzdHNTeW5jOiB0eXBlb2YgZnMuZXhpc3RzU3luY1xuICByZWFkRmlsZTogdHlwZW9mIGZzLnByb21pc2VzLnJlYWRGaWxlXG4gIHJlYWRGaWxlU3luYzogdHlwZW9mIGZzLnJlYWRGaWxlU3luY1xuICB3cml0ZUZpbGUoZjogc3RyaW5nLCBkOiBhbnkpOiBQcm9taXNlPHZvaWQ+XG4gIG1rZGlyKGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkIHwgc3RyaW5nPlxuICBzdGF0KGY6IHN0cmluZyk6IFByb21pc2U8eyBtdGltZTogRGF0ZSB9PlxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9KVxufVxuIl0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/error-once.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"errorOnce\", ({\n    enumerable: true,\n    get: function() {\n        return errorOnce;\n    }\n}));\nlet errorOnce = (_)=>{};\nif (true) {\n    const errors = new Set();\n    errorOnce = (msg)=>{\n        if (!errors.has(msg)) {\n            console.error(msg);\n        }\n        errors.add(msg);\n    };\n} //# sourceMappingURL=error-once.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy9lcnJvci1vbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NkNBV1NBOzs7ZUFBQUE7OztBQVhULElBQUlBLFlBQVksQ0FBQ0MsS0FBZTtBQUNoQyxJQUFJQyxJQUFvQixFQUFtQjtJQUN6QyxNQUFNRyxTQUFTLElBQUlDO0lBQ25CTixZQUFZLENBQUNPO1FBQ1gsSUFBSSxDQUFDRixPQUFPRyxHQUFHLENBQUNELE1BQU07WUFDcEJFLFFBQVFDLEtBQUssQ0FBQ0g7UUFDaEI7UUFDQUYsT0FBT00sR0FBRyxDQUFDSjtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxzcmNcXHNoYXJlZFxcbGliXFx1dGlsc1xcZXJyb3Itb25jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZXJyb3JPbmNlID0gKF86IHN0cmluZykgPT4ge31cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNvbnN0IGVycm9ycyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGVycm9yT25jZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgIGlmICghZXJyb3JzLmhhcyhtc2cpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZylcbiAgICB9XG4gICAgZXJyb3JzLmFkZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IHsgZXJyb3JPbmNlIH1cbiJdLCJuYW1lcyI6WyJlcnJvck9uY2UiLCJfIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZXJyb3JzIiwiU2V0IiwibXNnIiwiaGFzIiwiY29uc29sZSIsImVycm9yIiwiYWRkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/error-once.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/context.js":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/context.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Slot: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.Slot),\n/* harmony export */   asyncFromGen: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.asyncFromGen),\n/* harmony export */   bindContext: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.bind),\n/* harmony export */   noContext: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.noContext),\n/* harmony export */   nonReactive: () => (/* binding */ nonReactive),\n/* harmony export */   parentEntrySlot: () => (/* binding */ parentEntrySlot),\n/* harmony export */   setTimeout: () => (/* reexport safe */ _wry_context__WEBPACK_IMPORTED_MODULE_0__.setTimeout)\n/* harmony export */ });\n/* harmony import */ var _wry_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/context */ \"(app-pages-browser)/./node_modules/@wry/context/lib/index.js\");\n\nconst parentEntrySlot = new _wry_context__WEBPACK_IMPORTED_MODULE_0__.Slot();\nfunction nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\n\n\n//# sourceMappingURL=context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvY29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUM3Qiw0QkFBNEIsOENBQUk7QUFDaEM7QUFDUDtBQUNBO0FBQ2dCO0FBQ3lFO0FBQ3pGIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXG9wdGltaXNtXFxsaWJcXGNvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2xvdCB9IGZyb20gXCJAd3J5L2NvbnRleHRcIjtcbmV4cG9ydCBjb25zdCBwYXJlbnRFbnRyeVNsb3QgPSBuZXcgU2xvdCgpO1xuZXhwb3J0IGZ1bmN0aW9uIG5vblJlYWN0aXZlKGZuKSB7XG4gICAgcmV0dXJuIHBhcmVudEVudHJ5U2xvdC53aXRoVmFsdWUodm9pZCAwLCBmbik7XG59XG5leHBvcnQgeyBTbG90IH07XG5leHBvcnQgeyBiaW5kIGFzIGJpbmRDb250ZXh0LCBub0NvbnRleHQsIHNldFRpbWVvdXQsIGFzeW5jRnJvbUdlbiwgfSBmcm9tIFwiQHdyeS9jb250ZXh0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/dep.js":
/*!******************************************!*\
  !*** ./node_modules/optimism/lib/dep.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dep: () => (/* binding */ dep)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/optimism/lib/helpers.js\");\n\n\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nfunction dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = (entryMethodName &&\n                _helpers_js__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(dep).forEach(entry => entry[m]());\n            depsByKey.delete(key);\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(dep);\n        }\n    };\n    return depend;\n}\n//# sourceMappingURL=dep.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvZGVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNnQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBWTtBQUN4QjtBQUNBLFlBQVksNkRBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcb3B0aW1pc21cXGxpYlxcZGVwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcmVudEVudHJ5U2xvdCB9IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmltcG9ydCB7IGhhc093blByb3BlcnR5LCBtYXliZVVuc3Vic2NyaWJlLCBhcnJheUZyb21TZXQsIH0gZnJvbSBcIi4vaGVscGVycy5qc1wiO1xuY29uc3QgRW50cnlNZXRob2RzID0ge1xuICAgIHNldERpcnR5OiB0cnVlLFxuICAgIGRpc3Bvc2U6IHRydWUsXG4gICAgZm9yZ2V0OiB0cnVlLCAvLyBGdWxseSByZW1vdmUgcGFyZW50IEVudHJ5IGZyb20gTFJVIGNhY2hlIGFuZCBjb21wdXRhdGlvbiBncmFwaFxufTtcbmV4cG9ydCBmdW5jdGlvbiBkZXAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlcHNCeUtleSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSBvcHRpb25zICYmIG9wdGlvbnMuc3Vic2NyaWJlO1xuICAgIGZ1bmN0aW9uIGRlcGVuZChrZXkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gcGFyZW50RW50cnlTbG90LmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGxldCBkZXAgPSBkZXBzQnlLZXkuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoIWRlcCkge1xuICAgICAgICAgICAgICAgIGRlcHNCeUtleS5zZXQoa2V5LCBkZXAgPSBuZXcgU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5kZXBlbmRPbihkZXApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG1heWJlVW5zdWJzY3JpYmUoZGVwKTtcbiAgICAgICAgICAgICAgICBkZXAudW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXBlbmQuZGlydHkgPSBmdW5jdGlvbiBkaXJ0eShrZXksIGVudHJ5TWV0aG9kTmFtZSkge1xuICAgICAgICBjb25zdCBkZXAgPSBkZXBzQnlLZXkuZ2V0KGtleSk7XG4gICAgICAgIGlmIChkZXApIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAoZW50cnlNZXRob2ROYW1lICYmXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChFbnRyeU1ldGhvZHMsIGVudHJ5TWV0aG9kTmFtZSkpID8gZW50cnlNZXRob2ROYW1lIDogXCJzZXREaXJ0eVwiO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byB1c2UgYXJyYXlGcm9tU2V0KGRlcCkuZm9yRWFjaCBpbnN0ZWFkIG9mIGRlcC5mb3JFYWNoLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBtb2RpZnlpbmcgYSBTZXQgd2hpbGUgaXRlcmF0aW5nIG92ZXIgaXQgY2FuIGNhdXNlIGVsZW1lbnRzIGluXG4gICAgICAgICAgICAvLyB0aGUgU2V0IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgU2V0IGJlZm9yZSB0aGV5J3ZlIGJlZW4gaXRlcmF0ZWQgb3Zlci5cbiAgICAgICAgICAgIGFycmF5RnJvbVNldChkZXApLmZvckVhY2goZW50cnkgPT4gZW50cnlbbV0oKSk7XG4gICAgICAgICAgICBkZXBzQnlLZXkuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBtYXliZVVuc3Vic2NyaWJlKGRlcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBkZXBlbmQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/dep.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/entry.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/entry.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Entry: () => (/* binding */ Entry)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/optimism/lib/helpers.js\");\n\n\nconst emptySetPool = [];\nconst POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    const len = a.length;\n    return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n        // Both values must be ordinary (or both exceptional) to be equal.\n        len === b.length &&\n        // The underlying value or exception must be the same.\n        a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch (value.length) {\n        case 0: throw new Error(\"unknown value\");\n        case 1: return value[0];\n        case 2: throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nclass Entry {\n    constructor(fn) {\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n    peek() {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    }\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    recompute(args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this)\n            ? reallyRecompute(this, args)\n            : valueGet(this.value);\n    }\n    setDirty() {\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(this);\n    }\n    dispose() {\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, (parent, child) => {\n            parent.setDirty();\n            forgetChild(parent, this);\n        });\n    }\n    forget() {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    }\n    dependOn(dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    }\n    forgetDeps() {\n        if (this.deps) {\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(this.deps).forEach(dep => dep.delete(this));\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    }\n}\nEntry.count = 0;\nfunction rememberParent(child) {\n    const parent = _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        }\n        else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    _context_js__WEBPACK_IMPORTED_MODULE_0__.parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    const { normalizeResult } = entry;\n    let oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            }\n            catch (_a) {\n                // If normalizeResult throws, just use the newer value, rather than\n                // saving the exception as entry.value[1].\n            }\n        }\n    }\n    catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    const parentCount = child.parents.size;\n    if (parentCount) {\n        const parents = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.arrayFromSet)(child.parents);\n        for (let i = 0; i < parentCount; ++i) {\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    const parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    }\n    else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    const childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    }\n    else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    const dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach((_value, child) => {\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.maybeUnsubscribe)(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        }\n        catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n}\n//# sourceMappingURL=entry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvZW50cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBQ2U7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3REFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQVk7QUFDcEMsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQWdCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcb3B0aW1pc21cXGxpYlxcZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyZW50RW50cnlTbG90IH0gZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHsgbWF5YmVVbnN1YnNjcmliZSwgYXJyYXlGcm9tU2V0IH0gZnJvbSBcIi4vaGVscGVycy5qc1wiO1xuY29uc3QgZW1wdHlTZXRQb29sID0gW107XG5jb25zdCBQT09MX1RBUkdFVF9TSVpFID0gMTAwO1xuLy8gU2luY2UgdGhpcyBwYWNrYWdlIG1pZ2h0IGJlIHVzZWQgYnJvd3NlcnMsIHdlIHNob3VsZCBhdm9pZCB1c2luZyB0aGVcbi8vIE5vZGUgYnVpbHQtaW4gYXNzZXJ0IG1vZHVsZS5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG9wdGlvbmFsTWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25hbE1lc3NhZ2UgfHwgXCJhc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWx1ZUlzKGEsIGIpIHtcbiAgICBjb25zdCBsZW4gPSBhLmxlbmd0aDtcbiAgICByZXR1cm4gKFxuICAgIC8vIFVua25vd24gdmFsdWVzIGFyZSBub3QgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAgICBsZW4gPiAwICYmXG4gICAgICAgIC8vIEJvdGggdmFsdWVzIG11c3QgYmUgb3JkaW5hcnkgKG9yIGJvdGggZXhjZXB0aW9uYWwpIHRvIGJlIGVxdWFsLlxuICAgICAgICBsZW4gPT09IGIubGVuZ3RoICYmXG4gICAgICAgIC8vIFRoZSB1bmRlcmx5aW5nIHZhbHVlIG9yIGV4Y2VwdGlvbiBtdXN0IGJlIHRoZSBzYW1lLlxuICAgICAgICBhW2xlbiAtIDFdID09PSBiW2xlbiAtIDFdKTtcbn1cbmZ1bmN0aW9uIHZhbHVlR2V0KHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHZhbHVlXCIpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgY2FzZSAyOiB0aHJvdyB2YWx1ZVsxXTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWx1ZUNvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCk7XG59XG5leHBvcnQgY2xhc3MgRW50cnkge1xuICAgIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5wYXJlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNoaWxkVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGVuIHRoaXMgRW50cnkgaGFzIGNoaWxkcmVuIHRoYXQgYXJlIGRpcnR5LCB0aGlzIHByb3BlcnR5IGJlY29tZXNcbiAgICAgICAgLy8gYSBTZXQgY29udGFpbmluZyBvdGhlciBFbnRyeSBvYmplY3RzLCBib3Jyb3dlZCBmcm9tIGVtcHR5U2V0UG9vbC5cbiAgICAgICAgLy8gV2hlbiB0aGUgc2V0IGJlY29tZXMgZW1wdHksIGl0IGdldHMgcmVjeWNsZWQgYmFjayB0byBlbXB0eVNldFBvb2wuXG4gICAgICAgIHRoaXMuZGlydHlDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlY29tcHV0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBzID0gbnVsbDtcbiAgICAgICAgKytFbnRyeS5jb3VudDtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID09PSAxICYmICFtaWdodEJlRGlydHkodGhpcykpIHtcbiAgICAgICAgICAgIHJlbWVtYmVyUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgbWV0aG9kIG9mIHRoZSBFbnRyeSBBUEksIGJlY2F1c2UgaXRcbiAgICAvLyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNhY2hlZCB0aGlzLnZhbHVlIGNhbiBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSxcbiAgICAvLyBvciBtdXN0IGJlIHJlY29tcHV0ZWQuIFRoZSBvdmVyYWxsIHBlcmZvcm1hbmNlIG9mIHRoZSBjYWNoaW5nIHN5c3RlbVxuICAgIC8vIGRlcGVuZHMgb24gdGhlIHRydXRoIG9mIHRoZSBmb2xsb3dpbmcgb2JzZXJ2YXRpb25zOiAoMSkgdGhpcy5kaXJ0eSBpc1xuICAgIC8vIHVzdWFsbHkgZmFsc2UsICgyKSB0aGlzLmRpcnR5Q2hpbGRyZW4gaXMgdXN1YWxseSBudWxsL2VtcHR5LCBhbmQgdGh1c1xuICAgIC8vICgzKSB2YWx1ZUdldCh0aGlzLnZhbHVlKSBpcyB1c3VhbGx5IHJldHVybmVkIHdpdGhvdXQgcmVjb21wdXRhdGlvbi5cbiAgICByZWNvbXB1dGUoYXJncykge1xuICAgICAgICBhc3NlcnQoIXRoaXMucmVjb21wdXRpbmcsIFwiYWxyZWFkeSByZWNvbXB1dGluZ1wiKTtcbiAgICAgICAgcmVtZW1iZXJQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBtaWdodEJlRGlydHkodGhpcylcbiAgICAgICAgICAgID8gcmVhbGx5UmVjb21wdXRlKHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICA6IHZhbHVlR2V0KHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBzZXREaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICByZXBvcnREaXJ0eSh0aGlzKTtcbiAgICAgICAgLy8gV2UgY2FuIGdvIGFoZWFkIGFuZCB1bnN1YnNjcmliZSBoZXJlLCBzaW5jZSBhbnkgZnVydGhlciBkaXJ0eVxuICAgICAgICAvLyBub3RpZmljYXRpb25zIHdlIHJlY2VpdmUgd2lsbCBiZSByZWR1bmRhbnQsIGFuZCB1bnN1YnNjcmliaW5nIG1heVxuICAgICAgICAvLyBmcmVlIHVwIHNvbWUgcmVzb3VyY2VzLCBlLmcuIGZpbGUgd2F0Y2hlcnMuXG4gICAgICAgIG1heWJlVW5zdWJzY3JpYmUodGhpcyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoKTtcbiAgICAgICAgLy8gU2V2ZXIgYW55IGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwcyB3aXRoIG91ciBvd24gY2hpbGRyZW4sIHNvIHRob3NlXG4gICAgICAgIC8vIGNoaWxkcmVuIGRvbid0IHJldGFpbiB0aGlzIHBhcmVudCBFbnRyeSBpbiB0aGVpciBjaGlsZC5wYXJlbnRzIHNldHMsXG4gICAgICAgIC8vIHRoZXJlYnkgcHJldmVudGluZyBpdCBmcm9tIGJlaW5nIGZ1bGx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICBmb3JnZXRDaGlsZHJlbih0aGlzKTtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGlzIGVudHJ5IGhhcyBiZWVuIGtpY2tlZCBvdXQgb2YgdGhlIGNhY2hlIChpbiBpbmRleC5qcyksXG4gICAgICAgIC8vIHdlJ3ZlIGxvc3QgdGhlIGFiaWxpdHkgdG8gZmluZCBvdXQgaWYvd2hlbiB0aGlzIGVudHJ5IGJlY29tZXMgZGlydHksXG4gICAgICAgIC8vIHdoZXRoZXIgdGhhdCBoYXBwZW5zIHRocm91Z2ggYSBzdWJzY3JpcHRpb24sIGJlY2F1c2Ugb2YgYSBkaXJlY3QgY2FsbFxuICAgICAgICAvLyB0byBlbnRyeS5zZXREaXJ0eSgpLCBvciBiZWNhdXNlIG9uZSBvZiBpdHMgY2hpbGRyZW4gYmVjb21lcyBkaXJ0eS5cbiAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzIGxvc3Mgb2YgZnV0dXJlIGluZm9ybWF0aW9uLCB3ZSBoYXZlIHRvIGFzc3VtZSB0aGVcbiAgICAgICAgLy8gd29yc3QgKHRoYXQgdGhpcyBlbnRyeSBtaWdodCBoYXZlIGJlY29tZSBkaXJ0eSB2ZXJ5IHNvb24pLCBzbyB3ZSBtdXN0XG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IG1hcmsgdGhpcyBlbnRyeSdzIHBhcmVudHMgYXMgZGlydHkuIE5vcm1hbGx5IHdlIGNvdWxkXG4gICAgICAgIC8vIGp1c3QgY2FsbCBlbnRyeS5zZXREaXJ0eSgpIHJhdGhlciB0aGFuIGNhbGxpbmcgcGFyZW50LnNldERpcnR5KCkgZm9yXG4gICAgICAgIC8vIGVhY2ggcGFyZW50LCBidXQgdGhhdCB3b3VsZCBsZWF2ZSB0aGlzIGVudHJ5IGluIHBhcmVudC5jaGlsZFZhbHVlc1xuICAgICAgICAvLyBhbmQgcGFyZW50LmRpcnR5Q2hpbGRyZW4sIHdoaWNoIHdvdWxkIHByZXZlbnQgdGhlIGNoaWxkIGZyb20gYmVpbmdcbiAgICAgICAgLy8gdHJ1bHkgZm9yZ290dGVuLlxuICAgICAgICBlYWNoUGFyZW50KHRoaXMsIChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBwYXJlbnQuc2V0RGlydHkoKTtcbiAgICAgICAgICAgIGZvcmdldENoaWxkKHBhcmVudCwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3JnZXQoKSB7XG4gICAgICAgIC8vIFRoZSBjb2RlIHRoYXQgY3JlYXRlcyBFbnRyeSBvYmplY3RzIGluIGluZGV4LnRzIHdpbGwgcmVwbGFjZSB0aGlzIG1ldGhvZFxuICAgICAgICAvLyB3aXRoIG9uZSB0aGF0IGFjdHVhbGx5IHJlbW92ZXMgdGhlIEVudHJ5IGZyb20gdGhlIGNhY2hlLCB3aGljaCB3aWxsIGFsc29cbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZW50cnkuZGlzcG9zZSBtZXRob2QuXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBkZXBlbmRPbihkZXApIHtcbiAgICAgICAgZGVwLmFkZCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVwcyA9IGVtcHR5U2V0UG9vbC5wb3AoKSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXBzLmFkZChkZXApO1xuICAgIH1cbiAgICBmb3JnZXREZXBzKCkge1xuICAgICAgICBpZiAodGhpcy5kZXBzKSB7XG4gICAgICAgICAgICBhcnJheUZyb21TZXQodGhpcy5kZXBzKS5mb3JFYWNoKGRlcCA9PiBkZXAuZGVsZXRlKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZGVwcy5jbGVhcigpO1xuICAgICAgICAgICAgZW1wdHlTZXRQb29sLnB1c2godGhpcy5kZXBzKTtcbiAgICAgICAgICAgIHRoaXMuZGVwcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5FbnRyeS5jb3VudCA9IDA7XG5mdW5jdGlvbiByZW1lbWJlclBhcmVudChjaGlsZCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudEVudHJ5U2xvdC5nZXRWYWx1ZSgpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50cy5hZGQocGFyZW50KTtcbiAgICAgICAgaWYgKCFwYXJlbnQuY2hpbGRWYWx1ZXMuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkVmFsdWVzLnNldChjaGlsZCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWdodEJlRGlydHkoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXBvcnREaXJ0eUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWxseVJlY29tcHV0ZShlbnRyeSwgYXJncykge1xuICAgIGZvcmdldENoaWxkcmVuKGVudHJ5KTtcbiAgICAvLyBTZXQgZW50cnkgYXMgdGhlIHBhcmVudCBlbnRyeSB3aGlsZSBjYWxsaW5nIHJlY29tcHV0ZU5ld1ZhbHVlKGVudHJ5KS5cbiAgICBwYXJlbnRFbnRyeVNsb3Qud2l0aFZhbHVlKGVudHJ5LCByZWNvbXB1dGVOZXdWYWx1ZSwgW2VudHJ5LCBhcmdzXSk7XG4gICAgaWYgKG1heWJlU3Vic2NyaWJlKGVudHJ5LCBhcmdzKSkge1xuICAgICAgICAvLyBJZiB3ZSBzdWNjZXNzZnVsbHkgcmVjb21wdXRlZCBlbnRyeS52YWx1ZSBhbmQgZGlkIG5vdCBmYWlsIHRvXG4gICAgICAgIC8vIChyZSlzdWJzY3JpYmUsIHRoZW4gdGhpcyBFbnRyeSBpcyBubyBsb25nZXIgZXhwbGljaXRseSBkaXJ0eS5cbiAgICAgICAgc2V0Q2xlYW4oZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVHZXQoZW50cnkudmFsdWUpO1xufVxuZnVuY3Rpb24gcmVjb21wdXRlTmV3VmFsdWUoZW50cnksIGFyZ3MpIHtcbiAgICBlbnRyeS5yZWNvbXB1dGluZyA9IHRydWU7XG4gICAgY29uc3QgeyBub3JtYWxpemVSZXN1bHQgfSA9IGVudHJ5O1xuICAgIGxldCBvbGRWYWx1ZUNvcHk7XG4gICAgaWYgKG5vcm1hbGl6ZVJlc3VsdCAmJiBlbnRyeS52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgb2xkVmFsdWVDb3B5ID0gdmFsdWVDb3B5KGVudHJ5LnZhbHVlKTtcbiAgICB9XG4gICAgLy8gTWFrZSBlbnRyeS52YWx1ZSBhbiBlbXB0eSBhcnJheSwgcmVwcmVzZW50aW5nIGFuIHVua25vd24gdmFsdWUuXG4gICAgZW50cnkudmFsdWUubGVuZ3RoID0gMDtcbiAgICB0cnkge1xuICAgICAgICAvLyBJZiBlbnRyeS5mbiBzdWNjZWVkcywgZW50cnkudmFsdWUgd2lsbCBiZWNvbWUgYSBub3JtYWwgVmFsdWUuXG4gICAgICAgIGVudHJ5LnZhbHVlWzBdID0gZW50cnkuZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2aWFibGUgb2xkVmFsdWVDb3B5IHRvIGNvbXBhcmUgd2l0aCB0aGUgKHN1Y2Nlc3NmdWxseVxuICAgICAgICAvLyByZWNvbXB1dGVkKSBuZXcgZW50cnkudmFsdWUsIGFuZCB0aGV5IGFyZSBub3QgYWxyZWFkeSA9PT0gaWRlbnRpY2FsLCBnaXZlXG4gICAgICAgIC8vIG5vcm1hbGl6ZVJlc3VsdCBhIGNoYW5jZSB0byBwaWNrL2Nob29zZS9yZXVzZSBwYXJ0cyBvZiBvbGRWYWx1ZUNvcHlbMF1cbiAgICAgICAgLy8gYW5kL29yIGVudHJ5LnZhbHVlWzBdIHRvIGRldGVybWluZSB0aGUgZmluYWwgY2FjaGVkIGVudHJ5LnZhbHVlLlxuICAgICAgICBpZiAobm9ybWFsaXplUmVzdWx0ICYmIG9sZFZhbHVlQ29weSAmJiAhdmFsdWVJcyhvbGRWYWx1ZUNvcHksIGVudHJ5LnZhbHVlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbnRyeS52YWx1ZVswXSA9IG5vcm1hbGl6ZVJlc3VsdChlbnRyeS52YWx1ZVswXSwgb2xkVmFsdWVDb3B5WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vcm1hbGl6ZVJlc3VsdCB0aHJvd3MsIGp1c3QgdXNlIHRoZSBuZXdlciB2YWx1ZSwgcmF0aGVyIHRoYW5cbiAgICAgICAgICAgICAgICAvLyBzYXZpbmcgdGhlIGV4Y2VwdGlvbiBhcyBlbnRyeS52YWx1ZVsxXS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBlbnRyeS5mbiB0aHJvd3MsIGVudHJ5LnZhbHVlIHdpbGwgaG9sZCB0aGF0IGV4Y2VwdGlvbi5cbiAgICAgICAgZW50cnkudmFsdWVbMV0gPSBlO1xuICAgIH1cbiAgICAvLyBFaXRoZXIgd2F5LCB0aGlzIGxpbmUgaXMgYWx3YXlzIHJlYWNoZWQuXG4gICAgZW50cnkucmVjb21wdXRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1pZ2h0QmVEaXJ0eShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5kaXJ0eSB8fCAhIShlbnRyeS5kaXJ0eUNoaWxkcmVuICYmIGVudHJ5LmRpcnR5Q2hpbGRyZW4uc2l6ZSk7XG59XG5mdW5jdGlvbiBzZXRDbGVhbihlbnRyeSkge1xuICAgIGVudHJ5LmRpcnR5ID0gZmFsc2U7XG4gICAgaWYgKG1pZ2h0QmVEaXJ0eShlbnRyeSkpIHtcbiAgICAgICAgLy8gVGhpcyBFbnRyeSBtYXkgc3RpbGwgaGF2ZSBkaXJ0eSBjaGlsZHJlbiwgaW4gd2hpY2ggY2FzZSB3ZSBjYW4ndFxuICAgICAgICAvLyBsZXQgb3VyIHBhcmVudHMga25vdyB3ZSdyZSBjbGVhbiBqdXN0IHlldC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXBvcnRDbGVhbihlbnRyeSk7XG59XG5mdW5jdGlvbiByZXBvcnREaXJ0eShjaGlsZCkge1xuICAgIGVhY2hQYXJlbnQoY2hpbGQsIHJlcG9ydERpcnR5Q2hpbGQpO1xufVxuZnVuY3Rpb24gcmVwb3J0Q2xlYW4oY2hpbGQpIHtcbiAgICBlYWNoUGFyZW50KGNoaWxkLCByZXBvcnRDbGVhbkNoaWxkKTtcbn1cbmZ1bmN0aW9uIGVhY2hQYXJlbnQoY2hpbGQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcGFyZW50Q291bnQgPSBjaGlsZC5wYXJlbnRzLnNpemU7XG4gICAgaWYgKHBhcmVudENvdW50KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBhcnJheUZyb21TZXQoY2hpbGQucGFyZW50cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgY2FsbGJhY2socGFyZW50c1tpXSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gTGV0IGEgcGFyZW50IEVudHJ5IGtub3cgdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuIG1heSBiZSBkaXJ0eS5cbmZ1bmN0aW9uIHJlcG9ydERpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCkge1xuICAgIC8vIE11c3QgaGF2ZSBjYWxsZWQgcmVtZW1iZXJQYXJlbnQoY2hpbGQpIGJlZm9yZSBjYWxsaW5nXG4gICAgLy8gcmVwb3J0RGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKS5cbiAgICBhc3NlcnQocGFyZW50LmNoaWxkVmFsdWVzLmhhcyhjaGlsZCkpO1xuICAgIGFzc2VydChtaWdodEJlRGlydHkoY2hpbGQpKTtcbiAgICBjb25zdCBwYXJlbnRXYXNDbGVhbiA9ICFtaWdodEJlRGlydHkocGFyZW50KTtcbiAgICBpZiAoIXBhcmVudC5kaXJ0eUNoaWxkcmVuKSB7XG4gICAgICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuID0gZW1wdHlTZXRQb29sLnBvcCgpIHx8IG5ldyBTZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudC5kaXJ0eUNoaWxkcmVuLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBrbm93IHRoaXMgY2hpbGQgaXMgZGlydHksIHRoZW4gd2UgbXVzdCBoYXZlIGFscmVhZHlcbiAgICAgICAgLy8gaW5mb3JtZWQgb3VyIG93biBwYXJlbnRzIHRoYXQgd2UgYXJlIGRpcnR5LCBzbyB3ZSBjYW4gdGVybWluYXRlXG4gICAgICAgIC8vIHRoZSByZWN1cnNpb24gZWFybHkuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyZW50LmRpcnR5Q2hpbGRyZW4uYWRkKGNoaWxkKTtcbiAgICAvLyBJZiBwYXJlbnQgd2FzIGNsZWFuIGJlZm9yZSwgaXQganVzdCBiZWNhbWUgKHBvc3NpYmx5KSBkaXJ0eSAoYWNjb3JkaW5nIHRvXG4gICAgLy8gbWlnaHRCZURpcnR5KSwgc2luY2Ugd2UganVzdCBhZGRlZCBjaGlsZCB0byBwYXJlbnQuZGlydHlDaGlsZHJlbi5cbiAgICBpZiAocGFyZW50V2FzQ2xlYW4pIHtcbiAgICAgICAgcmVwb3J0RGlydHkocGFyZW50KTtcbiAgICB9XG59XG4vLyBMZXQgYSBwYXJlbnQgRW50cnkga25vdyB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4gaXMgbm8gbG9uZ2VyIGRpcnR5LlxuZnVuY3Rpb24gcmVwb3J0Q2xlYW5DaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgLy8gTXVzdCBoYXZlIGNhbGxlZCByZW1lbWJlckNoaWxkKGNoaWxkKSBiZWZvcmUgY2FsbGluZ1xuICAgIC8vIHJlcG9ydENsZWFuQ2hpbGQocGFyZW50LCBjaGlsZCkuXG4gICAgYXNzZXJ0KHBhcmVudC5jaGlsZFZhbHVlcy5oYXMoY2hpbGQpKTtcbiAgICBhc3NlcnQoIW1pZ2h0QmVEaXJ0eShjaGlsZCkpO1xuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBwYXJlbnQuY2hpbGRWYWx1ZXMuZ2V0KGNoaWxkKTtcbiAgICBpZiAoY2hpbGRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyZW50LmNoaWxkVmFsdWVzLnNldChjaGlsZCwgdmFsdWVDb3B5KGNoaWxkLnZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF2YWx1ZUlzKGNoaWxkVmFsdWUsIGNoaWxkLnZhbHVlKSkge1xuICAgICAgICBwYXJlbnQuc2V0RGlydHkoKTtcbiAgICB9XG4gICAgcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICBpZiAobWlnaHRCZURpcnR5KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXBvcnRDbGVhbihwYXJlbnQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRGlydHlDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgY29uc3QgZGMgPSBwYXJlbnQuZGlydHlDaGlsZHJlbjtcbiAgICBpZiAoZGMpIHtcbiAgICAgICAgZGMuZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgaWYgKGRjLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChlbXB0eVNldFBvb2wubGVuZ3RoIDwgUE9PTF9UQVJHRVRfU0laRSkge1xuICAgICAgICAgICAgICAgIGVtcHR5U2V0UG9vbC5wdXNoKGRjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5kaXJ0eUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBlbnRyeSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVcbi8vIHJlbW92ZWQgY2hpbGRyZW4uXG5mdW5jdGlvbiBmb3JnZXRDaGlsZHJlbihwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmNoaWxkVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHBhcmVudC5jaGlsZFZhbHVlcy5mb3JFYWNoKChfdmFsdWUsIGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBmb3JnZXRDaGlsZChwYXJlbnQsIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGlzIHBhcmVudCBFbnRyeSBmcm9tIGFueSBzZXRzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBieSB0aGVcbiAgICAvLyBhZGRUb1NldCBtZXRob2QuXG4gICAgcGFyZW50LmZvcmdldERlcHMoKTtcbiAgICAvLyBBZnRlciB3ZSBmb3JnZXQgYWxsIG91ciBjaGlsZHJlbiwgdGhpcy5kaXJ0eUNoaWxkcmVuIG11c3QgYmUgZW1wdHlcbiAgICAvLyBhbmQgdGhlcmVmb3JlIG11c3QgaGF2ZSBiZWVuIHJlc2V0IHRvIG51bGwuXG4gICAgYXNzZXJ0KHBhcmVudC5kaXJ0eUNoaWxkcmVuID09PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGZvcmdldENoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICBjaGlsZC5wYXJlbnRzLmRlbGV0ZShwYXJlbnQpO1xuICAgIHBhcmVudC5jaGlsZFZhbHVlcy5kZWxldGUoY2hpbGQpO1xuICAgIHJlbW92ZURpcnR5Q2hpbGQocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBtYXliZVN1YnNjcmliZShlbnRyeSwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZW50cnkuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1heWJlVW5zdWJzY3JpYmUoZW50cnkpOyAvLyBQcmV2ZW50IGRvdWJsZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUgPSBlbnRyeS5zdWJzY3JpYmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgRW50cnkgaGFzIGEgc3Vic2NyaWJlIGZ1bmN0aW9uIGFuZCBpdCB0aHJldyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIChvciBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiBpdCBwcmV2aW91c2x5IHJldHVybmVkIG5vdyB0aHJvd3MpLFxuICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2Ugd2VyZSBub3QgYWJsZSB0byBzdWJzY3JpYmUgKG9yXG4gICAgICAgICAgICAvLyB1bnN1YnNjcmliZSksIGFuZCB0aGlzIEVudHJ5IHNob3VsZCByZW1haW4gZGlydHkuXG4gICAgICAgICAgICBlbnRyeS5zZXREaXJ0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybmluZyB0cnVlIGluZGljYXRlcyBlaXRoZXIgdGhhdCB0aGVyZSB3YXMgbm8gZW50cnkuc3Vic2NyaWJlXG4gICAgLy8gZnVuY3Rpb24gb3IgdGhhdCBpdCBzdWNjZWVkZWQuXG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/entry.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/optimism/lib/helpers.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayFromSet: () => (/* binding */ arrayFromSet),\n/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),\n/* harmony export */   maybeUnsubscribe: () => (/* binding */ maybeUnsubscribe)\n/* harmony export */ });\nconst { hasOwnProperty, } = Object.prototype;\nconst arrayFromSet = Array.from ||\n    function (set) {\n        const array = [];\n        set.forEach(item => array.push(item));\n        return array;\n    };\nfunction maybeUnsubscribe(entryOrDep) {\n    const { unsubscribe } = entryOrDep;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTyxRQUFRLGtCQUFrQjtBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcb3B0aW1pc21cXGxpYlxcaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5leHBvcnQgY29uc3QgYXJyYXlGcm9tU2V0ID0gQXJyYXkuZnJvbSB8fFxuICAgIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgc2V0LmZvckVhY2goaXRlbSA9PiBhcnJheS5wdXNoKGl0ZW0pKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5leHBvcnQgZnVuY3Rpb24gbWF5YmVVbnN1YnNjcmliZShlbnRyeU9yRGVwKSB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gZW50cnlPckRlcDtcbiAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW50cnlPckRlcC51bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/optimism/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/optimism/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyTrie: () => (/* reexport safe */ _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie),\n/* harmony export */   Slot: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.Slot),\n/* harmony export */   asyncFromGen: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.asyncFromGen),\n/* harmony export */   bindContext: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.bindContext),\n/* harmony export */   defaultMakeCacheKey: () => (/* binding */ defaultMakeCacheKey),\n/* harmony export */   dep: () => (/* reexport safe */ _dep_js__WEBPACK_IMPORTED_MODULE_3__.dep),\n/* harmony export */   noContext: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.noContext),\n/* harmony export */   nonReactive: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.nonReactive),\n/* harmony export */   setTimeout: () => (/* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_2__.setTimeout),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _wry_trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wry/trie */ \"(app-pages-browser)/./node_modules/@wry/trie/lib/index.js\");\n/* harmony import */ var _wry_caches__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wry/caches */ \"(app-pages-browser)/./node_modules/@wry/caches/lib/strong.js\");\n/* harmony import */ var _entry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entry.js */ \"(app-pages-browser)/./node_modules/optimism/lib/entry.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/optimism/lib/context.js\");\n/* harmony import */ var _dep_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dep.js */ \"(app-pages-browser)/./node_modules/optimism/lib/dep.js\");\n\n\n\n\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\n\n// A lighter-weight dependency, similar to OptimisticWrapperFunction, except\n// with only one argument, no makeCacheKey, no wrapped function to recompute,\n// and no result value. Useful for representing dependency leaves in the graph\n// of computation. Subscriptions are supported.\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nlet defaultKeyTrie;\nfunction defaultMakeCacheKey(...args) {\n    const trie = defaultKeyTrie || (defaultKeyTrie = new _wry_trie__WEBPACK_IMPORTED_MODULE_0__.Trie(typeof WeakMap === \"function\"));\n    return trie.lookupArray(args);\n}\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\n\n;\nconst caches = new Set();\nfunction wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = _wry_caches__WEBPACK_IMPORTED_MODULE_4__.StrongCache, } = Object.create(null)) {\n    const cache = typeof cacheOption === \"function\"\n        ? new cacheOption(max, entry => entry.dispose())\n        : cacheOption;\n    const optimistic = function () {\n        const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        let entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new _entry_js__WEBPACK_IMPORTED_MODULE_1__.Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = () => cache.delete(key);\n        }\n        const value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!_context_js__WEBPACK_IMPORTED_MODULE_2__.parentEntrySlot.hasValue()) {\n            caches.forEach(cache => cache.clean());\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: () => cache.size,\n        configurable: false,\n        enumerable: false,\n    });\n    Object.freeze(optimistic.options = {\n        max,\n        keyArgs,\n        makeCacheKey,\n        normalizeResult,\n        subscribe,\n        cache,\n    });\n    function dirtyKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcHRpbWlzbS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQ1M7QUFDUDtBQUNZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUMrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5REFBeUQsMkNBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQjtBQUMzQjtBQUNBO0FBQ08sa0NBQWtDLHFIQUFxSCxvREFBVyxJQUFJO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXG9wdGltaXNtXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyaWUgfSBmcm9tIFwiQHdyeS90cmllXCI7XG5pbXBvcnQgeyBTdHJvbmdDYWNoZSB9IGZyb20gXCJAd3J5L2NhY2hlc1wiO1xuaW1wb3J0IHsgRW50cnkgfSBmcm9tIFwiLi9lbnRyeS5qc1wiO1xuaW1wb3J0IHsgcGFyZW50RW50cnlTbG90IH0gZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuLy8gVGhlc2UgaGVscGVyIGZ1bmN0aW9ucyBhcmUgaW1wb3J0YW50IGZvciBtYWtpbmcgb3B0aW1pc20gd29yayB3aXRoXG4vLyBhc3luY2hyb25vdXMgY29kZS4gSW4gb3JkZXIgdG8gcmVnaXN0ZXIgcGFyZW50LWNoaWxkIGRlcGVuZGVuY2llcyxcbi8vIG9wdGltaXNtIG5lZWRzIHRvIGtub3cgYWJvdXQgYW55IGN1cnJlbnRseSBhY3RpdmUgcGFyZW50IGNvbXB1dGF0aW9ucy5cbi8vIEluIG9yZGluYXJ5IHN5bmNocm9ub3VzIGNvZGUsIHRoZSBwYXJlbnQgY29udGV4dCBpcyBpbXBsaWNpdCBpbiB0aGVcbi8vIGV4ZWN1dGlvbiBzdGFjaywgYnV0IGFzeW5jaHJvbm91cyBjb2RlIHJlcXVpcmVzIHNvbWUgZXh0cmEgZ3VpZGFuY2UgaW5cbi8vIG9yZGVyIHRvIHByb3BhZ2F0ZSBjb250ZXh0IGZyb20gb25lIGFzeW5jIHRhc2sgc2VnbWVudCB0byB0aGUgbmV4dC5cbmV4cG9ydCB7IGJpbmRDb250ZXh0LCBub0NvbnRleHQsIG5vblJlYWN0aXZlLCBzZXRUaW1lb3V0LCBhc3luY0Zyb21HZW4sIFNsb3QsIH0gZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuLy8gQSBsaWdodGVyLXdlaWdodCBkZXBlbmRlbmN5LCBzaW1pbGFyIHRvIE9wdGltaXN0aWNXcmFwcGVyRnVuY3Rpb24sIGV4Y2VwdFxuLy8gd2l0aCBvbmx5IG9uZSBhcmd1bWVudCwgbm8gbWFrZUNhY2hlS2V5LCBubyB3cmFwcGVkIGZ1bmN0aW9uIHRvIHJlY29tcHV0ZSxcbi8vIGFuZCBubyByZXN1bHQgdmFsdWUuIFVzZWZ1bCBmb3IgcmVwcmVzZW50aW5nIGRlcGVuZGVuY3kgbGVhdmVzIGluIHRoZSBncmFwaFxuLy8gb2YgY29tcHV0YXRpb24uIFN1YnNjcmlwdGlvbnMgYXJlIHN1cHBvcnRlZC5cbmV4cG9ydCB7IGRlcCB9IGZyb20gXCIuL2RlcC5qc1wiO1xuLy8gVGhlIGRlZmF1bHRNYWtlQ2FjaGVLZXkgZnVuY3Rpb24gaXMgcmVtYXJrYWJseSBwb3dlcmZ1bCwgYmVjYXVzZSBpdCBnaXZlc1xuLy8gYSB1bmlxdWUgb2JqZWN0IGZvciBhbnkgc2hhbGxvdy1pZGVudGljYWwgbGlzdCBvZiBhcmd1bWVudHMuIElmIHlvdSBuZWVkXG4vLyB0byBpbXBsZW1lbnQgYSBjdXN0b20gbWFrZUNhY2hlS2V5IGZ1bmN0aW9uLCB5b3UgbWF5IGZpbmQgaXQgaGVscGZ1bCB0b1xuLy8gZGVsZWdhdGUgdGhlIGZpbmFsIHdvcmsgdG8gZGVmYXVsdE1ha2VDYWNoZUtleSwgd2hpY2ggaXMgd2h5IHdlIGV4cG9ydCBpdFxuLy8gaGVyZS4gSG93ZXZlciwgeW91IG1heSB3YW50IHRvIGF2b2lkIGRlZmF1bHRNYWtlQ2FjaGVLZXkgaWYgeW91ciBydW50aW1lXG4vLyBkb2VzIG5vdCBzdXBwb3J0IFdlYWtNYXAsIG9yIHlvdSBoYXZlIHRoZSBhYmlsaXR5IHRvIHJldHVybiBhIHN0cmluZyBrZXkuXG4vLyBJbiB0aG9zZSBjYXNlcywganVzdCB3cml0ZSB5b3VyIG93biBjdXN0b20gbWFrZUNhY2hlS2V5IGZ1bmN0aW9ucy5cbmxldCBkZWZhdWx0S2V5VHJpZTtcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TWFrZUNhY2hlS2V5KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0cmllID0gZGVmYXVsdEtleVRyaWUgfHwgKGRlZmF1bHRLZXlUcmllID0gbmV3IFRyaWUodHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIikpO1xuICAgIHJldHVybiB0cmllLmxvb2t1cEFycmF5KGFyZ3MpO1xufVxuLy8gSWYgeW91J3JlIHBhcmFub2lkIGFib3V0IG1lbW9yeSBsZWFrcywgb3IgeW91IHdhbnQgdG8gYXZvaWQgdXNpbmcgV2Vha01hcFxuLy8gdW5kZXIgdGhlIGhvb2QsIGJ1dCB5b3Ugc3RpbGwgbmVlZCB0aGUgYmVoYXZpb3Igb2YgZGVmYXVsdE1ha2VDYWNoZUtleSxcbi8vIGltcG9ydCB0aGlzIGNvbnN0cnVjdG9yIHRvIGNyZWF0ZSB5b3VyIG93biB0cmllcy5cbmV4cG9ydCB7IFRyaWUgYXMgS2V5VHJpZSB9O1xuO1xuY29uc3QgY2FjaGVzID0gbmV3IFNldCgpO1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXAob3JpZ2luYWxGdW5jdGlvbiwgeyBtYXggPSBNYXRoLnBvdygyLCAxNiksIGtleUFyZ3MsIG1ha2VDYWNoZUtleSA9IGRlZmF1bHRNYWtlQ2FjaGVLZXksIG5vcm1hbGl6ZVJlc3VsdCwgc3Vic2NyaWJlLCBjYWNoZTogY2FjaGVPcHRpb24gPSBTdHJvbmdDYWNoZSwgfSA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgICBjb25zdCBjYWNoZSA9IHR5cGVvZiBjYWNoZU9wdGlvbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gbmV3IGNhY2hlT3B0aW9uKG1heCwgZW50cnkgPT4gZW50cnkuZGlzcG9zZSgpKVxuICAgICAgICA6IGNhY2hlT3B0aW9uO1xuICAgIGNvbnN0IG9wdGltaXN0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBrZXlBcmdzID8ga2V5QXJncy5hcHBseShudWxsLCBhcmd1bWVudHMpIDogYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbnRyeSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoa2V5LCBlbnRyeSA9IG5ldyBFbnRyeShvcmlnaW5hbEZ1bmN0aW9uKSk7XG4gICAgICAgICAgICBlbnRyeS5ub3JtYWxpemVSZXN1bHQgPSBub3JtYWxpemVSZXN1bHQ7XG4gICAgICAgICAgICBlbnRyeS5zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgICAgICAvLyBHaXZlIHRoZSBFbnRyeSB0aGUgYWJpbGl0eSB0byB0cmlnZ2VyIGNhY2hlLmRlbGV0ZShrZXkpLCBldmVuIHRob3VnaFxuICAgICAgICAgICAgLy8gdGhlIEVudHJ5IGl0c2VsZiBkb2VzIG5vdCBrbm93IGFib3V0IGtleSBvciBjYWNoZS5cbiAgICAgICAgICAgIGVudHJ5LmZvcmdldCA9ICgpID0+IGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZW50cnkucmVjb21wdXRlKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAvLyBNb3ZlIHRoaXMgZW50cnkgdG8gdGhlIGZyb250IG9mIHRoZSBsZWFzdC1yZWNlbnRseSB1c2VkIHF1ZXVlLFxuICAgICAgICAvLyBzaW5jZSB3ZSBqdXN0IGZpbmlzaGVkIGNvbXB1dGluZyBpdHMgdmFsdWUuXG4gICAgICAgIGNhY2hlLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgY2FjaGVzLmFkZChjYWNoZSk7XG4gICAgICAgIC8vIENsZWFuIHVwIGFueSBleGNlc3MgZW50cmllcyBpbiB0aGUgY2FjaGUsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIGFjdGl2ZSBwYXJlbnQgZW50cnksIG1lYW5pbmcgd2UncmUgbm90IGluIHRoZSBtaWRkbGUgb2YgYSBsYXJnZXJcbiAgICAgICAgLy8gY29tcHV0YXRpb24gdGhhdCBtaWdodCBiZSBmbHVtbW94ZWQgYnkgdGhlIGNsZWFuaW5nLlxuICAgICAgICBpZiAoIXBhcmVudEVudHJ5U2xvdC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjYWNoZXMuZm9yRWFjaChjYWNoZSA9PiBjYWNoZS5jbGVhbigpKTtcbiAgICAgICAgICAgIGNhY2hlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpbWlzdGljLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGNhY2hlLnNpemUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5mcmVlemUob3B0aW1pc3RpYy5vcHRpb25zID0ge1xuICAgICAgICBtYXgsXG4gICAgICAgIGtleUFyZ3MsXG4gICAgICAgIG1ha2VDYWNoZUtleSxcbiAgICAgICAgbm9ybWFsaXplUmVzdWx0LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGNhY2hlLFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGRpcnR5S2V5KGtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGtleSAmJiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBlbnRyeS5zZXREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGltaXN0aWMuZGlydHlLZXkgPSBkaXJ0eUtleTtcbiAgICBvcHRpbWlzdGljLmRpcnR5ID0gZnVuY3Rpb24gZGlydHkoKSB7XG4gICAgICAgIGRpcnR5S2V5KG1ha2VDYWNoZUtleS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBlZWtLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ga2V5ICYmIGNhY2hlLmdldChrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5wZWVrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3B0aW1pc3RpYy5wZWVrS2V5ID0gcGVla0tleTtcbiAgICBvcHRpbWlzdGljLnBlZWsgPSBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICByZXR1cm4gcGVla0tleShtYWtlQ2FjaGVLZXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JnZXRLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBjYWNoZS5kZWxldGUoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgICBvcHRpbWlzdGljLmZvcmdldEtleSA9IGZvcmdldEtleTtcbiAgICBvcHRpbWlzdGljLmZvcmdldCA9IGZ1bmN0aW9uIGZvcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdldEtleShtYWtlQ2FjaGVLZXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBvcHRpbWlzdGljLm1ha2VDYWNoZUtleSA9IG1ha2VDYWNoZUtleTtcbiAgICBvcHRpbWlzdGljLmdldEtleSA9IGtleUFyZ3MgPyBmdW5jdGlvbiBnZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2FjaGVLZXkuYXBwbHkobnVsbCwga2V5QXJncy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9IDogbWFrZUNhY2hlS2V5O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG9wdGltaXN0aWMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/optimism/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zen-observable-ts/module.js":
/*!**************************************************!*\
  !*** ./node_modules/zen-observable-ts/module.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: () => (/* binding */ Observable)\n/* harmony export */ });\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.unsubscribe = function unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  };\n\n  _createClass(Subscription, [{\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  var _proto2 = SubscriptionObserver.prototype;\n\n  _proto2.next = function next(value) {\n    onNotify(this._subscription, 'next', value);\n  };\n\n  _proto2.error = function error(value) {\n    onNotify(this._subscription, 'error', value);\n  };\n\n  _proto2.complete = function complete() {\n    onNotify(this._subscription, 'complete');\n  };\n\n  _createClass(SubscriptionObserver, [{\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  var _proto3 = Observable.prototype;\n\n  _proto3.subscribe = function subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  };\n\n  _proto3.forEach = function forEach(fn) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      var subscription = _this.subscribe({\n        next: function (value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  _proto3.map = function map(fn) {\n    var _this2 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this2.subscribe({\n        next: function (value) {\n          try {\n            value = fn(value);\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.filter = function filter(fn) {\n    var _this3 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this3.subscribe({\n        next: function (value) {\n          try {\n            if (!fn(value)) return;\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.reduce = function reduce(fn) {\n    var _this4 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    var hasSeed = arguments.length > 1;\n    var hasValue = false;\n    var seed = arguments[1];\n    var acc = seed;\n    return new C(function (observer) {\n      return _this4.subscribe({\n        next: function (value) {\n          var first = !hasValue;\n          hasValue = true;\n\n          if (!first || hasSeed) {\n            try {\n              acc = fn(acc, value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            acc = value;\n          }\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n          observer.next(acc);\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.concat = function concat() {\n    var _this5 = this;\n\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscription;\n      var index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next: function (v) {\n            observer.next(v);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n        });\n      }\n\n      startNext(_this5);\n      return function () {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  };\n\n  _proto3.flatMap = function flatMap(fn) {\n    var _this6 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscriptions = [];\n\n      var outer = _this6.subscribe({\n        next: function (value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          var inner = C.from(value).subscribe({\n            next: function (value) {\n              observer.next(value);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              var i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n          });\n          subscriptions.push(inner);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          completeIfDone();\n        }\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return function () {\n        subscriptions.forEach(function (s) {\n          return s.unsubscribe();\n        });\n        outer.unsubscribe();\n      };\n    });\n  };\n\n  _proto3[SymbolObservable] = function () {\n    return this;\n  };\n\n  Observable.from = function from(x) {\n    var C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    var method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      var observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;) {\n              var item = _step.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  };\n\n  Observable.of = function of() {\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    var C = typeof this === 'function' ? this : Observable;\n    return new C(function (observer) {\n      enqueue(function () {\n        if (observer.closed) return;\n\n        for (var i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  };\n\n  _createClass(Observable, null, [{\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96ZW4tb2JzZXJ2YWJsZS10cy9tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDhEQUE4RCxpRkFBaUYsZ0RBQWdELHdIQUF3SCxnQkFBZ0IsV0FBVyxxQkFBcUIsNEJBQTRCLGNBQWMsU0FBUyxtQ0FBbUM7O0FBRTdiLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6Syw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4UTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlGQUF5Riw0QkFBNEI7QUFDckg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRXNCIiwic291cmNlcyI6WyJEOlxcRW1wbG95ZWVEaXJlY3RvcnlBcHBcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHplbi1vYnNlcnZhYmxlLXRzXFxtb2R1bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyByZXR1cm4gZnVuY3Rpb24gKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLy8gPT09IFN5bWJvbCBTdXBwb3J0ID09PVxudmFyIGhhc1N5bWJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGhhc1N5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2xzKCkgJiYgQm9vbGVhbihTeW1ib2xbbmFtZV0pO1xufTtcblxudmFyIGdldFN5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2wobmFtZSkgPyBTeW1ib2xbbmFtZV0gOiAnQEAnICsgbmFtZTtcbn07XG5cbmlmIChoYXNTeW1ib2xzKCkgJiYgIWhhc1N5bWJvbCgnb2JzZXJ2YWJsZScpKSB7XG4gIFN5bWJvbC5vYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG59XG5cbnZhciBTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sKCdvYnNlcnZhYmxlJyk7XG52YXIgU3ltYm9sU3BlY2llcyA9IGdldFN5bWJvbCgnc3BlY2llcycpOyAvLyA9PT0gQWJzdHJhY3QgT3BlcmF0aW9ucyA9PT1cblxuZnVuY3Rpb24gZ2V0TWV0aG9kKG9iaiwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWVzKG9iaikge1xuICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcblxuICBpZiAoY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3RvciA9IGN0b3JbU3ltYm9sU3BlY2llc107XG5cbiAgICBpZiAoY3RvciA9PT0gbnVsbCkge1xuICAgICAgY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3RvciAhPT0gdW5kZWZpbmVkID8gY3RvciA6IE9ic2VydmFibGU7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgT2JzZXJ2YWJsZTsgLy8gU1BFQzogQnJhbmQgY2hlY2tcbn1cblxuZnVuY3Rpb24gaG9zdFJlcG9ydEVycm9yKGUpIHtcbiAgaWYgKGhvc3RSZXBvcnRFcnJvci5sb2cpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IubG9nKGUpO1xuICB9IGVsc2Uge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlKGZuKSB7XG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fY2xlYW51cDtcbiAgaWYgKGNsZWFudXAgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBzdWJzY3JpcHRpb24uX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFjbGVhbnVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVuc3Vic2NyaWJlID0gZ2V0TWV0aG9kKGNsZWFudXAsICd1bnN1YnNjcmliZScpO1xuXG4gICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdW5zdWJzY3JpYmUuY2FsbChjbGVhbnVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAnY2xvc2VkJztcbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHZhciBxdWV1ZSA9IHN1YnNjcmlwdGlvbi5fcXVldWU7XG5cbiAgaWYgKCFxdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAncmVhZHknO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBxdWV1ZVtpXS50eXBlLCBxdWV1ZVtpXS52YWx1ZSk7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCB0eXBlLCB2YWx1ZSkge1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ3J1bm5pbmcnO1xuICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX29ic2VydmVyO1xuXG4gIHRyeSB7XG4gICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIsIHR5cGUpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBpZiAobSkgbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7ZWxzZSB0aHJvdyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO2Vsc2UgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdydW5uaW5nJykgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdyZWFkeSc7XG59XG5cbmZ1bmN0aW9uIG9uTm90aWZ5KHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSByZXR1cm47XG5cbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdidWZmZXJpbmcnKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9xdWV1ZS5wdXNoKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlICE9PSAncmVhZHknKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdidWZmZXJpbmcnO1xuICAgIHN1YnNjcmlwdGlvbi5fcXVldWUgPSBbe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH1dO1xuICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZsdXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpO1xufVxuXG52YXIgU3Vic2NyaXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gICAgLy8gQVNTRVJUOiBvYnNlcnZlciBpcyBhbiBvYmplY3RcbiAgICAvLyBBU1NFUlQ6IHN1YnNjcmliZXIgaXMgY2FsbGFibGVcbiAgICB0aGlzLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhdGUgPSAnaW5pdGlhbGl6aW5nJztcbiAgICB2YXIgc3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY2xlYW51cCA9IHN1YnNjcmliZXIuY2FsbCh1bmRlZmluZWQsIHN1YnNjcmlwdGlvbk9ic2VydmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWJzY3JpcHRpb25PYnNlcnZlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdpbml0aWFsaXppbmcnKSB0aGlzLl9zdGF0ZSA9ICdyZWFkeSc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3Vic2NyaXB0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8udW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTtcbiAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdWJzY3JpcHRpb24sIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb25PYnNlcnZlcihzdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLm5leHQgPSBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnbmV4dCcsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmVycm9yID0gZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICBvbk5vdGlmeSh0aGlzLl9zdWJzY3JpcHRpb24sICdlcnJvcicsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnY29tcGxldGUnKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3Vic2NyaXB0aW9uT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb25PYnNlcnZlcjtcbn0oKTtcblxudmFyIE9ic2VydmFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmFibGUgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYnNlcnZhYmxlIGluaXRpYWxpemVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBPYnNlcnZhYmxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgbmV4dDogb2JzZXJ2ZXIsXG4gICAgICAgIGVycm9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIGNvbXBsZXRlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX3N1YnNjcmliZXIpO1xuICB9O1xuXG4gIF9wcm90bzMuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4odmFsdWUsIGRvbmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMubWFwID0gZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGZuKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWZuKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5yZWR1Y2UgPSBmdW5jdGlvbiByZWR1Y2UoZm4pIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgIHZhciBoYXNTZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGFjYyA9IHNlZWQ7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIF90aGlzNC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSAhaGFzVmFsdWU7XG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFmaXJzdCB8fCBoYXNTZWVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhY2MgPSBmbihhY2MsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2MgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzVmFsdWUgJiYgIWhhc1NlZWQpIHJldHVybiBvYnNlcnZlci5lcnJvcihuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVkdWNlIGFuIGVtcHR5IHNlcXVlbmNlJykpO1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoYWNjKTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8zLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0TmV4dChuZXh0KSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5leHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydE5leHQoQy5mcm9tKHNvdXJjZXNbaW5kZXgrK10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzdGFydE5leHQoX3RoaXM1KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5mbGF0TWFwID0gZnVuY3Rpb24gZmxhdE1hcChmbikge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgdmFyIG91dGVyID0gX3RoaXM2LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5uZXIgPSBDLmZyb20odmFsdWUpLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKGlubmVyKTtcbiAgICAgICAgICAgICAgaWYgKGkgPj0gMCkgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGNvbXBsZXRlSWZEb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGlubmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcGxldGVJZkRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlSWZEb25lKCkge1xuICAgICAgICBpZiAob3V0ZXIuY2xvc2VkICYmIHN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvM1tTeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBPYnNlcnZhYmxlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6IE9ic2VydmFibGU7XG4gICAgaWYgKHggPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZCh4LCBTeW1ib2xPYnNlcnZhYmxlKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbWV0aG9kLmNhbGwoeCk7XG4gICAgICBpZiAoT2JqZWN0KG9ic2VydmFibGUpICE9PSBvYnNlcnZhYmxlKSB0aHJvdyBuZXcgVHlwZUVycm9yKG9ic2VydmFibGUgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgIGlmIChpc09ic2VydmFibGUob2JzZXJ2YWJsZSkgJiYgb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3ltYm9sKCdpdGVyYXRvcicpKSB7XG4gICAgICBtZXRob2QgPSBnZXRNZXRob2QoeCwgU3ltYm9sSXRlcmF0b3IpO1xuXG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShtZXRob2QuY2FsbCh4KSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbSk7XG4gICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHhbaV0pO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3Qgb2JzZXJ2YWJsZScpO1xuICB9O1xuXG4gIE9ic2VydmFibGUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogT2JzZXJ2YWJsZTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGUsIG51bGwsIFt7XG4gICAga2V5OiBTeW1ib2xTcGVjaWVzLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KCk7XG5cbmlmIChoYXNTeW1ib2xzKCkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGUsIFN5bWJvbCgnZXh0ZW5zaW9ucycpLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHN5bWJvbDogU3ltYm9sT2JzZXJ2YWJsZSxcbiAgICAgIGhvc3RSZXBvcnRFcnJvcjogaG9zdFJlcG9ydEVycm9yXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IE9ic2VydmFibGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zen-observable-ts/module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/EmployeeList.tsx":
/*!*****************************************!*\
  !*** ./src/components/EmployeeList.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @apollo/client */ \"(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useQuery.js\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @apollo/client */ \"(app-pages-browser)/./node_modules/@apollo/client/react/hooks/useLazyQuery.js\");\n/* harmony import */ var _graphql_queries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/graphql/queries */ \"(app-pages-browser)/./src/graphql/queries.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);\n// import { useLazyQuery, useQuery } from '@apollo/client';\n// import { GET_ALL_EMPLOYEES, GET_EMPLOYEES_BY_DEPARTMENT } from '@/graphql/queries';\n// import { useState, useEffect } from 'react';\n// import Link from 'next/link';\n// const EmployeeList = () => {\n//   const [selectedDepartment, setSelectedDepartment] = useState('All');\n//   // Get all employees initially (to build the department dropdown)\n//   const { data: allData, loading: loadingAll, error: errorAll } = useQuery(GET_ALL_EMPLOYEES);\n//   // Lazy query for department filtering\n//   const [fetchByDepartment, { data: filteredData, loading: loadingFiltered, error: errorFiltered }] =\n//     useLazyQuery(GET_EMPLOYEES_BY_DEPARTMENT);\n//   useEffect(() => {\n//     if (selectedDepartment !== 'All') {\n//       fetchByDepartment({ variables: { department: selectedDepartment } });\n//     }\n//   }, [selectedDepartment,fetchByDepartment]);\n//   const allEmployees = allData?.getAllEmployees || [];\n//   const filteredEmployees = filteredData?.getEmployeesByDepartment || [];\n//   const departments: string[] = Array.from(\n//     new Set(allEmployees.map((e:any) => e.department))\n//   );\n//   const employeesToShow = selectedDepartment === 'All' ? allEmployees : filteredEmployees;\n//   if (loadingAll || loadingFiltered) return <p>Loading...</p>;\n//   if (errorAll) return <p>Error loading employees: {errorAll.message}</p>;\n//   if (errorFiltered) return <p>Error filtering: {errorFiltered.message}</p>;\n//   return (\n//     <div className=\"mt-6\">\n//       <div className=\"mb-4\">\n//         <label className=\"text-sm font-medium\">\n//           Filter by Department:{' '}\n//           <select\n//             className=\"ml-2 border border-gray-300 p-1 rounded\"\n//             value={selectedDepartment}\n//             onChange={(e) => setSelectedDepartment(e.target.value)}\n//           >\n//             <option value=\"All\">All</option>\n//             {departments.map((dept) => (\n//               <option key={dept} value={dept}>\n//                 {dept}\n//               </option>\n//             ))}\n//           </select>\n//         </label>\n//       </div>\n//       <table className=\"w-full border-collapse border border-gray-300\">\n//         <thead className=\"bg-gray-100\">\n//            <tr>\n//             <th className=\"p-2 border\">Name</th>\n//             <th className=\"p-2 border\">Position</th>\n//             <th className=\"p-2 border\">Department</th>\n//           </tr>\n//         </thead>\n//         <tbody>\n//           {employeesToShow.map((emp: any) => (\n//             <tr key={emp.id} className=\"text-center\">\n//               <Link href={`/employee/${emp.id}`}>{emp.name}</Link>\n//               <td className=\"p-2 border\">{emp.position}</td>\n//               <td className=\"p-2 border\">{emp.department}</td>\n//             </tr>\n//           ))}\n//         </tbody>\n//       </table>\n//     </div>\n//   );\n// };\n// export default EmployeeList;\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst EmployeeList = ()=>{\n    _s();\n    const [selectedDepartment, setSelectedDepartment] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)('All');\n    // Get all employees initially (to build the department dropdown)\n    const { data: allData, loading: loadingAll, error: errorAll } = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_4__.useQuery)(_graphql_queries__WEBPACK_IMPORTED_MODULE_1__.GET_ALL_EMPLOYEES);\n    // Lazy query for department filtering\n    const [fetchByDepartment, { data: filteredData, loading: loadingFiltered, error: errorFiltered }] = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_5__.useLazyQuery)(_graphql_queries__WEBPACK_IMPORTED_MODULE_1__.GET_EMPLOYEES_BY_DEPARTMENT);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"EmployeeList.useEffect\": ()=>{\n            if (selectedDepartment !== 'All') {\n                fetchByDepartment({\n                    variables: {\n                        department: selectedDepartment\n                    }\n                });\n            }\n        }\n    }[\"EmployeeList.useEffect\"], [\n        selectedDepartment,\n        fetchByDepartment\n    ]);\n    const allEmployees = (allData === null || allData === void 0 ? void 0 : allData.getAllEmployees) || [];\n    const filteredEmployees = (filteredData === null || filteredData === void 0 ? void 0 : filteredData.getEmployeesByDepartment) || [];\n    const departments = Array.from(new Set(allEmployees.map((e)=>e.department)));\n    const employeesToShow = selectedDepartment === 'All' ? allEmployees : filteredEmployees;\n    if (loadingAll || loadingFiltered) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n        children: \"Loading...\"\n    }, void 0, false, {\n        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n        lineNumber: 121,\n        columnNumber: 45\n    }, undefined);\n    if (errorAll) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n        children: [\n            \"Error loading employees: \",\n            errorAll.message\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n        lineNumber: 122,\n        columnNumber: 24\n    }, undefined);\n    if (errorFiltered) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n        children: [\n            \"Error filtering: \",\n            errorFiltered.message\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n        lineNumber: 123,\n        columnNumber: 29\n    }, undefined);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"mt-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"text-sm font-medium\",\n                    children: [\n                        \"Filter by Department:\",\n                        ' ',\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                            className: \"ml-2 border border-gray-300 p-1 rounded\",\n                            value: selectedDepartment,\n                            onChange: (e)=>setSelectedDepartment(e.target.value),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                    value: \"All\",\n                                    children: \"All\"\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                    lineNumber: 135,\n                                    columnNumber: 13\n                                }, undefined),\n                                departments.map((dept)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: dept,\n                                        children: dept\n                                    }, dept, false, {\n                                        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                        lineNumber: 137,\n                                        columnNumber: 15\n                                    }, undefined))\n                            ]\n                        }, void 0, true, {\n                            fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                            lineNumber: 130,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                    lineNumber: 128,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                lineNumber: 127,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                className: \"w-full border-collapse border border-gray-300\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"thead\", {\n                        className: \"bg-gray-100\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    className: \"p-2 border\",\n                                    children: \"Name\"\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                    lineNumber: 148,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    className: \"p-2 border\",\n                                    children: \"Position\"\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                    lineNumber: 149,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                    className: \"p-2 border\",\n                                    children: \"Department\"\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                    lineNumber: 150,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                            lineNumber: 147,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                        lineNumber: 146,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tbody\", {\n                        children: employeesToShow.map((emp)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                className: \"text-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        className: \"p-2 border\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_3___default()), {\n                                            href: \"/employee/\".concat(emp.id),\n                                            children: emp.name\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                            lineNumber: 157,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                        lineNumber: 156,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        className: \"p-2 border\",\n                                        children: emp.position\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                        lineNumber: 159,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                        className: \"p-2 border\",\n                                        children: emp.department\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                        lineNumber: 160,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, emp.id, true, {\n                                fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                                lineNumber: 155,\n                                columnNumber: 13\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                        lineNumber: 153,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n                lineNumber: 145,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\EmployeeDirectoryApp\\\\frontend\\\\src\\\\components\\\\EmployeeList.tsx\",\n        lineNumber: 126,\n        columnNumber: 5\n    }, undefined);\n};\n_s(EmployeeList, \"4Q27NkJhAdEWfXX7l37FbnnYccY=\", false, function() {\n    return [\n        _apollo_client__WEBPACK_IMPORTED_MODULE_4__.useQuery,\n        _apollo_client__WEBPACK_IMPORTED_MODULE_5__.useLazyQuery\n    ];\n});\n_c = EmployeeList;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EmployeeList);\nvar _c;\n$RefreshReg$(_c, \"EmployeeList\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0VtcGxveWVlTGlzdC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMkRBQTJEO0FBQzNELHNGQUFzRjtBQUN0RiwrQ0FBK0M7QUFDL0MsZ0NBQWdDO0FBRWhDLCtCQUErQjtBQUMvQix5RUFBeUU7QUFFekUsc0VBQXNFO0FBQ3RFLGlHQUFpRztBQUVqRywyQ0FBMkM7QUFDM0Msd0dBQXdHO0FBQ3hHLGlEQUFpRDtBQUVqRCxzQkFBc0I7QUFDdEIsMENBQTBDO0FBQzFDLDhFQUE4RTtBQUM5RSxRQUFRO0FBQ1IsZ0RBQWdEO0FBRWhELHlEQUF5RDtBQUN6RCw0RUFBNEU7QUFFNUUsOENBQThDO0FBQzlDLHlEQUF5RDtBQUN6RCxPQUFPO0FBRVAsNkZBQTZGO0FBRTdGLGlFQUFpRTtBQUNqRSw2RUFBNkU7QUFDN0UsK0VBQStFO0FBRS9FLGFBQWE7QUFDYiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLGtEQUFrRDtBQUNsRCx1Q0FBdUM7QUFDdkMsb0JBQW9CO0FBQ3BCLGtFQUFrRTtBQUNsRSx5Q0FBeUM7QUFDekMsc0VBQXNFO0FBQ3RFLGNBQWM7QUFDZCwrQ0FBK0M7QUFDL0MsMkNBQTJDO0FBQzNDLGlEQUFpRDtBQUNqRCx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLGVBQWU7QUFFZiwwRUFBMEU7QUFDMUUsMENBQTBDO0FBQzFDLGtCQUFrQjtBQUNsQixtREFBbUQ7QUFDbkQsdURBQXVEO0FBQ3ZELHlEQUF5RDtBQUN6RCxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixpREFBaUQ7QUFDakQsd0RBQXdEO0FBQ3hELHFFQUFxRTtBQUNyRSwrREFBK0Q7QUFDL0QsaUVBQWlFO0FBQ2pFLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsT0FBTztBQUNQLEtBQUs7QUFFTCwrQkFBK0I7OztBQUl5QjtBQUMyQjtBQUN2QztBQUNmO0FBVzdCLE1BQU1PLGVBQWU7O0lBQ25CLE1BQU0sQ0FBQ0Msb0JBQW9CQyxzQkFBc0IsR0FBR0wsK0NBQVFBLENBQUM7SUFFN0QsaUVBQWlFO0lBQ2pFLE1BQU0sRUFBRU0sTUFBTUMsT0FBTyxFQUFFQyxTQUFTQyxVQUFVLEVBQUVDLE9BQU9DLFFBQVEsRUFBRSxHQUFHZCx3REFBUUEsQ0FBQ0MsK0RBQWlCQTtJQUUxRixzQ0FBc0M7SUFDdEMsTUFBTSxDQUFDYyxtQkFBbUIsRUFBRU4sTUFBTU8sWUFBWSxFQUFFTCxTQUFTTSxlQUFlLEVBQUVKLE9BQU9LLGFBQWEsRUFBRSxDQUFDLEdBQy9GbkIsNERBQVlBLENBQUNHLHlFQUEyQkE7SUFFMUNFLGdEQUFTQTtrQ0FBQztZQUNSLElBQUlHLHVCQUF1QixPQUFPO2dCQUNoQ1Esa0JBQWtCO29CQUFFSSxXQUFXO3dCQUFFQyxZQUFZYjtvQkFBbUI7Z0JBQUU7WUFDcEU7UUFDRjtpQ0FBRztRQUFDQTtRQUFvQlE7S0FBa0I7SUFFMUMsTUFBTU0sZUFBMkJYLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU1ksZUFBZSxLQUFJLEVBQUU7SUFDL0QsTUFBTUMsb0JBQWdDUCxDQUFBQSx5QkFBQUEsbUNBQUFBLGFBQWNRLHdCQUF3QixLQUFJLEVBQUU7SUFFbEYsTUFBTUMsY0FBd0JDLE1BQU1DLElBQUksQ0FDdEMsSUFBSUMsSUFBSVAsYUFBYVEsR0FBRyxDQUFDLENBQUNDLElBQU1BLEVBQUVWLFVBQVU7SUFHOUMsTUFBTVcsa0JBQ0p4Qix1QkFBdUIsUUFBUWMsZUFBZUU7SUFFaEQsSUFBSVgsY0FBY0ssaUJBQWlCLHFCQUFPLDhEQUFDZTtrQkFBRTs7Ozs7O0lBQzdDLElBQUlsQixVQUFVLHFCQUFPLDhEQUFDa0I7O1lBQUU7WUFBMEJsQixTQUFTbUIsT0FBTzs7Ozs7OztJQUNsRSxJQUFJZixlQUFlLHFCQUFPLDhEQUFDYzs7WUFBRTtZQUFrQmQsY0FBY2UsT0FBTzs7Ozs7OztJQUVwRSxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDQztvQkFBTUQsV0FBVTs7d0JBQXNCO3dCQUNmO3NDQUN0Qiw4REFBQ0U7NEJBQ0NGLFdBQVU7NEJBQ1ZHLE9BQU8vQjs0QkFDUGdDLFVBQVUsQ0FBQ1QsSUFBTXRCLHNCQUFzQnNCLEVBQUVVLE1BQU0sQ0FBQ0YsS0FBSzs7OENBRXJELDhEQUFDRztvQ0FBT0gsT0FBTTs4Q0FBTTs7Ozs7O2dDQUNuQmIsWUFBWUksR0FBRyxDQUFDLENBQUNhLHFCQUNoQiw4REFBQ0Q7d0NBQWtCSCxPQUFPSTtrREFDdkJBO3VDQURVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFRckIsOERBQUNDO2dCQUFNUixXQUFVOztrQ0FDZiw4REFBQ1M7d0JBQU1ULFdBQVU7a0NBQ2YsNEVBQUNVOzs4Q0FDQyw4REFBQ0M7b0NBQUdYLFdBQVU7OENBQWE7Ozs7Ozs4Q0FDM0IsOERBQUNXO29DQUFHWCxXQUFVOzhDQUFhOzs7Ozs7OENBQzNCLDhEQUFDVztvQ0FBR1gsV0FBVTs4Q0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBRy9CLDhEQUFDWTtrQ0FDRWhCLGdCQUFnQkYsR0FBRyxDQUFDLENBQUNtQixvQkFDcEIsOERBQUNIO2dDQUFnQlYsV0FBVTs7a0RBQ3pCLDhEQUFDYzt3Q0FBR2QsV0FBVTtrREFDWiw0RUFBQzlCLGtEQUFJQTs0Q0FBQzZDLE1BQU0sYUFBb0IsT0FBUEYsSUFBSUcsRUFBRTtzREFBS0gsSUFBSUksSUFBSTs7Ozs7Ozs7Ozs7a0RBRTlDLDhEQUFDSDt3Q0FBR2QsV0FBVTtrREFBY2EsSUFBSUssUUFBUTs7Ozs7O2tEQUN4Qyw4REFBQ0o7d0NBQUdkLFdBQVU7a0RBQWNhLElBQUk1QixVQUFVOzs7Ozs7OytCQUxuQzRCLElBQUlHLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZM0I7R0F4RU03Qzs7UUFJNEROLG9EQUFRQTtRQUl0RUQsd0RBQVlBOzs7S0FSVk87QUEwRU4saUVBQWVBLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxFbXBsb3llZURpcmVjdG9yeUFwcFxcZnJvbnRlbmRcXHNyY1xcY29tcG9uZW50c1xcRW1wbG95ZWVMaXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgeyB1c2VMYXp5UXVlcnksIHVzZVF1ZXJ5IH0gZnJvbSAnQGFwb2xsby9jbGllbnQnO1xyXG4vLyBpbXBvcnQgeyBHRVRfQUxMX0VNUExPWUVFUywgR0VUX0VNUExPWUVFU19CWV9ERVBBUlRNRU5UIH0gZnJvbSAnQC9ncmFwaHFsL3F1ZXJpZXMnO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG4vLyBpbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnO1xyXG5cclxuLy8gY29uc3QgRW1wbG95ZWVMaXN0ID0gKCkgPT4ge1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZERlcGFydG1lbnQsIHNldFNlbGVjdGVkRGVwYXJ0bWVudF0gPSB1c2VTdGF0ZSgnQWxsJyk7XHJcblxyXG4vLyAgIC8vIEdldCBhbGwgZW1wbG95ZWVzIGluaXRpYWxseSAodG8gYnVpbGQgdGhlIGRlcGFydG1lbnQgZHJvcGRvd24pXHJcbi8vICAgY29uc3QgeyBkYXRhOiBhbGxEYXRhLCBsb2FkaW5nOiBsb2FkaW5nQWxsLCBlcnJvcjogZXJyb3JBbGwgfSA9IHVzZVF1ZXJ5KEdFVF9BTExfRU1QTE9ZRUVTKTtcclxuXHJcbi8vICAgLy8gTGF6eSBxdWVyeSBmb3IgZGVwYXJ0bWVudCBmaWx0ZXJpbmdcclxuLy8gICBjb25zdCBbZmV0Y2hCeURlcGFydG1lbnQsIHsgZGF0YTogZmlsdGVyZWREYXRhLCBsb2FkaW5nOiBsb2FkaW5nRmlsdGVyZWQsIGVycm9yOiBlcnJvckZpbHRlcmVkIH1dID1cclxuLy8gICAgIHVzZUxhenlRdWVyeShHRVRfRU1QTE9ZRUVTX0JZX0RFUEFSVE1FTlQpO1xyXG5cclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKHNlbGVjdGVkRGVwYXJ0bWVudCAhPT0gJ0FsbCcpIHtcclxuLy8gICAgICAgZmV0Y2hCeURlcGFydG1lbnQoeyB2YXJpYWJsZXM6IHsgZGVwYXJ0bWVudDogc2VsZWN0ZWREZXBhcnRtZW50IH0gfSk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW3NlbGVjdGVkRGVwYXJ0bWVudCxmZXRjaEJ5RGVwYXJ0bWVudF0pO1xyXG5cclxuLy8gICBjb25zdCBhbGxFbXBsb3llZXMgPSBhbGxEYXRhPy5nZXRBbGxFbXBsb3llZXMgfHwgW107XHJcbi8vICAgY29uc3QgZmlsdGVyZWRFbXBsb3llZXMgPSBmaWx0ZXJlZERhdGE/LmdldEVtcGxveWVlc0J5RGVwYXJ0bWVudCB8fCBbXTtcclxuXHJcbi8vICAgY29uc3QgZGVwYXJ0bWVudHM6IHN0cmluZ1tdID0gQXJyYXkuZnJvbShcclxuLy8gICAgIG5ldyBTZXQoYWxsRW1wbG95ZWVzLm1hcCgoZTphbnkpID0+IGUuZGVwYXJ0bWVudCkpXHJcbi8vICAgKTtcclxuXHJcbi8vICAgY29uc3QgZW1wbG95ZWVzVG9TaG93ID0gc2VsZWN0ZWREZXBhcnRtZW50ID09PSAnQWxsJyA/IGFsbEVtcGxveWVlcyA6IGZpbHRlcmVkRW1wbG95ZWVzO1xyXG5cclxuLy8gICBpZiAobG9hZGluZ0FsbCB8fCBsb2FkaW5nRmlsdGVyZWQpIHJldHVybiA8cD5Mb2FkaW5nLi4uPC9wPjtcclxuLy8gICBpZiAoZXJyb3JBbGwpIHJldHVybiA8cD5FcnJvciBsb2FkaW5nIGVtcGxveWVlczoge2Vycm9yQWxsLm1lc3NhZ2V9PC9wPjtcclxuLy8gICBpZiAoZXJyb3JGaWx0ZXJlZCkgcmV0dXJuIDxwPkVycm9yIGZpbHRlcmluZzoge2Vycm9yRmlsdGVyZWQubWVzc2FnZX08L3A+O1xyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC02XCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNFwiPlxyXG4vLyAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtXCI+XHJcbi8vICAgICAgICAgICBGaWx0ZXIgYnkgRGVwYXJ0bWVudDp7JyAnfVxyXG4vLyAgICAgICAgICAgPHNlbGVjdFxyXG4vLyAgICAgICAgICAgICBjbGFzc05hbWU9XCJtbC0yIGJvcmRlciBib3JkZXItZ3JheS0zMDAgcC0xIHJvdW5kZWRcIlxyXG4vLyAgICAgICAgICAgICB2YWx1ZT17c2VsZWN0ZWREZXBhcnRtZW50fVxyXG4vLyAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFNlbGVjdGVkRGVwYXJ0bWVudChlLnRhcmdldC52YWx1ZSl9XHJcbi8vICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJBbGxcIj5BbGw8L29wdGlvbj5cclxuLy8gICAgICAgICAgICAge2RlcGFydG1lbnRzLm1hcCgoZGVwdCkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxvcHRpb24ga2V5PXtkZXB0fSB2YWx1ZT17ZGVwdH0+XHJcbi8vICAgICAgICAgICAgICAgICB7ZGVwdH1cclxuLy8gICAgICAgICAgICAgICA8L29wdGlvbj5cclxuLy8gICAgICAgICAgICAgKSl9XHJcbi8vICAgICAgICAgICA8L3NlbGVjdD5cclxuLy8gICAgICAgICA8L2xhYmVsPlxyXG4vLyAgICAgICA8L2Rpdj5cclxuXHJcbi8vICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ3LWZ1bGwgYm9yZGVyLWNvbGxhcHNlIGJvcmRlciBib3JkZXItZ3JheS0zMDBcIj5cclxuLy8gICAgICAgICA8dGhlYWQgY2xhc3NOYW1lPVwiYmctZ3JheS0xMDBcIj5cclxuLy8gICAgICAgICAgICA8dHI+XHJcbi8vICAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJwLTIgYm9yZGVyXCI+TmFtZTwvdGg+XHJcbi8vICAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJwLTIgYm9yZGVyXCI+UG9zaXRpb248L3RoPlxyXG4vLyAgICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwicC0yIGJvcmRlclwiPkRlcGFydG1lbnQ8L3RoPlxyXG4vLyAgICAgICAgICAgPC90cj5cclxuLy8gICAgICAgICA8L3RoZWFkPlxyXG4vLyAgICAgICAgIDx0Ym9keT5cclxuLy8gICAgICAgICAgIHtlbXBsb3llZXNUb1Nob3cubWFwKChlbXA6IGFueSkgPT4gKFxyXG4vLyAgICAgICAgICAgICA8dHIga2V5PXtlbXAuaWR9IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XHJcbi8vICAgICAgICAgICAgICAgPExpbmsgaHJlZj17YC9lbXBsb3llZS8ke2VtcC5pZH1gfT57ZW1wLm5hbWV9PC9MaW5rPlxyXG4vLyAgICAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJwLTIgYm9yZGVyXCI+e2VtcC5wb3NpdGlvbn08L3RkPlxyXG4vLyAgICAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJwLTIgYm9yZGVyXCI+e2VtcC5kZXBhcnRtZW50fTwvdGQ+XHJcbi8vICAgICAgICAgICAgIDwvdHI+XHJcbi8vICAgICAgICAgICApKX1cclxuLy8gICAgICAgICA8L3Rib2R5PlxyXG4vLyAgICAgICA8L3RhYmxlPlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfTtcclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IEVtcGxveWVlTGlzdDtcclxuXHJcblxyXG5cclxuaW1wb3J0IHsgdXNlTGF6eVF1ZXJ5LCB1c2VRdWVyeSB9IGZyb20gJ0BhcG9sbG8vY2xpZW50JztcclxuaW1wb3J0IHsgR0VUX0FMTF9FTVBMT1lFRVMsIEdFVF9FTVBMT1lFRVNfQllfREVQQVJUTUVOVCB9IGZyb20gJ0AvZ3JhcGhxbC9xdWVyaWVzJztcclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuXHJcbi8vIERlZmluZSB0aGUgdHlwZSBmb3IgYW4gZW1wbG95ZWVcclxudHlwZSBFbXBsb3llZSA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBwb3NpdGlvbjogc3RyaW5nO1xyXG4gIGRlcGFydG1lbnQ6IHN0cmluZztcclxuICBzYWxhcnk6IG51bWJlcjtcclxufTtcclxuXHJcbmNvbnN0IEVtcGxveWVlTGlzdCA9ICgpID0+IHtcclxuICBjb25zdCBbc2VsZWN0ZWREZXBhcnRtZW50LCBzZXRTZWxlY3RlZERlcGFydG1lbnRdID0gdXNlU3RhdGUoJ0FsbCcpO1xyXG5cclxuICAvLyBHZXQgYWxsIGVtcGxveWVlcyBpbml0aWFsbHkgKHRvIGJ1aWxkIHRoZSBkZXBhcnRtZW50IGRyb3Bkb3duKVxyXG4gIGNvbnN0IHsgZGF0YTogYWxsRGF0YSwgbG9hZGluZzogbG9hZGluZ0FsbCwgZXJyb3I6IGVycm9yQWxsIH0gPSB1c2VRdWVyeShHRVRfQUxMX0VNUExPWUVFUyk7XHJcblxyXG4gIC8vIExhenkgcXVlcnkgZm9yIGRlcGFydG1lbnQgZmlsdGVyaW5nXHJcbiAgY29uc3QgW2ZldGNoQnlEZXBhcnRtZW50LCB7IGRhdGE6IGZpbHRlcmVkRGF0YSwgbG9hZGluZzogbG9hZGluZ0ZpbHRlcmVkLCBlcnJvcjogZXJyb3JGaWx0ZXJlZCB9XSA9XHJcbiAgICB1c2VMYXp5UXVlcnkoR0VUX0VNUExPWUVFU19CWV9ERVBBUlRNRU5UKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChzZWxlY3RlZERlcGFydG1lbnQgIT09ICdBbGwnKSB7XHJcbiAgICAgIGZldGNoQnlEZXBhcnRtZW50KHsgdmFyaWFibGVzOiB7IGRlcGFydG1lbnQ6IHNlbGVjdGVkRGVwYXJ0bWVudCB9IH0pO1xyXG4gICAgfVxyXG4gIH0sIFtzZWxlY3RlZERlcGFydG1lbnQsIGZldGNoQnlEZXBhcnRtZW50XSk7XHJcblxyXG4gIGNvbnN0IGFsbEVtcGxveWVlczogRW1wbG95ZWVbXSA9IGFsbERhdGE/LmdldEFsbEVtcGxveWVlcyB8fCBbXTtcclxuICBjb25zdCBmaWx0ZXJlZEVtcGxveWVlczogRW1wbG95ZWVbXSA9IGZpbHRlcmVkRGF0YT8uZ2V0RW1wbG95ZWVzQnlEZXBhcnRtZW50IHx8IFtdO1xyXG5cclxuICBjb25zdCBkZXBhcnRtZW50czogc3RyaW5nW10gPSBBcnJheS5mcm9tKFxyXG4gICAgbmV3IFNldChhbGxFbXBsb3llZXMubWFwKChlKSA9PiBlLmRlcGFydG1lbnQpKVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGVtcGxveWVlc1RvU2hvdzogRW1wbG95ZWVbXSA9XHJcbiAgICBzZWxlY3RlZERlcGFydG1lbnQgPT09ICdBbGwnID8gYWxsRW1wbG95ZWVzIDogZmlsdGVyZWRFbXBsb3llZXM7XHJcblxyXG4gIGlmIChsb2FkaW5nQWxsIHx8IGxvYWRpbmdGaWx0ZXJlZCkgcmV0dXJuIDxwPkxvYWRpbmcuLi48L3A+O1xyXG4gIGlmIChlcnJvckFsbCkgcmV0dXJuIDxwPkVycm9yIGxvYWRpbmcgZW1wbG95ZWVzOiB7ZXJyb3JBbGwubWVzc2FnZX08L3A+O1xyXG4gIGlmIChlcnJvckZpbHRlcmVkKSByZXR1cm4gPHA+RXJyb3IgZmlsdGVyaW5nOiB7ZXJyb3JGaWx0ZXJlZC5tZXNzYWdlfTwvcD47XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTZcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi00XCI+XHJcbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW1cIj5cclxuICAgICAgICAgIEZpbHRlciBieSBEZXBhcnRtZW50OnsnICd9XHJcbiAgICAgICAgICA8c2VsZWN0XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1sLTIgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCBwLTEgcm91bmRlZFwiXHJcbiAgICAgICAgICAgIHZhbHVlPXtzZWxlY3RlZERlcGFydG1lbnR9XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0U2VsZWN0ZWREZXBhcnRtZW50KGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIkFsbFwiPkFsbDwvb3B0aW9uPlxyXG4gICAgICAgICAgICB7ZGVwYXJ0bWVudHMubWFwKChkZXB0KSA9PiAoXHJcbiAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9e2RlcHR9IHZhbHVlPXtkZXB0fT5cclxuICAgICAgICAgICAgICAgIHtkZXB0fVxyXG4gICAgICAgICAgICAgIDwvb3B0aW9uPlxyXG4gICAgICAgICAgICApKX1cclxuICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgIDwvbGFiZWw+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInctZnVsbCBib3JkZXItY29sbGFwc2UgYm9yZGVyIGJvcmRlci1ncmF5LTMwMFwiPlxyXG4gICAgICAgIDx0aGVhZCBjbGFzc05hbWU9XCJiZy1ncmF5LTEwMFwiPlxyXG4gICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwicC0yIGJvcmRlclwiPk5hbWU8L3RoPlxyXG4gICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwicC0yIGJvcmRlclwiPlBvc2l0aW9uPC90aD5cclxuICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT1cInAtMiBib3JkZXJcIj5EZXBhcnRtZW50PC90aD5cclxuICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgPC90aGVhZD5cclxuICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICB7ZW1wbG95ZWVzVG9TaG93Lm1hcCgoZW1wKSA9PiAoXHJcbiAgICAgICAgICAgIDx0ciBrZXk9e2VtcC5pZH0gY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwicC0yIGJvcmRlclwiPlxyXG4gICAgICAgICAgICAgICAgPExpbmsgaHJlZj17YC9lbXBsb3llZS8ke2VtcC5pZH1gfT57ZW1wLm5hbWV9PC9MaW5rPlxyXG4gICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cInAtMiBib3JkZXJcIj57ZW1wLnBvc2l0aW9ufTwvdGQ+XHJcbiAgICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cInAtMiBib3JkZXJcIj57ZW1wLmRlcGFydG1lbnR9PC90ZD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICkpfVxyXG4gICAgICAgIDwvdGJvZHk+XHJcbiAgICAgIDwvdGFibGU+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRW1wbG95ZWVMaXN0O1xyXG4iXSwibmFtZXMiOlsidXNlTGF6eVF1ZXJ5IiwidXNlUXVlcnkiLCJHRVRfQUxMX0VNUExPWUVFUyIsIkdFVF9FTVBMT1lFRVNfQllfREVQQVJUTUVOVCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTGluayIsIkVtcGxveWVlTGlzdCIsInNlbGVjdGVkRGVwYXJ0bWVudCIsInNldFNlbGVjdGVkRGVwYXJ0bWVudCIsImRhdGEiLCJhbGxEYXRhIiwibG9hZGluZyIsImxvYWRpbmdBbGwiLCJlcnJvciIsImVycm9yQWxsIiwiZmV0Y2hCeURlcGFydG1lbnQiLCJmaWx0ZXJlZERhdGEiLCJsb2FkaW5nRmlsdGVyZWQiLCJlcnJvckZpbHRlcmVkIiwidmFyaWFibGVzIiwiZGVwYXJ0bWVudCIsImFsbEVtcGxveWVlcyIsImdldEFsbEVtcGxveWVlcyIsImZpbHRlcmVkRW1wbG95ZWVzIiwiZ2V0RW1wbG95ZWVzQnlEZXBhcnRtZW50IiwiZGVwYXJ0bWVudHMiLCJBcnJheSIsImZyb20iLCJTZXQiLCJtYXAiLCJlIiwiZW1wbG95ZWVzVG9TaG93IiwicCIsIm1lc3NhZ2UiLCJkaXYiLCJjbGFzc05hbWUiLCJsYWJlbCIsInNlbGVjdCIsInZhbHVlIiwib25DaGFuZ2UiLCJ0YXJnZXQiLCJvcHRpb24iLCJkZXB0IiwidGFibGUiLCJ0aGVhZCIsInRyIiwidGgiLCJ0Ym9keSIsImVtcCIsInRkIiwiaHJlZiIsImlkIiwibmFtZSIsInBvc2l0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/EmployeeList.tsx\n"));

/***/ })

}]);